{"meta":{"title":"逸枫","subtitle":"欢迎来访","description":"从来没有真正的绝境，只有心灵的迷途","author":"M.","url":"https://dongzhu.ink","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-08-06T08:47:43.593Z","updated":"2020-08-06T08:47:43.593Z","comments":true,"path":"404.html","permalink":"https://dongzhu.ink/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-08-08T02:37:10.709Z","updated":"2020-08-08T02:37:10.709Z","comments":true,"path":"about/index.html","permalink":"https://dongzhu.ink/about/index.html","excerpt":"","text":"驿 站 简 介"},{"title":"相册","date":"2020-07-29T00:45:59.000Z","updated":"2020-08-07T01:52:16.035Z","comments":true,"path":"photo/index.html","permalink":"https://dongzhu.ink/photo/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-10-01T16:47:23.000Z","updated":"2020-08-07T05:44:22.812Z","comments":false,"path":"blog/categories/index.html","permalink":"https://dongzhu.ink/blog/categories/index.html","excerpt":"","text":""},{"title":"博客链接","date":"2020-08-08T02:56:54.535Z","updated":"2020-08-08T02:56:54.535Z","comments":true,"path":"blog/link/index.html","permalink":"https://dongzhu.ink/blog/link/index.html","excerpt":"示 例 博 客","text":"示 例 博 客"},{"title":"标签","date":"2018-09-12T15:24:17.000Z","updated":"2020-08-07T05:55:47.178Z","comments":false,"path":"blog/tags/index.html","permalink":"https://dongzhu.ink/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"TypeScript学习(1)-环境搭建","slug":"后端/TypeScript/TypeScript学习(1)-环境搭建","date":"2020-07-24T00:45:00.000Z","updated":"2020-08-08T02:46:49.429Z","comments":true,"path":"archives/50a9dd25.html","link":"","permalink":"https://dongzhu.ink/archives/50a9dd25.html","excerpt":"TypeScript环境安装1.全局安装包scriptnpm install typescript tslint ts-node -g 2. 项目环境包安装scriptnpm install typescript ts-loader -s #ts编译npm install clean-webpack-plugin cross-env html-webpack-plugin webpack webpack-cli webpack-dev-server -s","text":"TypeScript环境安装1.全局安装包scriptnpm install typescript tslint ts-node -g 2. 项目环境包安装scriptnpm install typescript ts-loader -s #ts编译npm install clean-webpack-plugin cross-env html-webpack-plugin webpack webpack-cli webpack-dev-server -s 3. 项目架构创建scriptmkdir client-typecd client-typenpm init -y # 直接初始化生成项目（注意刚刚创建项目名的名字（最好全小写），否者初始化出错）# 成功后 就会出现 package.jsontsc --init # 生成ts配置文件 &#123; &quot;name&quot;: &quot;client-side&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;source code of ts-learning&quot;, &quot;main&quot;: &quot;./src/index.ts&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --config ./build/webpack.config.js&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config ./build/webpack.config.js&quot; &#125;, &quot;keywords&quot;: [ &quot;typescript&quot; ], &quot;author&quot;: &quot;cheo&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;dependencies&quot;: &#123; &quot;clean-webpack-plugin&quot;: &quot;^3.0.0&quot;, &quot;cross-env&quot;: &quot;^7.0.2&quot;, &quot;html-webpack-plugin&quot;: &quot;^4.3.0&quot;, &quot;ts-loader&quot;: &quot;^8.0.1&quot;, &quot;typescript&quot;: &quot;^3.9.7&quot;, &quot;webpack&quot;: &quot;^4.43.0&quot;, &quot;webpack-cli&quot;: &quot;^3.3.12&quot;, &quot;webpack-dev-server&quot;: &quot;^3.11.0&quot; &#125;&#125; 项目结构client-type -build - webpack.config.js -src - api &#x2F;*项目接口*&#x2F; - assets &#x2F;*项目静态资源存放*&#x2F; - config &#x2F;*项目的配置文件*&#x2F; - components &#x2F;*项目组件*&#x2F; - example &#x2F;*学习ts代码的编写存放*&#x2F; - router &#x2F;*项目路由*&#x2F; - views &#x2F;*项目视图*&#x2F; - template -index.html &#x2F;*静态模板*&#x2F; - tools &#x2F;*项目工具*&#x2F; - utils &#x2F;*项目公共方法*&#x2F; - index.ts &#x2F;*入口文件*&#x2F; - typings - package.json - tsconfig.json &#x2F;*ts配置文件 tsc --init*&#x2F; - tslint.json - package-lock.json webpack.config.js配置设置1.入口文件配置,编译后生成名module.exports=&#123; entry:&#x27;./src/index.ts&#x27;, output:&#123; filename:&quot;main.js&quot; // 指定，输出文件名称 &#125;&#125; 2. 文件导包的后缀省略 这样 再导入文件时，只要是这样的文件，后缀都可以省略import &#39;./example/interface_.ts&#39; =&gt; import &#39;./example/interface_&#39; module.exports=&#123; resolve:&#123; extensions:[&#x27;.ts&#x27;,&#x27;.tsx&#x27;,&#x27;.js&#x27;] &#125;&#125; 3. module 文件编译处理 编译时， 针对不通的文件换换编译成浏览器能识别的，对ts文件的转换需要下载相应的扩展包 module.exports=&#123; module:&#123; rules:[&#123; test:/\\.tsx?$/, use:&#x27;ts-loader&#x27;, exclude:/node_modules/ &#125;] &#125;,&#125; 启动配置const &#123;CleanWebpackPlugin&#125; = require(&quot;clean-webpack-plugin&quot;)const htmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const webpack = require(&#x27;webpack&#x27;)module.exports=&#123; devtool:process.env.NODE_ENV ===&#x27;production&#x27;? false: &#x27;inline-source-map&#x27;, // 启动端口设置， 代理配置 devServer:&#123; contentBase:&#x27;./dist&#x27;, stats:&#x27;errors-only&#x27;, compress:false, host:&#x27;localhost&#x27;, port:8088 &#125;, // 一些插件配置 plugins:[ new webpack.HotModuleReplacementPlugin() ,// new 一个热更新的模块 new CleanWebpackPlugin(), // 注意更新后的使用方式， new htmlWebpackPlugin(&#123; template:&#x27;./src/template/index.html&#x27; , filename: &#x27;index.html&#x27; // 指定生成页面的名称 &#125;) ]&#125; 第一行代码 配置完成后， 开始写代码吧 // 再example 目录下 创建一个文件， 写入代码console.log(&#x27;hello world&#x27;);// index.ts 导入该文件 ，运行import ./example/xxx 个人学习的一些资料， 文档,视频分享","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Typescript","slug":"前端/typescript","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/typescript/"}],"tags":[{"name":"TypeScript","slug":"typescript","permalink":"https://dongzhu.ink/tags/typescript/"},{"name":"环境配置","slug":"环境配置","permalink":"https://dongzhu.ink/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"author":"Dong"},{"title":"postgresql查询","slug":"数据库/postgresql查询命令","date":"2020-07-13T16:46:00.000Z","updated":"2020-08-08T06:27:37.690Z","comments":true,"path":"archives/bee85523.html","link":"","permalink":"https://dongzhu.ink/archives/bee85523.html","excerpt":"公司使用的PostgreSql库，学习一下，写一些视图查询， 跟mysql基本上是长不多，在某些地方存在细微差距， 底层原理咋也不过多深入， 满足了工作中日常使用 window安装 下载地址 https://www.enterprisedb.com/downloads/postgres-postgresql-downloads 下一步，全勾上，设置密码， 去掉勾选，直接点 Finish，完成 设置pgAdmin4 为中文 点击 file-1-选择语言 创建数据库python操作postgresqlimport psycopg2conn = psycopg2.connect(database=&quot;postgres&quot;, user=&quot;postgres&quot;, password=&quot;123456789&quot;, host=&quot;10.128.212.164&quot;, port=&quot;5432&quot;)cur = conn.cursor() # 创建指针对象cur.execute(&quot;select * from statu&quot;)results = cur.fetchall()conn.commit()cur.close()conn.close()","text":"公司使用的PostgreSql库，学习一下，写一些视图查询， 跟mysql基本上是长不多，在某些地方存在细微差距， 底层原理咋也不过多深入， 满足了工作中日常使用 window安装 下载地址 https://www.enterprisedb.com/downloads/postgres-postgresql-downloads 下一步，全勾上，设置密码， 去掉勾选，直接点 Finish，完成 设置pgAdmin4 为中文 点击 file-1-选择语言 创建数据库python操作postgresqlimport psycopg2conn = psycopg2.connect(database=&quot;postgres&quot;, user=&quot;postgres&quot;, password=&quot;123456789&quot;, host=&quot;10.128.212.164&quot;, port=&quot;5432&quot;)cur = conn.cursor() # 创建指针对象cur.execute(&quot;select * from statu&quot;)results = cur.fetchall()conn.commit()cur.close()conn.close() python Pandas 读取和写入数据库读取数据库import psycopg2import pandas as pd# 配置文件localhost=dict( database=&quot;demo1&quot;, user=&quot;postgres&quot;, password=&quot;123456789&quot;, host=&quot;localhost&quot;, port=&quot;5432&quot;)def redPostGresql(config,sql): &quot;&quot;&quot;读取数据 config配置文件 sql语句&quot;&quot;&quot; conn = psycopg2.connect(**config) # 连接数据库 try: data = pd.read_sql(sql, con=conn) # 读取数据库数据 return data except Exception as e: print(e) return False finally: conn.close()# 直接获取数据库数据， 以DataFrame格式返回，（）IfsstepID = redPostGresql(cnctum0pgsql02,&#x27;SELECT * FROM &quot;Report&quot;.&quot;IFSStepID&quot;&#x27;) 写入数据库from sqlalchemy import create_engineimport pandas as pd# 创建连接engine = create_engine(&quot;postgresql://postgres:123456789@localhost:5432/demo1&quot;) # 获取要写入的数据，posData = pd.DataFrame(snWIPlist)try: &quot;&quot;&quot;if_exists： * fail: Raise a ValueError. * replace: Drop the table before inserting new values. * append: Insert new values to the existing table. &quot;&quot;&quot; posData.to_sql(&#x27;wip&#x27;,engine,index=False,if_exists=&#x27;replace&#x27;) # 写入数据库except Exception as e: print(e) LIKE 模糊查询% 任意0个和多个字符 _ 任意单个字符 [] [正则表达式] [^]SELECT * FROM &quot;public&quot;.ifactoryreportdata WHERE daytime &gt;=&#x27;2020-07-09&#x27; and daytime &lt;=&#x27;2020-07-23&#x27; and reportname LIKE &#x27;ic(ng)%&#x27; 时间段查询方法一：select * from user_info where create_date&gt;= &#x27;2015-07-01&#x27; and create_date &lt; &#x27;2015-08-15&#x27;; 方法二：select * from user_info where create_date between &#x27;2015-07-01&#x27; and &#x27;2015-08-15&#x27;; 方法三：select * from user_info where create_date &gt;= &#x27;2015-07-01&#x27;::timestamp and create_date &lt; &#x27;2015-08-15&#x27;::timestamp; 方法四： select * from user_info where create_date between to_date(&#x27;2015-07-01&#x27;,&#x27;YYYY-MM-DD&#x27;) and to_date(&#x27;2015-08-15&#x27;,&#x27;YYYY-MM-DD&#x27;);select * from user_info where create_date between to_date(&#x27;2015-07-01&#x27;,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;) and to_date(&#x27;2015-08-15&#x27;,&#x27;yyyy-mm-dd hh24:mi:ss&#x27;); 表连接union不合并重复数据select * from T1 union all select * from T2 union合并重复数据select * from T1 union select * from T2 except 左查询中返回右查询没有找到的所有非重复值intersect 两个结果集的交集（即两个查询都返回的所有非重复值）关联查询 inner join 内连接查询 (2表 合并，显示相同的数据) SELECT a.*,b.* FROM table_a a INNER JOIN table_b b ON a.id=b.id left jion 左关联查询 SELECT a.*,b.* FROM table_a a LEFT JOIN table_b b ON a.id=b.id right join 右关联查询 左连接-内连接 （取左表的部分集合，但又不存在右表中） SELECT a.*,b.* FROM table_a a LEFT JOIN table_b b ON a.id=b.id WHERE b.id IS NULL -- SELECT a.*,b.* FROM table_a a LEFT JOIN table_b b ON a.id=b.id WHERE b.id IS NULL 只需要几秒钟中完成 -- SELECT a.*,b.* FROM table_a a LEFT JOIN table_b b ON a.id !=b.id 谨慎测试，单机十几万的数据，直接把库跑挂了 -- 根据测试，，你会发现， 后者比前者的查询速度相差太大了 右连接-内连接 (取有表的部分数据，但又不存在左表中) SELECT a.*,b.* FROM table_a a RIGHT JOIN table_b b ON a.id=b.id WHERE a.id IS NULL 创建临时表查询 whit WITH abcd AS (select * from table) 语法 -- 例如 WITH abcd AS ( SELECT a.&quot;SN&quot;, a.&quot;Process&quot;, a.&quot;ProcessID&quot;, to_char(now(), &#x27;yyyy-mm-dd&#x27;::text) AS lasttime, a.&quot;Project&quot; FROM &quot;Report&quot;.&quot;mainSnWithFirstTimeStationAndResult&quot; a WHERE (to_char(now(), &#x27;yyyy-mm-dd&#x27;::text) = to_char(a.&quot;FirstTime&quot;, &#x27;yyyy-mm-dd&#x27;::text)) ) SELECT a.&quot;SN&quot;, upper((a.&quot;Process&quot;)::text) AS process, a.lasttime, a.&quot;ProcessID&quot;, a.&quot;Project&quot; FROM abcd a WHERE (&quot;RawData&quot;.isnumeric(a.&quot;Process&quot;) &lt;&gt; true)UNION ALL SELECT a.&quot;SN&quot;, upper(b.&quot;StepName&quot;) AS process, a.lasttime, a.&quot;ProcessID&quot;, a.&quot;Project&quot; FROM (abcd a JOIN &quot;Report&quot;.&quot;IFSStepID&quot; b ON (((a.&quot;Process&quot;)::text = b.&quot;StepID&quot;))); -- 创建 临时表 abcd， -- 创建多个临时表， 只需要用 , 分割就好， 最后一定要有sql语句-- 多个语句语法语法WITH so1 AS (),so2 AS(),so3 AS () 排序ORDER BY 查询后，按什么字段排序 升序：ASC；降序：DESC； -- 例句： 聚合查询,分组 GROUP BY我们可以先从字面上来理解，GROUP表示分组，BY后面写字段名，就表示根据哪个字段进行分组，如果有用Excel比较多的话，GROUP BY比较类似Excel里面的透视表。GROUP BY必须得配合聚合函数来用，分组之后你可以计数（COUNT），求和（SUM），求平均数（AVG）等 常用的 聚合查询 count() 计数 sum() 求和 avg() 平均数 max() 最大值 min() 最小值 -- 以a.customer, a.factory, a.lineid, a.reportprocess, a.wip分组， 计算sum(a.sn) 的值SELECT a.customer, a.factory, a.lineid, a.reportprocess, a.wip, to_char(now(), &#x27;yyyy-mm-dd&#x27;::text) AS lasttime, sum(a.sn) AS wipsn FROM stationamecount a GROUP BY a.customer, a.factory, a.lineid, a.reportprocess, a.wip; HAVING 筛选 HAVING是对于GROUP BY对象进行筛选， 可以使用聚合函数筛选 SELECT a.customer, a.factory, a.lineid, a.reportprocess, a.wip, to_char(now(), &#x27;yyyy-mm-dd&#x27;::text) AS lasttime, sum(a.sn) AS wipsn FROM stationamecount a GROUP BY a.customer, a.factory, a.lineid, a.reportprocess, a.wip HAVING a.wip=&#x27;yes&#x27; -- 筛选除 wip=yes的 组， Postgresql 子查询 子查询或称为内部查询、嵌套查询，指的是在 PostgreSQL 查询中的 WHERE 子句中嵌入查询语句 函数集常用函数initcap(首字母大写)lower(字母全部小写)upper(字母全部大写)日期函数now() 获取当前日期localtime 当前时间 SELECT localtimelocaltimestamp 当前日期和时间 SELECT localtimestampcurrent_date 当前日期 select current_date;to_char(now(), &#x27;yyyy-mm-dd&#x27;::text) -- 2020-07-14 timeofday()当前日期和时间SELECT timeofday()-- Tue Jul 14 09:32:24.894371 2020 HKT -- 时间计算select now() + interval &#x27;1 years&#x27; -- 一年后 select now() + interval &#x27;1 month&#x27; -- 一月后select now() - interval &#x27;3 week&#x27; --三周后select now() + &#x27;10 min&#x27; -- 10分钟后select now() + &#x27;10 D&#x27; -- 一天后/*Abbreviation Meaning Y Years M Months (in the date part) W Weeks D Days H Hours M Minutes (in the time part) S Seconds*/ age() 计算2个时间差select age(timestamp &#x27;2019-09-15&#x27;); -- 9 mons 29 daysselect age(now(), timestamp &#x27;2022-02-05&#x27;); -- -1 years -6 mons -21 days -14:12:19.288452select age(now(), timestamp &#x27;2019-02-05&#x27;); -- 1 year 5 mons 9 days 09:48:08.012659 EXTRACT(field FROM source)时间字段截取-- 获取年select extract(year from now()); -- 获取月份select extract(month from now()); -- 获取 天数select extract(day from timestamp &#x27;2013-04-13&#x27;);SELECT EXTRACT(DAY FROM INTERVAL &#x27;40 days 1 minute&#x27;);-- 查看今天是一年中的多少天select extract(doy from now()); 转换函数to_number(数值类型的字符):将字符转换为数值to_char(数值或者是日期):将数值或者日期转换为字符to_date(日期格式的字符)：将字符转换为日期自定义函数函数基本语法 实践中，官方函数没法满足需求，就需要自己写函数， 那么了解 函数的语法构建 自定义函数像内置函数一样返回标量值，也可以将结果集用表格变量返回。sql函数必须有返回值 自定义函数整理判断为存数字函数CREATEOR REPLACE FUNCTION isnumeric (txtStr VARCHAR) RETURNS BOOLEAN AS $$BEGIN RETURN txtStr ~ &#x27;^([0-9]+[.]?[0-9]*|[.][0-9]+)$&#x27; ;END ; $$ LANGUAGE &#x27;plpgsql&#x27;; ALTER TABLE 曾删表的列 alter table命令用于添加、修改、删除一张已经存在表的列, 也可以添加，删除约束 语法 -- table_name ：表名 ; column_name：新列名; datatype：数据类型ALTER TABLE table_name ADD column_name datatype; 视图 视图： 就是查询语句的别名，生成的新的表 CREATE VIEW viewName AS select name,id,age FROM student WITH id&gt;5;-- 这样 viewName 就是一个视图， 可以理解为一张新的表在数据库了 事务 一组操作，要么成功，要么失败 Postgresql 触发器 触发器是数据库的回调函数，它会在指定的数据库事件发生时自动执行/调用 PostgreSQL 触发器 触发情况！ 在执行操作之前（在检查约束并尝试插入、更新或删除之前）。 在执行操作之后（在检查约束并插入、更新或删除完成之后）。 更新操作（在对一个视图进行插入、更新、删除时） Postgresql索引 索引是加速搜索引擎检索数据的一种特殊表查询。简单地说，索引是一个指向表中数据的指针。 方便快速检索数据，创建的索引多了， 也会影响查询效率 语法： 使用 CREATE INDEX 语句创建索引，它允许命名索引，指定表及要索引的一列或多列，并指示索引是升序排列还是降序排列。索引也可以是唯一的，与 UNIQUE 约束类似，在列上或列组合上防止重复条目。 语法创建索引： CREATE INDEX index_name ON table_name;删除所有： drop index index_name 索引类型 类型 语法 单列索引 CREATE INDEX index_name ON table_name(column_name); 组合索引 CREATE INDEX index_name ON table_name(column1_name,column2_name); 唯一索引 CREATE UNIQUE INDEX index_name on table_name (column_name); 局部索引 CREATE INDEX index_name on table_name (conditional) 隐式索引 建表时由数据库服务器自动创建，一般为主键约束和唯一约束 不管是单列索引还是组合索引，该索引必须是在WHERE子句的过滤条件中使用非常频繁的列。唯一索引的使用，一方面提高了查询性能，同时也保护了数据的完整性，不允许任何重复的值插入到表中。 什么情况下避免使用索引？ 表数据较小时不需要使用索引 进行频繁插入或更新操作的表不需要使用 不应该使用在含有大量的NULL值的列上 不使用在频繁操作的列上 (to_char(now(), &#x27;yyyy-mm-dd&#x27;::text) = to_char(a.&quot;LastTime&quot;, &#x27;yyyy-mm-dd&#x27;::text) SELECT a.*,b.wipsn,b.wip FROM pvder as a LEFT JOIN &quot;RawData&quot;.&quot;wipCounts&quot; as b ON upper(a.factory) = b.factory and upper(a.customer)=b.customer and upper(a.lineid) = b.lineid and upper(a.reportprocess) = b.reportprocess and a.date = b.lasttime WHERE a.date =b.lasttime----------------------SELECT a.*,b.wip FROM pvder as a LEFT JOIN &quot;RawData&quot;.&quot;wipCount&quot; as b ON upper(a.factory) = b.factory and upper(a.customer)=b.customer and upper(a.lineid) = b.lineid and upper(a.reportprocess) = b.reportprocessand a.date =to_char(now(), &#x27;yyyy-mm-dd&#x27;) WHERE a.date = to_char(now(), &#x27;yyyy-mm-dd&#x27;)","categories":[{"name":"数据库","slug":"数据库","permalink":"https://dongzhu.ink/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PostgreSql","slug":"数据库/postgresql","permalink":"https://dongzhu.ink/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/postgresql/"}],"tags":[{"name":"PostgreSql","slug":"postgresql","permalink":"https://dongzhu.ink/tags/postgresql/"}],"author":"M."},{"title":"koa.js的路由请求（2）","slug":"后端/koajs/koa.js的路由请求（2）","date":"2020-06-15T14:57:00.000Z","updated":"2020-08-08T06:25:39.459Z","comments":true,"path":"archives/2d20ecd4.html","link":"","permalink":"https://dongzhu.ink/archives/2d20ecd4.html","excerpt":"koa.js中路由的理解function router(url)&#123; let page = &#x27;404.html&#x27; switch(url)&#123; case &#x27;/&#x27;: page=&#x27;index.html&#x27;; case &#x27;index&#x27;: page=&#x27;index&#x27;; case &#x27;/todo&#x27;: page=&#x27;&#x27;&#125; &#125;","text":"koa.js中路由的理解function router(url)&#123; let page = &#x27;404.html&#x27; switch(url)&#123; case &#x27;/&#x27;: page=&#x27;index.html&#x27;; case &#x27;index&#x27;: page=&#x27;index&#x27;; case &#x27;/todo&#x27;: page=&#x27;&#x27;&#125; &#125; 方法一 router.use(&#x27;/&#x27;, async ctx=&gt;&#123; if (ctx.method==&#x27;GET&#x27;)&#123; ctx.body=&#123;msg:&quot;测试成功&quot;&#125; &#125; &#125;) Koa-bodyparser 中间件","categories":[{"name":"后端","slug":"后端","permalink":"https://dongzhu.ink/categories/%E5%90%8E%E7%AB%AF/"},{"name":"node","slug":"后端/node","permalink":"https://dongzhu.ink/categories/%E5%90%8E%E7%AB%AF/node/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://dongzhu.ink/tags/node-js/"},{"name":"koa.js","slug":"koa-js","permalink":"https://dongzhu.ink/tags/koa-js/"}],"author":"M."},{"title":"nodejs环境配置","slug":"后端/nodejs/nodejs环境配置","date":"2020-06-12T15:49:00.000Z","updated":"2020-08-07T08:45:04.778Z","comments":true,"path":"archives/12affc36.html","link":"","permalink":"https://dongzhu.ink/archives/12affc36.html","excerpt":"node.js 相关配置 node.js Windons安装配置官网下载直接安装（选择路径安装）找到安装路径，下创建2个文件node_cache, node_gloal然后在cmd中输入npm config set prefix &quot;D:\\Program Files\\nodejs\\node_global&quot;npm config set cache &quot;D:\\Program Files\\nodejs\\node_cache&quot;在在环境配置中修改系统变量中 添加 NODE_PATH D:\\Program Files\\nodejs\\node_cache个人变量中path 中把原来的npm路径修改 成 D:\\Program Files\\nodejs\\node_global这样下载的全局安装就会在node_global 文件中","text":"node.js 相关配置 node.js Windons安装配置官网下载直接安装（选择路径安装）找到安装路径，下创建2个文件node_cache, node_gloal然后在cmd中输入npm config set prefix &quot;D:\\Program Files\\nodejs\\node_global&quot;npm config set cache &quot;D:\\Program Files\\nodejs\\node_cache&quot;在在环境配置中修改系统变量中 添加 NODE_PATH D:\\Program Files\\nodejs\\node_cache个人变量中path 中把原来的npm路径修改 成 D:\\Program Files\\nodejs\\node_global这样下载的全局安装就会在node_global 文件中 npm 修改源// 设置 淘宝镜像源npm config set registry https://registry.npm.taobao.org// 查看 使用的 镜像源npm config get registry// 安装 淘宝镜像源npm install -g cnpm --registry=https://registry.npm.taobao.org centos下安装script稳定版：1. 软件预存：$ yum clean all &amp;&amp; yum makecache fast$ yum install -y gcc-c++ make$ curl -sL https://rpm.nodesource.com/setup_10.x | sudo -E bash -2. sudo yum install nodejs -y3. node -v， npm -v最新版安装：$ yum clean all &amp;&amp; yum makecache fast$ yum install -y gcc-c++ make$ curl -sL https://rpm.nodesource.com/setup_12.x | sudo -E bash - 相关包安装一. nrm 安装 1. npm i nrm -g全局安装`nrm`包； 2. nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 3. nrm use npm 或nrm use taobao`切换不同的镜像源地址； js动画库 Three.js Anime.js Mo.js Velocity.js Popmotion Vivus GreenSock js Scroll Reveal Hover(css) Kute.js Typed.js echarts http://jxhx2.yangqq.com/blog/#https://www.yangqq.com/link.htmlhttp://ww.aliwen.vip/https://shawnzeng.com/https://blog.csdn.net/weixin_44387725/article/details/90904191 https://www.bilibili.com/video/av83101450?p=26 https://www.bilibili.com/video/av88732281?p=46 https://www.cnblogs.com/AlexanderZhao/p/LearnCSSGrid.html css","categories":[{"name":"后端","slug":"后端","permalink":"https://dongzhu.ink/categories/%E5%90%8E%E7%AB%AF/"},{"name":"node","slug":"后端/node","permalink":"https://dongzhu.ink/categories/%E5%90%8E%E7%AB%AF/node/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://dongzhu.ink/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"node.js","slug":"node-js","permalink":"https://dongzhu.ink/tags/node-js/"}],"author":"M."},{"title":"koa.js项目架构搭建(1)","slug":"后端/koajs/koa.js项目架构搭建(1)","date":"2020-06-12T15:45:00.000Z","updated":"2020-08-08T02:03:43.508Z","comments":true,"path":"archives/89dec30a.html","link":"","permalink":"https://dongzhu.ink/archives/89dec30a.html","excerpt":"pycharm最新方法 环境搭建$ nvm install 7$ npm i koa$ node my-koa-app.js","text":"pycharm最新方法 环境搭建$ nvm install 7$ npm i koa$ node my-koa-app.js","categories":[{"name":"后端","slug":"后端","permalink":"https://dongzhu.ink/categories/%E5%90%8E%E7%AB%AF/"},{"name":"node","slug":"后端/node","permalink":"https://dongzhu.ink/categories/%E5%90%8E%E7%AB%AF/node/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://dongzhu.ink/tags/node-js/"},{"name":"koa.js","slug":"koa-js","permalink":"https://dongzhu.ink/tags/koa-js/"}],"author":"M."},{"title":"js-数组和对象类型判断","slug":"前端/javaScript/js-数组和对象类型判断","date":"2020-05-18T07:07:00.000Z","updated":"2020-08-08T01:37:36.634Z","comments":true,"path":"archives/6091f578.html","link":"","permalink":"https://dongzhu.ink/archives/6091f578.html","excerpt":"js 如何判断数组和对象的类型在使用 typeOf 判断的时候 都是 Object 在es6中 可以使用 instanceof Array.isArray(ary) constructor let art = [1,2,3]console.log(art instanceof Array)console.log(art.constructor === Array)console.log(Array.isArray(art)) 考虑兼容性问题可以使用 Object.prototype.toString.call()来判断 Object.prototype.toString.call(art) === &quot;[object Array]&quot;// 如果是对象&#123;&#125;Object.prototype.toString.call(art) === &quot;[object object]&quot;","text":"js 如何判断数组和对象的类型在使用 typeOf 判断的时候 都是 Object 在es6中 可以使用 instanceof Array.isArray(ary) constructor let art = [1,2,3]console.log(art instanceof Array)console.log(art.constructor === Array)console.log(Array.isArray(art)) 考虑兼容性问题可以使用 Object.prototype.toString.call()来判断 Object.prototype.toString.call(art) === &quot;[object Array]&quot;// 如果是对象&#123;&#125;Object.prototype.toString.call(art) === &quot;[object object]&quot;","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://dongzhu.ink/tags/javascript/"}],"author":"M."},{"title":"css权重和属性继承","slug":"前端/css权重和属性继承","date":"2020-05-18T07:02:00.000Z","updated":"2020-08-08T01:40:54.881Z","comments":true,"path":"archives/f4ae9910.html","link":"","permalink":"https://dongzhu.ink/archives/f4ae9910.html","excerpt":"可继承的样式1.字体系列属性 font，font-family，font-weight，font-size，font-style，font-variant，font-stretch，font-size-adjust 2.文本系列属性 text-indent，text-align，line-height，word-spacing，letter-spacing，text-transform，direction，color 3.元素可见性 visibility 4.表格布局属性 caption-side，border-collapse，border-spacing，empty-cells，table-layout 5.列表布局属性 list-style-type，list-style-image，list-style-position，list-style 6.生成内容属性 quotes 7.光标属性 cursor 8.页面样式属性 page，page-break-inside，windows，orphans 9.声音样式属性 speak，speak-punctuation，speak-numeral，speak-header，speech-rate，volume，voice-family，pitch，pitch-range，stress，richness，azimuth，elevation 优先级算法如何计算1.优先级就近原则，同权重情况下样式定义最近者为准； 2.载入样式以最后载入的定位为准； 3.!important &gt; id &gt; class &gt; tag； 4.important 比 内联优先级高，但内联比id要高,id比class高","text":"可继承的样式1.字体系列属性 font，font-family，font-weight，font-size，font-style，font-variant，font-stretch，font-size-adjust 2.文本系列属性 text-indent，text-align，line-height，word-spacing，letter-spacing，text-transform，direction，color 3.元素可见性 visibility 4.表格布局属性 caption-side，border-collapse，border-spacing，empty-cells，table-layout 5.列表布局属性 list-style-type，list-style-image，list-style-position，list-style 6.生成内容属性 quotes 7.光标属性 cursor 8.页面样式属性 page，page-break-inside，windows，orphans 9.声音样式属性 speak，speak-punctuation，speak-numeral，speak-header，speech-rate，volume，voice-family，pitch，pitch-range，stress，richness，azimuth，elevation 优先级算法如何计算1.优先级就近原则，同权重情况下样式定义最近者为准； 2.载入样式以最后载入的定位为准； 3.!important &gt; id &gt; class &gt; tag； 4.important 比 内联优先级高，但内联比id要高,id比class高 CSS 选择符有哪些 1.id选择器（#id）2.类选择器（.class）3.标签选择器（div，h1，p）4.相邻选择器（h1 + p）5.子选择器（ul &gt; li）6.后代选择器（li a）7.通配符选择器（ * ）8.属性选择器（a[title]）9.伪类选择器（a:hover，li:nth-child）","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"https://dongzhu.ink/tags/css/"}],"author":"M."},{"title":"npm项目初始化","slug":"前端/webpack/npm项目初始化","date":"2020-05-10T16:23:00.000Z","updated":"2020-08-08T01:40:54.912Z","comments":true,"path":"archives/d478e240.html","link":"","permalink":"https://dongzhu.ink/archives/d478e240.html","excerpt":"初始化环境 npm init 初始化项目， 一值 ent 创建 scr 文件夹 index.js / index.html npm install webpack webpack-cli -save-dev 创建 webpack.dev.config.js 配置 module.exports =&#123; entry: &#x27;./scr/index.js&#x27;, // 入口文件路径 output:&#123; path: __dirname, filename:&#x27;./releasse/bundle.js&#x27; // &#125;&#125;","text":"初始化环境 npm init 初始化项目， 一值 ent 创建 scr 文件夹 index.js / index.html npm install webpack webpack-cli -save-dev 创建 webpack.dev.config.js 配置 module.exports =&#123; entry: &#x27;./scr/index.js&#x27;, // 入口文件路径 output:&#123; path: __dirname, filename:&#x27;./releasse/bundle.js&#x27; // &#125;&#125; npm install webpack-dev-server html-webpack-plugin --save-dev npm i bacbel-core babel-loader babel-polyfill babel-preset-es2015 babel-prset-latest .babelrc","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://dongzhu.ink/tags/webpack/"},{"name":"npm","slug":"npm","permalink":"https://dongzhu.ink/tags/npm/"}],"author":"M."},{"title":"js-time时间转换操作","slug":"前端/javaScript/js-time时间转换操作","date":"2020-05-06T07:19:00.000Z","updated":"2020-08-08T01:37:36.620Z","comments":true,"path":"archives/44876dc0.html","link":"","permalink":"https://dongzhu.ink/archives/44876dc0.html","excerpt":"将时间戳和时间格式转成，str类型格林尼治2019-03-19T16:00:00.000Z ==&gt;&gt; 2019-03-20 00:00:00 与北京时间8小时时差 let formDate = dateForm=&gt;&#123; if (dateForm === &#x27;&#x27;)return &#x27;&#x27;; const dateee = new Date(dateForm).toJSON(); var date = new Date(+new Date(dateee)+ 8 * 3600 * 1000).toISOString().replace(/T/g,&#x27; &#x27;).replace(/\\.[\\d]&#123;3&#125;Z/,&#x27;&#x27;);return date;&#125;","text":"将时间戳和时间格式转成，str类型格林尼治2019-03-19T16:00:00.000Z ==&gt;&gt; 2019-03-20 00:00:00 与北京时间8小时时差 let formDate = dateForm=&gt;&#123; if (dateForm === &#x27;&#x27;)return &#x27;&#x27;; const dateee = new Date(dateForm).toJSON(); var date = new Date(+new Date(dateee)+ 8 * 3600 * 1000).toISOString().replace(/T/g,&#x27; &#x27;).replace(/\\.[\\d]&#123;3&#125;Z/,&#x27;&#x27;);return date;&#125; // 将字符串2019-03-20 00:00:00，转成 Date格式Sat Apr 20 2019 00:00:00 GMT+0800 (中国标准时间)let getDate= strDate=&gt; &#123; const st = strDate; const a = st.split(&quot; &quot;); const b = a[0].split(&quot;-&quot;); const c = a[1].split(&quot;:&quot;); const date = new Date(b[0], b[1], b[2], c[0], c[1], c[2]); return date; &#125; // 将时间戳1553547600000 转 // 2019-03-25T21:00:00.000Zlet formatDate = datatime=&gt;&#123; let timestamp = datatime; let newDate = new Date(datatime) // let newDate = new Date(datatime+8*36000*1000) newDate.getTime(timestamp*1000) // console.log(newDate.toDateString());//Mon Mar 11 2019 // console.log(newDate.toGMTString()); //Mon, 11 Mar 2019 06:55:07 GMT // console.log(newDate.toISOString()); //2019-03-11T06:55:07.622Z return newDate.toISOString()&#125; 时间倒计时时间计时器","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://dongzhu.ink/tags/javascript/"}],"author":"M."},{"title":"计算机读书-文件收藏","slug":"文件收藏","date":"2020-05-02T16:08:00.000Z","updated":"2020-08-08T02:45:20.403Z","comments":true,"path":"archives/91580c5e.html","link":"","permalink":"https://dongzhu.ink/archives/91580c5e.html","excerpt":"coding只能部署不超过134217728 字节大小的博客， 文件将部署到其它服务上 高等数据-算法 python电子书籍 暂无 疯狂Python讲义 Flask Web开发 基于Python的Web应用开发实战 Flask+Web开发实战：入门、进阶与原理解析（李辉著+） 利用Python进行数据分析","text":"coding只能部署不超过134217728 字节大小的博客， 文件将部署到其它服务上 高等数据-算法 python电子书籍 暂无 疯狂Python讲义 Flask Web开发 基于Python的Web应用开发实战 Flask+Web开发实战：入门、进阶与原理解析（李辉著+） 利用Python进行数据分析 前端电子书 可看 JavaScript权威指南(第七版)-中文 Linux 暂无 计算机科学导论 鸟哥的Linux私房菜_第四版 常用ARM指令集及汇编 可看 常用ARM指令集及汇编-点击下载 https://demo.jerryc.me/","categories":[{"name":"工具","slug":"工具","permalink":"https://dongzhu.ink/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"https://dongzhu.ink/tags/%E6%94%B6%E8%97%8F/"}],"author":"M."},{"title":"axios请求封装","slug":"前端/vue篇/axios请求封装","date":"2020-05-02T12:06:00.000Z","updated":"2020-08-08T01:40:54.924Z","comments":true,"path":"archives/c88f0c02.html","link":"","permalink":"https://dongzhu.ink/archives/c88f0c02.html","excerpt":"项目中对 axios 请求的封装 axios.js 文件 import axios from &#x27;axios&#x27;const baseUrl = process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/api/&#x27;: &#x27;/&#x27;class HttpRequest &#123; // 参数初始化 constructor (baseUrl = baseURL) &#123; this.baseUrl = baseUrl; this.queue = &#123;&#125; &#125; getInsideConfig () &#123; const config = &#123; baseURL: this.baseUrl, headers: &#123; // &#125; &#125;; return config &#125; distroy (url) &#123; delete this.queue[url] if (!Object.keys(this.queue).length) &#123; // Spin.hide() &#125; &#125; interceptors (instance, url) &#123; // 请求拦截 instance.interceptors.request.use(config =&gt; &#123; // 添加全局的loading... if (!Object.keys(this.queue).length) &#123; // Spin.show() &#125; this.queue[url] = true; config.headers[&#x27;Authorization&#x27;] = getToken() return config &#125;, error =&gt; &#123; return Promise.reject(error) &#125;) // 对请求结果拦截处理 instance.interceptors.response.use(res =&gt; &#123; this.distroy(url) const &#123; data &#125; = res return data &#125;, error =&gt; &#123; this.distroy(url) return Promise.reject(error.response.data) &#125;) &#125; request (options) &#123; const instance = axios.create() options = Object.assign(this.getInsideConfig(), options) this.interceptors(instance, options.url) return instance(options) &#125;&#125;const axios = new HttpRequest()export default axios// export default HttpRequest","text":"项目中对 axios 请求的封装 axios.js 文件 import axios from &#x27;axios&#x27;const baseUrl = process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/api/&#x27;: &#x27;/&#x27;class HttpRequest &#123; // 参数初始化 constructor (baseUrl = baseURL) &#123; this.baseUrl = baseUrl; this.queue = &#123;&#125; &#125; getInsideConfig () &#123; const config = &#123; baseURL: this.baseUrl, headers: &#123; // &#125; &#125;; return config &#125; distroy (url) &#123; delete this.queue[url] if (!Object.keys(this.queue).length) &#123; // Spin.hide() &#125; &#125; interceptors (instance, url) &#123; // 请求拦截 instance.interceptors.request.use(config =&gt; &#123; // 添加全局的loading... if (!Object.keys(this.queue).length) &#123; // Spin.show() &#125; this.queue[url] = true; config.headers[&#x27;Authorization&#x27;] = getToken() return config &#125;, error =&gt; &#123; return Promise.reject(error) &#125;) // 对请求结果拦截处理 instance.interceptors.response.use(res =&gt; &#123; this.distroy(url) const &#123; data &#125; = res return data &#125;, error =&gt; &#123; this.distroy(url) return Promise.reject(error.response.data) &#125;) &#125; request (options) &#123; const instance = axios.create() options = Object.assign(this.getInsideConfig(), options) this.interceptors(instance, options.url) return instance(options) &#125;&#125;const axios = new HttpRequest()export default axios// export default HttpRequest 使用","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://dongzhu.ink/tags/vue/"}],"author":"M."},{"title":"js中数组常用方法","slug":"前端/javaScript/js中数组常用方法","date":"2020-05-02T04:49:00.000Z","updated":"2020-08-08T01:40:54.930Z","comments":true,"path":"archives/98ca42b0.html","link":"","permalink":"https://dongzhu.ink/archives/98ca42b0.html","excerpt":"filter 用来过滤数组，返回一个新的数组，filter方法需要在循环的时候判断一下是true还是false，是true才会返回这个元素；接收一个方法，该方法可传入三个参数，第一个为数组的一个元素，第二位为该元素的下标，第三个为原数组。 let ary = [1,2,3,4,22,44,22,1,90];let ary2 = ary.filter((value,key,arr)=&gt;&#123; console.log(value); //=&gt; 值 console.log(key); // =&gt; 索引 console.log(arr); // =&gt; ary数组 return value &gt;10? true:false; &#125;);console.log(ary); // 不变console.log(ary2) //[22, 44, 22, 90] 去重 let ary= [2,3,23,12,3,1,2,3,4,56,4];let new_ary = ary.filter((x,index,self)=&gt;self.indexOf(x)===index)//new_ary =&gt;[2, 3, 23, 12, 1, 4, 56]","text":"filter 用来过滤数组，返回一个新的数组，filter方法需要在循环的时候判断一下是true还是false，是true才会返回这个元素；接收一个方法，该方法可传入三个参数，第一个为数组的一个元素，第二位为该元素的下标，第三个为原数组。 let ary = [1,2,3,4,22,44,22,1,90];let ary2 = ary.filter((value,key,arr)=&gt;&#123; console.log(value); //=&gt; 值 console.log(key); // =&gt; 索引 console.log(arr); // =&gt; ary数组 return value &gt;10? true:false; &#125;);console.log(ary); // 不变console.log(ary2) //[22, 44, 22, 90] 去重 let ary= [2,3,23,12,3,1,2,3,4,56,4];let new_ary = ary.filter((x,index,self)=&gt;self.indexOf(x)===index)//new_ary =&gt;[2, 3, 23, 12, 1, 4, 56] map map()根据当前数组映射出一个新的数组,可以改变当前循环的值，返回一个新的被改变过值之后的数组（map需return）接收一个方法，该方法可传入三个参数，第一个为数组的一个元素，第二位为该元素的下标，第三个为原数组 一般用来处理需要修改某一个数组的值 let arr = [1,2,3,4,5,6];let newArr= arr.map((value, index, array)=&gt;value*10)// newArr =&gt; [10, 20, 30, 40, 50, 60] forEach forEach遍历方式遍历数组全部元素，利用回调函数对数组进行操作，自动遍历数组.length次，且无法break中途跳出循环，不可控、不支持return操作输出，return只用于控制循环是否跳出当前循环接收一个方法，该方法可传入三个参数，第一个为数组的一个元素，第二位为该元素的下标，第三个为原数组。 循环 [3,2,4,6].forEach(item=&gt;console.log(item)) some 返回 布尔值， true，false， 遍历数组并使用传入参数方法，如果参数方法返回值为false，则继续循环，如果参数方法返回值为true，则终止循环，都不满足为false接收一个方法，该方法可传入三个参数，第一个为数组的一个元素，第二位为该元素的下标，第三个为原数组。 [1,2,3,4].some(item=&gt;item&gt;3);//&gt;true[1,2,3,4].some(item=&gt;item&lt;0) // false reduce 数组常用的一些方法 [].indexOf(item) =&gt; 半段该元素是否存在，返回下标，否则 -1 添加新元素 [].push(item) =&gt; 将一个或多个元素加入数组，返回新数组的长度 [].unshift(item) =&gt;将一个或多个元素加入到数组的开始位置，原有元素位置自动后移，返回 新数组的长度 [].splice(start,delCount,item…) =&gt;从start的位置开始向后删除delCount个元素，然后从start的位置开始插入一个或多个新元素 删除元素 [].pop() =&gt; 删除最后一个元素，并返回该元素 [].shift() =&gt; 删除第一个元素，数组元素位置自动前移，返回被删除的元素 [].splice(start,delCount) =&gt; 从start的位置开始向后删除delCount个元素 数组的合并，截取 [].slice(start,end) =&gt; 以数组的形式返回数组的一部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素 [].concat(array1,array2) =&gt; 将多个数组拼接成一个数组 排序 [].reverse() =&gt; 数组反转 [].sort() =&gt; 数组排序，返回数组地址 拼接成字符串 [].join(‘,’) =&gt; 安什么拼接，返回字符串 根据下标删除元素 使用splice() 方法，写道 Array的原型链接上 Array.prototype.del =function(index) &#123; if (isNaN(index)||index&gt;this.length)return false; this.splice(index,1)&#125;;let a = [1,2,3,4,5];a.del(3);console.log(a) //=&gt; [1,2,3,5]","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://dongzhu.ink/tags/javascript/"}],"author":"M."},{"title":"vue双向数据绑定原理","slug":"前端/vue双向数据绑定原理","date":"2020-04-29T03:13:00.000Z","updated":"2020-08-08T01:40:54.977Z","comments":true,"path":"archives/e2e1e8ad.html","link":"","permalink":"https://dongzhu.ink/archives/e2e1e8ad.html","excerpt":"vue数据双向绑定 VUE2.0 双向绑定底层原理 ES5中的 Object.defineProperty 简单实现 &lt;div&gt; 姓名： &lt;span id=&quot;name&quot;&gt;&lt;/span&gt; &lt;br&gt; &lt;input type=&quot;text&quot; id=&quot;text&quot;&gt;&lt;/div&gt;&lt;script&gt; let obj=&#123; name:&#x27;&#x27;&#125;; let newobj =&#123;...obj&#125;; Object.defineProperty(obj,&#x27;name&#x27;,&#123; get()&#123; // 返回数据， 不能使用 this.name , 会造成死循环， this指向defineProperties // 换回一个新值， 将值克隆一份返回 return newobj.name &#125; set(value)&#123; if(value === obj.name) return; newobj.name =value; observe(); &#125; &#125;); function observe() &#123; name.innerHTML = obj.name; text.value = obj.name &#125; observe(); //text, 监听输入框的值改变，赋予obj，是现实双向绑定 text.oninput= function() &#123; obj.name = this.name &#125;/*1. 对原始数据克隆2. 需要分别给对象中而定每一个属性设置监听*/&lt;/script&gt;","text":"vue数据双向绑定 VUE2.0 双向绑定底层原理 ES5中的 Object.defineProperty 简单实现 &lt;div&gt; 姓名： &lt;span id=&quot;name&quot;&gt;&lt;/span&gt; &lt;br&gt; &lt;input type=&quot;text&quot; id=&quot;text&quot;&gt;&lt;/div&gt;&lt;script&gt; let obj=&#123; name:&#x27;&#x27;&#125;; let newobj =&#123;...obj&#125;; Object.defineProperty(obj,&#x27;name&#x27;,&#123; get()&#123; // 返回数据， 不能使用 this.name , 会造成死循环， this指向defineProperties // 换回一个新值， 将值克隆一份返回 return newobj.name &#125; set(value)&#123; if(value === obj.name) return; newobj.name =value; observe(); &#125; &#125;); function observe() &#123; name.innerHTML = obj.name; text.value = obj.name &#125; observe(); //text, 监听输入框的值改变，赋予obj，是现实双向绑定 text.oninput= function() &#123; obj.name = this.name &#125;/*1. 对原始数据克隆2. 需要分别给对象中而定每一个属性设置监听*/&lt;/script&gt; VUE 3.0 使用的是 ES6中 Proxy &lt;script&gt;let obj=&#123;&#125;;obj = new Proxy(obj,&#123; get(target,prop)&#123; console.log(&#x27;get&#x27;); return target[prop] &#125;, set(target, p, value, receiver) &#123; console.log(&#x27;set&#x27;); target[props] = value; observe(); &#125;&#125;); function observe() &#123; name.innerHTML = obj.name; text.value = obj.name &#125; observe(); //text, 监听输入框的值改变，赋予obj，是现实双向绑定 text.oninput= function() &#123; obj.name = this.name &#125;&lt;/script&gt; 订阅者和发布者模式 订阅者向消息队列中，订阅消息， 发布者只要发布到队列中，就会被订阅者收到如何实现： 初始化，发布者，订阅者 订阅者需要注册到发布者，发布者发布消息的时候，依次向订阅者发布消息","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://dongzhu.ink/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://dongzhu.ink/tags/vue/"}],"author":"M."},{"title":"有趣的题（1）","slug":"前端/有趣的题（1）","date":"2020-04-28T14:59:00.000Z","updated":"2020-08-08T01:40:54.897Z","comments":true,"path":"archives/35f01edd.html","link":"","permalink":"https://dongzhu.ink/archives/35f01edd.html","excerpt":"掌握几大今典布局方案 圣杯布局双飞翼布局 ==&gt; 左右固定，中间自适应 圣杯布局：浮动和负MARGIN &lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 对象（数组）的深拷贝和浅拷贝let obj=&#123; a:100, b:[10,20,30], c:&#123;x:10&#125;, d:/^\\d+$/&#125;;let arrr =[10,[100,200],&#123;x:10,y:20&#125;] 堆栈内存的问题题一1.8let a=&#123;&#125;, b=&#x27;0&#x27;, c=0;a[b]=&#x27;one&#x27;;a[c]=&#x27;two&#x27;;console.log(a[b]) // ==&gt; two// &gt; 对象key 不能重复， 字符串属性名和数字相等， value 被替换掉了// ==&gt; 对象和数组的区别？ 堆，存储引用值内存空间， 没顺序栈，存储基本类型值和指定代码环境 ， 有顺序 题二1.8let a=&#123;&#125;, b=Symbol(&#x27;0&#x27;), c=Symbol(0);a[b]=&#x27;one&#x27;;a[c]=&#x27;two&#x27;;console.log(a[b]) // ==&gt; one// Symbol 创建的是 唯一的值， b和c的 值不相等// 如何实现 Symbol","text":"掌握几大今典布局方案 圣杯布局双飞翼布局 ==&gt; 左右固定，中间自适应 圣杯布局：浮动和负MARGIN &lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 对象（数组）的深拷贝和浅拷贝let obj=&#123; a:100, b:[10,20,30], c:&#123;x:10&#125;, d:/^\\d+$/&#125;;let arrr =[10,[100,200],&#123;x:10,y:20&#125;] 堆栈内存的问题题一1.8let a=&#123;&#125;, b=&#x27;0&#x27;, c=0;a[b]=&#x27;one&#x27;;a[c]=&#x27;two&#x27;;console.log(a[b]) // ==&gt; two// &gt; 对象key 不能重复， 字符串属性名和数字相等， value 被替换掉了// ==&gt; 对象和数组的区别？ 堆，存储引用值内存空间， 没顺序栈，存储基本类型值和指定代码环境 ， 有顺序 题二1.8let a=&#123;&#125;, b=Symbol(&#x27;0&#x27;), c=Symbol(0);a[b]=&#x27;one&#x27;;a[c]=&#x27;two&#x27;;console.log(a[b]) // ==&gt; one// Symbol 创建的是 唯一的值， b和c的 值不相等// 如何实现 Symbol 题三1.8let a=&#123;&#125;, b=&#123;n:&#x27;1&#x27;&#125;, c=&#123;m:&#x27;2&#x27;&#125;;a[b]=&#x27;one&#x27;;a[c]=&#x27;two&#x27;;console.log(a[b]) // ==&gt; two// a[b],a[c] =&gt; [&#x27;object object&#x27;]// ==》 Object.prototype.toString /valueOf 1.8let test = (function(i)&#123; return function() &#123; alert(i*2) &#125; &#125;)(2) test(5)// =&gt; &#x27;4&#x27; 深拷贝 简单实现方式function deepClone(obj)&#123; // 先判断一些类型，重新new对象生产新的地址空间 if(obj ===null) return null if (typeof obj !== &#x27;object&#x27; ) return obj; if(obj instanceof RegExp) return new RegExp(obj); if (obj instanceof Date) return new Date(obj); // = 不直接创建空对象目的， 克隆的结果和之前保持相同的所有类 let newObj = new obj.constructor for (let key in obj)&#123; if(obj.hasOwnProperty(key))&#123; newObj[key] = deepClone(obj[key]) &#125; &#125; return newObj&#125; var a;if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; consple.log(&#x27;条件成立&#x27;) &#125;; 对象==字符串， 对象.toString() 变成字符串null==undefined 相等，但是和其它值比较就不在相等NaN == NaN 不相等，和其它都不想等剩下的都转成为数字比较 a=&#123; i:0, // 每次调用前都会调用toString ， // toString valueOf()&#123; console.log(&#x27;ok&#x27;) return ++this.i &#125;&#125; var a=[1,2,3];a.toString=a.shift() 采用数据劫持来实现， let i =0;Object.defineProperty( window,&#x27;a&#x27;,&#123; get() &#123; //defineProperty geter 不能再次获取当前属性，‘a’ ，会溢出报错 return i++ &#125;&#125;) 实现上面的方式，思维方式，， 1. 就是变成字符串比较， 2. 采用数据劫持方式，。 方式很多 let和varvar age =100;let years =6;if (age&gt;12)&#123; let age =10; var years=age*3;&#125;// // 输出什么=&gt; Uncaught SyntaxError: Identifier &#x27;years&#x27; has already been declared","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://dongzhu.ink/tags/javascript/"},{"name":"css","slug":"css","permalink":"https://dongzhu.ink/tags/css/"},{"name":"html","slug":"html","permalink":"https://dongzhu.ink/tags/html/"}],"author":"M."},{"title":"React(学习一)","slug":"前端/React与Vue对比","date":"2020-04-16T06:55:00.000Z","updated":"2020-08-08T01:40:54.964Z","comments":true,"path":"archives/926d3aa6.html","link":"","permalink":"https://dongzhu.ink/archives/926d3aa6.html","excerpt":"组件化方面 什么是模块化：从 代码 的角度，去分析问题，把我们编程时候的业务逻辑，分割到不同的模块中来进行开发，这样能够方便代码的重用； 什么是组件化：从 UI 的角度，去分析问题，把一个页面，拆分为一些互不相干的小组件，随着我们项目的开发，我们手里的组件会越来越多，最后，我们如果要实现一个页面，可能直接把现有的组件拿过来进行拼接，就能快速得到一个完整的页面， 这样方便了UI元素的重用；组件是元素的集合体； 组件化的好处： Vue是如何实现组件化的：.vue 组件模板文件，浏览器不识别这样的.vue文件，所以，在运行前，会把 .vue 预先编译成真正的组件； template： UI结构 script： 业务逻辑和数据 style： UI的样式 React如何实现组件化：在React中实现组件化的时候，根本没有 像 .vue 这样的模板文件，而是，直接使用JS代码的形式，去创建任何你想要的组件； React中的组件，都是直接在 js 文件中定义的； React的组件，并没有把一个组件 拆分为 三部分（结构、样式、业务逻辑），而是全部使用JS来实现一个组件的；（也就是说：结构、样式、业务逻辑是混合在JS里面一起编写出来的）","text":"组件化方面 什么是模块化：从 代码 的角度，去分析问题，把我们编程时候的业务逻辑，分割到不同的模块中来进行开发，这样能够方便代码的重用； 什么是组件化：从 UI 的角度，去分析问题，把一个页面，拆分为一些互不相干的小组件，随着我们项目的开发，我们手里的组件会越来越多，最后，我们如果要实现一个页面，可能直接把现有的组件拿过来进行拼接，就能快速得到一个完整的页面， 这样方便了UI元素的重用；组件是元素的集合体； 组件化的好处： Vue是如何实现组件化的：.vue 组件模板文件，浏览器不识别这样的.vue文件，所以，在运行前，会把 .vue 预先编译成真正的组件； template： UI结构 script： 业务逻辑和数据 style： UI的样式 React如何实现组件化：在React中实现组件化的时候，根本没有 像 .vue 这样的模板文件，而是，直接使用JS代码的形式，去创建任何你想要的组件； React中的组件，都是直接在 js 文件中定义的； React的组件，并没有把一个组件 拆分为 三部分（结构、样式、业务逻辑），而是全部使用JS来实现一个组件的；（也就是说：结构、样式、业务逻辑是混合在JS里面一起编写出来的） 开发团队方面 React是由FaceBook前端官方团队进行维护和更新的；因此，React的维护开发团队，技术实力比较雄厚； Vue：第一版，主要是有作者 尤雨溪 专门进行维护的，当 Vue更新到 2.x 版本后，也有了一个小团队进行相关的维护和开发； 社区方面 在社区方面，React由于诞生的较早，所以社区比较强大，一些常见的问题、坑、最优解决方案，文档、博客在社区中都是可以很方便就能找到的； Vue是近两年才诞生开源出来的，所以，它的社区相对于React来说，要小巧一些，所以，可能有的一些坑，没人踩过； 移动APP开发体验方面 Vue，结合 Weex 这门技术，提供了 迁移到 移动端App开发的体验（Weex，目前只是一个 小的玩具， 并没有很成功的 大案例；） React，结合 ReactNative，也提供了无缝迁移到 移动App的开发体验（RN用的最多，也是最火最流行的）； React中的核心概念虚拟DOM DOM： 用js表示的ui元素， 是由js提供的功能， 所以我们只能人为的使用 浏览器提供的固定的API来操作DOM对象； 虚拟DOM: 并不是由浏览器提供的，而是我们程序员手动模拟实现的，类似于浏览器中的DOM，但是有着本质的区别； 虚拟DOM的本质： 就是使用js对象来模拟DOM树， 目的： 为了实现DOM节点的搞笑更新： DIff算法 tree diff:新旧DOM树，逐层对比的方式，就叫做 tree diff,每当我们从前到后，把所有层的节点对比完后，必然能够找到那些 需要被更新的元素； component diff：在对比每一层的时候，组件之间的对比，叫做 component diff;当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换到被移除的位置； element diff:在组件中，每个元素之间也要进行对比，那么，元素级别的对比，叫做 element diff； key：key这个属性，可以把 页面上的 DOM节点 和 虚拟DOM中的对象，做一层关联关系； react项目创建有状态组件和无状态组件 function 创建的组件是 无状态组件， class 创建的组件是有状态组件","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"react","permalink":"https://dongzhu.ink/tags/react/"}],"author":"M."},{"title":"js中类的使用","slug":"前端/javaScript/js中类的使用","date":"2020-04-15T12:29:00.000Z","updated":"2020-08-08T01:40:55.084Z","comments":true,"path":"archives/bec7cdca.html","link":"","permalink":"https://dongzhu.ink/archives/bec7cdca.html","excerpt":"类的原理 在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称”实例”）共有的属性和方法。Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。在 javaScript中， 类的所有实例对象都是从通一个原型对象上继承属性，因此，原型对象是类的核心","text":"类的原理 在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称”实例”）共有的属性和方法。Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。在 javaScript中， 类的所有实例对象都是从通一个原型对象上继承属性，因此，原型对象是类的核心 原型链类的继承","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://dongzhu.ink/tags/javascript/"}],"author":"M."},{"title":"闭包-生成器-迭代器","slug":"后端/闭包-装饰器","date":"2020-04-15T09:28:00.000Z","updated":"2020-08-08T01:52:33.827Z","comments":true,"path":"archives/e8c457c6.html","link":"","permalink":"https://dongzhu.ink/archives/e8c457c6.html","excerpt":"JavaScript 中闭包的理解 知识点的总结，也是一种好的表达方式，也能更好的理解 什么是闭包: 函数对象通过作用域链相互关联起来， 函数体内部的变量都可以保存在函数作用域内，这种特征就叫 闭包最常见方式，就是 一个函数嵌套另一个函数，内部函数引用外部函数的局部变量优点： 延长外部函数局部变量的声明周期缺点： 容易造成 内存泄漏 javascript闭包简单实现 function func1()&#123; let a =1; return function() &#123; a = a+1; return c &#125; &#125;res =func1()console.log(res()) //2console.log(res()) //3 闭包的作用域链包含着它自己的作用域，以及包含它的函数的作用域和全局作用域。 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。 在javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收； 如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是某个特殊的变量。","text":"JavaScript 中闭包的理解 知识点的总结，也是一种好的表达方式，也能更好的理解 什么是闭包: 函数对象通过作用域链相互关联起来， 函数体内部的变量都可以保存在函数作用域内，这种特征就叫 闭包最常见方式，就是 一个函数嵌套另一个函数，内部函数引用外部函数的局部变量优点： 延长外部函数局部变量的声明周期缺点： 容易造成 内存泄漏 javascript闭包简单实现 function func1()&#123; let a =1; return function() &#123; a = a+1; return c &#125; &#125;res =func1()console.log(res()) //2console.log(res()) //3 闭包的作用域链包含着它自己的作用域，以及包含它的函数的作用域和全局作用域。 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。 在javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收； 如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是某个特殊的变量。 闭包实现节流，和防抖 规定时间内 触发, 节流函数 function throttle(fn,delay)&#123; // 记入上一次杉树触发时间 let lastTime =0; return function()&#123; let nowTIME= Date.now(); if (nowTIME-lastTime &gt;delay)&#123; fn.call(this); // 修正this指向问题 // fn() lastTime=nowTIME &#125; &#125;&#125; 防抖函数, 一个需要频繁触发的函数,在规定时间内,只让最后一次生效,前面不生效 function debounce(fn,date)&#123; // 初始 记入上一次延时器 let timer = null; return function ()&#123; // 清楚上一次延时器 clearTimeout(timer); // 重新设置新的延时器 timer = setTimeout(function()&#123; fn.apply(this) // 修正this指向 &#125;,date) &#125;&#125; 闭包中常见题型function fun(n,o)&#123; console.log(o) return &#123; fun:function(m)&#123; return fun(m,n) &#125; &#125;&#125;var a = fun(0) // undefinde,a.fun(1) // 0a.fun(2) //0a.fun(3) //0var b = fun(0).fun(1).fun(2).fun(3).fun(4)// undefinde,0,1,2,3var c = fun(0).fun(1) // undefinde,0c.fun(2) //1c.fun(3) //1 for (var i=0;i&lt;5;i++)&#123; setTimeout(function()&#123; console.log(i++) &#125;,4000)&#125;console.log(i);// 5, 5,6,7,8,9 i=10// setTimeout是异步操作，会将任务管理起来，执行， 等待4秒后会直接执行所有for (var i=0;i&lt;5;i++)&#123; (function(x)&#123; setTimeout(function()&#123; console.log(x++) &#125;,4000) &#125;)(i)&#125;console.log(i)// 5, 0,1,2,3,4,5 i=5 Python，中闭包 实现一个闭包 def func1(): a = 1 def func2(): # nonloacal a a = a+1 return a return func2func1()() # 直接报错，local variable &#x27;a&#x27; referenced before assignment 这是应为python规定所有在赋值语句左面的变量都是局部变量，这个a在等号左边，所以成了一个局部的变量，导致我访问不到func1中的a可使用 nonloacal 来指定变量a， 不为局部变量再在py3版本中， 即使这条它输入的结果跟js也是不一样的， 返回的结果始终是 2这是应为python中 存在可变类型和不可变类型，不可变类型 在第一次声明赋值声明的时候, 会在内存中开辟一块空间, 用来存放这个变量被赋的值, 而这个变量实际上存储的, 并不是被赋予的这个值, 而是存放这个值所在空间的内存地址, 通过这个地址, 变量就可以在内存中取出数据了. 所谓不可变就是说, 我们不能改变这个数据在内存中的值, 所以当我们改变这个变量的赋值时, 只是在内存中重新开辟了一块空间, 将这一条新的数据存放在这一个新的内存地址里, 而原来的那个变量就不在引用原数据的内存地址而转为引用新数据的内存地址了.可变类型 结合不可变类类型，可变数据类型是指变量所指向的内存地址处的值是可以被改变的。 Python 装饰器开发中经常会用到装饰器，减少重复写代码, 做验证判断机制，就时一个闭包，把一个函数当做参数然后返回一个替代版函数 1.定义：函数装饰器用于标记函数，增强函数的行为。装饰器本身是可调用的对象，它的参数是另一个被装饰的函数。2.装饰方法：可能会处理被装饰的函数，然后把他返回。或者将其替换成另一个函数或者可调用对象 函数装饰器 def logg(func): def wrapper(*args,**kwargs): # *args,**kwargs 是 func函数所携带参数， name... print(func.__name__,*args,**kwargs) # 传递进来的 函数 return func(*args,**kwargs) ## 返回结果， return wrapper @loggdef foo(name): print(&#x27;foo&#x27;)@loggdef par(name): print(&quot;par&quot;) 带参数的装饰器, 再嵌套一个函数 def lg(level): # level 装饰器参数 def decorator(func): def wrapper(*args,**kwargs): if level == &#x27;info&#x27;: return func(*args,**kwargs) return 2 return wrapper return decorator@lg(&#x27;info&#x27;)def foo(name): print(&#x27;正常输入&#x27;) 装饰器常用来实现的小案例 时间计时器 import timedef timer(func): def wrapper(*args, **kw): t1=time.time() # 这是函数真正执行的地方 func(*args, **kw) t2=time.time() # 计算下时长 cost_time = t2-t1 print(&quot;花费时间：&#123;&#125;秒&quot;.format(cost_time)) return wrapper 类装饰器在开发很少会用到类装饰，但是再一些别的源码中会见到 类装饰器， 使用 __call__ __init__ 内置函数来实现 class loger(object): def __init__(self,func): self.func = func def __call__(self, *args, **kwargs): print(&#x27;正在运行的函数是：&#x27;,self.func.__name__) return self.func(*args, **kwargs)@logerdef foo(hap): print(&#x27;hi &#123;&#125;&#x27;.format(hap)) 带参数的","categories":[{"name":"后端","slug":"后端","permalink":"https://dongzhu.ink/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://dongzhu.ink/tags/javascript/"},{"name":"Python","slug":"python","permalink":"https://dongzhu.ink/tags/python/"}],"author":"M."},{"title":"js中Promise的用法","slug":"前端/javaScript/js中Promise的使用","date":"2020-04-14T06:55:00.000Z","updated":"2020-08-08T01:40:54.907Z","comments":true,"path":"archives/1e9fa2d1.html","link":"","permalink":"https://dongzhu.ink/archives/1e9fa2d1.html","excerpt":"Promise 的定义Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。Promise对象有以下两个特点。（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise缺点。 无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。","text":"Promise 的定义Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。Promise对象有以下两个特点。（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise缺点。 无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Promise 的用法const promise = new Promise((resolve, reject) =&gt; &#123; let status = true; if (status) &#123; resolve(&#x27;操作成功!&#x27;); &#125; else &#123; reject(&#x27;操作失败!&#x27;); &#125;&#125;);promise.then(res =&gt; &#123; console.log(&#x27;成功结果：&#x27; + res);&#125;, error =&gt; &#123; console.log(&#x27;失败结果：&#x27; + error); &#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected）在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。then方法可以接受两个回调函数作为参数。 第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。(可选) const promise = new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;new Promise()&#x27;); resolve();&#125;);promise.then(() =&gt; &#123; console.log(&#x27;resolve()&#x27;);&#125;);console.log(&#x27;End&#x27;);// 输出结果//new Promise()// End// resolve() 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法 new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;成功返回&#x27;);&#125;).then(res =&gt; &#123; console.log(res); // 成功返回&#125;); then方法的基础调用写法，可以写一个回调方法，来执行成功后的回调。then方法返回一个的是一个新的Promise实例，因此我们可以采用链式写法，即then方法后面再调用一个then方法。 new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;成功返回&#x27;);&#125;).then(res =&gt; &#123; return res // 成功返回&#125;).then(res=&gt;res).then(res=&gt;&#123;console.log(res)&#125;)// 成功返回 Promise.prototype.catch() 发生错误的回调函数,Promise实例当状态改变为rejected状态或者操作失败抛出异常错误，就会被catch方法捕获。所以在Promise实例中reject方法等同于抛出错误。如果Promise的状态已经变成了resolved，再抛出错误无效 new Promise((resolve, reject) =&gt; &#123; reject(&#x27;失败&#x27;);&#125;).catch(error =&gt; &#123; console.log(error); // 失败&#125;);new Promise((resolve, reject) =&gt; &#123; reject(&#x27;失败&#x27;); throw new Error(&#x27;抛出异常&#x27;); // 这行无效&#125;).catch(error =&gt; &#123; console.log(error); // 失败&#125;); Promise的finally方法 不管Promise最后状态如何，都会回调执行 new Promise((resolve, reject) =&gt; &#123; resolve();&#125;).then(res =&gt; &#123; console.log(&#x27;success&#x27;);&#125;).catch(error =&gt; &#123; console.log(&#x27;error&#x27;);&#125;).finally(() =&gt;&#123; console.log(&#x27;finally&#x27;);&#125;) Promise的all方法 Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。在all方法中可以传递多个Promise对象，当所有的Promise对象状态都返回fufilled，才会返回fulfilled，否则返回rejected。 const promise1 = new Promise((resolve, reject) =&gt; &#123; resolve();&#125;);const promise2 = new Promise((resolve, reject) =&gt; &#123; resolve();&#125;);const promise3 = new Promise((resolve, reject) =&gt; &#123; resolve();&#125;);const promiseAll = Promise.all([promise1, promise2, promise3]).then(res =&gt; &#123; console.log(&#x27;all&#x27;);&#125;) Promise的race方法 和all 差不多， 只是， 只要有一个有一个实例率先改变状态，那么race的状态就会跟着改变 const promise1 = new Promise((resolve, reject) =&gt; &#123; reject();&#125;);const promise2 = new Promise((resolve, reject) =&gt; &#123; resolve();&#125;);const promise3 = new Promise((resolve, reject) =&gt; &#123; reject();&#125;);const promiseRace = Promise.race([promise1, promise2, promise3]).then(res =&gt; &#123; console.log(&#x27;race then&#x27;);&#125;).catch(error =&gt; &#123; console.log(&#x27;race catch&#x27;);&#125;) ECM6","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://dongzhu.ink/tags/javascript/"}],"author":"M."},{"title":"常用的网站工具收藏","slug":"工具/常用的工具收纳","date":"2020-04-14T05:06:00.000Z","updated":"2020-08-08T01:40:54.902Z","comments":true,"path":"archives/ee063036.html","link":"","permalink":"https://dongzhu.ink/archives/ee063036.html","excerpt":"整理一些自己经常用到的一些好的网站… 方便自己使用有些插件工具用法会单独篇章在慢慢简介…持续增加… 在线工具箱 开发 css,html 图标之家 阿里字体图标库 icomoon图库 css渐变色 Animate.css 动画效果框架, 在线CNDhttps://unpkg.com/animate.css@3.5.2/animate.min.css 高德地图api ui组件 W3school在线测试 colorhunt配色","text":"整理一些自己经常用到的一些好的网站… 方便自己使用有些插件工具用法会单独篇章在慢慢简介…持续增加… 在线工具箱 开发 css,html 图标之家 阿里字体图标库 icomoon图库 css渐变色 Animate.css 动画效果框架, 在线CNDhttps://unpkg.com/animate.css@3.5.2/animate.min.css 高德地图api ui组件 W3school在线测试 colorhunt配色 js,jQ JQuery文档 jQ插件 vue组件库 Element-UI 移动端组件库 color-ui, Github 当你词穷,不知道怎么取变量名时 CODELF 学习 python文档 Go文档 ES6入门教程 刷题网 力扣牛客 demo编程Code HS 社区交流 夜幕爬虫论坛 黑客派 吾爱破解 掘金论坛 stackoverflow 游戏图库 萌娘动漫图库","categories":[{"name":"工具","slug":"工具","permalink":"https://dongzhu.ink/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"https://dongzhu.ink/tags/%E6%94%B6%E8%97%8F/"}],"author":"M."},{"title":"抓包工具的使用","slug":"工具/抓包工具的使用","date":"2020-04-13T15:46:00.000Z","updated":"2020-08-08T01:40:54.935Z","comments":true,"path":"archives/4fbf257c.html","link":"","permalink":"https://dongzhu.ink/archives/4fbf257c.html","excerpt":"Charles工具使用 Charles下载 配置抓https请求包 点击安装证书，本地计算机-将所有证书都到到-受信用的根证书烦发机构 点击确定 设置 ssl 拦截配置 Proxy-ssl Proxy Settings... 点击， 勾选 Enable SSL Proxying再点击下面 Add 添加， 设置 * 即可， 全部拦截 拦截抓包 通过使用测试请求的web工具 http://httpbin.org/ 发送请求 过滤请求 通过设置 左下角的Filter: httpbin.org 来过滤请求 或者右键请求， 选择 Focus, 设置断点 通过 Proxy- Breakpoint Sett... 来设置请求的url断点","text":"Charles工具使用 Charles下载 配置抓https请求包 点击安装证书，本地计算机-将所有证书都到到-受信用的根证书烦发机构 点击确定 设置 ssl 拦截配置 Proxy-ssl Proxy Settings... 点击， 勾选 Enable SSL Proxying再点击下面 Add 添加， 设置 * 即可， 全部拦截 拦截抓包 通过使用测试请求的web工具 http://httpbin.org/ 发送请求 过滤请求 通过设置 左下角的Filter: httpbin.org 来过滤请求 或者右键请求， 选择 Focus, 设置断点 通过 Proxy- Breakpoint Sett... 来设置请求的url断点 待续… EditThisCookie 使用该插件就是方便 调试和管理 cookie，严重过期，参数， 导入导出，方便调试 谷歌商店 搜索 EditThisCookie 小饼干图型的，安装即可 Toggle JavaScript 插件该插件主要是， 方便失败，有没有使用javaScript渲染，渲染开关… 方便快速判断， Tampermonkey 插件 Your browser does not support the video tag. - 获取脚本 - 管理面板 待续…","categories":[{"name":"工具","slug":"工具","permalink":"https://dongzhu.ink/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://dongzhu.ink/tags/%E7%88%AC%E8%99%AB/"}],"author":"M."},{"title":"js中this的指向","slug":"前端/javaScript/js-this","date":"2020-04-13T13:17:00.000Z","updated":"2020-08-08T01:37:36.628Z","comments":true,"path":"archives/c3ed0128.html","link":"","permalink":"https://dongzhu.ink/archives/c3ed0128.html","excerpt":"在JavaScript 中，函数的 this 指向比较复杂多变。它和你调用的方式有关系，和 严格模式 或者 非严格模式 有关系，和你是否使用了箭头函数有关系，和你在使用函数时是否传入了 this 有关系，和你是否主动修改了调用对象有关系。 在绝大多数情况下，函数的调用方式决定了 this 的值。this 不能再执行期间被赋值，并且在每次函数被调用时 this 的值也可能会不同。 与其他语言相比，函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在 严格模式 和 非严格模式之间也会有一些差别。 this 的值指向，取决于函数被调用的方式 全局上下文无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this 都指代全局对象。【在全局执行上下文中 this 都是全局对象 window】（浏览器环境）","text":"在JavaScript 中，函数的 this 指向比较复杂多变。它和你调用的方式有关系，和 严格模式 或者 非严格模式 有关系，和你是否使用了箭头函数有关系，和你在使用函数时是否传入了 this 有关系，和你是否主动修改了调用对象有关系。 在绝大多数情况下，函数的调用方式决定了 this 的值。this 不能再执行期间被赋值，并且在每次函数被调用时 this 的值也可能会不同。 与其他语言相比，函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在 严格模式 和 非严格模式之间也会有一些差别。 this 的值指向，取决于函数被调用的方式 全局上下文无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this 都指代全局对象。【在全局执行上下文中 this 都是全局对象 window】（浏览器环境） var a = 1;console.log(this); // windowconsole.log(this.a); // 1&quot;use strict&quot;;var b = 2;console.log(this); // windowconsole.log(this.b); // 2 函数上下文在函数内部，this 的值取决于函数被调用的方式。【取决于被调用的方式】 简单调用function f1() &#123; return this;&#125;// 在浏览器中f1() === window; // 在浏览器中，全局对象是widnow// 在 Node 中f1() === global; 【在严格模式下，this 将保持他进入执行上下文时的值】 在严格模式下，this 将保持他进入执行上下文时的值，所以下面的 this 将会默认为 undefined。 function f2()&#123; &quot;use strict&quot;; // 这里是严格模式 return this;&#125;f2() === undefined; // true 所以，在严格模式下，如果 this 没有被执行上下文（execution context）定义，那它将保持为 undefined。 因为 f2() 是被直接调用的，而不是作为对象的属性或方法调用的（如window.f2()）。有一些浏览器最初在支持严格模式时没有正确实现这个功能，于是它们错误的返回了 window 对象。 但是，如果用 window 来调用的话，this 就是 window 了。 function f2()&#123; &quot;use strict&quot;; // 这里是严格模式 return this;&#125;console.log(window.f2()) // window 如果要想把 this 的值从一个上下文传到另一个，就要用 call 或者 apply 方法。 当一个函数在其主体中使用 this 关键字时，可以通过使用函数继承自 Function.prototype 的 call 或 apply 方法将 this 值绑定到调用中的特定对象 function add(c, d) &#123; return this.a + this.b + c + d;&#125;var o = &#123;a: 1, b: 3&#125;;// 第一个参数是作为‘this’使用的对象// 后续参数作为参数传递给函数调用add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16// 第一个参数也是作为‘this’使用的对象// 第二个参数是一个数组，数组里的元素用作函数调用中的参数add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 使用 call 和 apply 函数的时候要注意，如果传递给 this 的值不是一个对象，JavaScript 会尝试使用内部 ToObject 操作将其转换为对象。 因此，如果传递的值是一个原始值比如 7 或 foo，那么就会使用相关构造函数将它转换为对象，所以原始值 7 会被转为对象，像new Number(7) 这样，而字符串 foo 转化成 new String(&#39;foo&#39;) 这样。 bind 方法ECMAScript 5 引入了 Function.prototype.bind。调用 f.bind(someObject) 会 创建一个与 f 具有相同函数体和作用域的函数，但是在这个新函数中，this 将永久地被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的。 【this 将永久的被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的】 function f()&#123; return this.a;&#125;var g = f.bind(&#123;a:&quot;azerty&quot;&#125;);console.log(g()); // azertyvar h = g.bind(&#123;a:&#x27;yoo&#x27;&#125;); // bind只生效一次！console.log(h()); // azertyvar o = &#123;a:37, f:f, g:g, h:h&#125;;console.log(o.f(), o.g(), o.h()); // 37, azerty, azerty 箭头函数在箭头函数中，this 与封闭词法上下文的 this 保持一致。在全局代码中，它将被设置为全局对象。【封闭词法上下文 是什么意思，你知道吗？】 var foo = (() =&gt; this);// 接着上面的代码// 作为对象的一个方法调用var obj = &#123;foo: foo&#125;;console.log(obj.foo() === window); // true// 尝试使用call来设定thisconsole.log(foo.call(obj) === window); // true// 尝试使用bind来设定thisfoo = foo.bind(obj);console.log(foo() === window); // true 【无论如何，foo 的 this 被设置为他被创建时的上下文（在上面的例子中，就是全局对象）】这同样适用于在其他函数内创建的箭头函数：这些箭头函数的 this 被设置为封闭的词法上下文的。 作为对象的方法 当函数作为对象里的方法被调用时，它们的 this 是调用该函数的对象 this 的绑定只受最靠近的成员引用的影响。在下面的例子中，我们把一个方法 g 当做对象 o.b 的函数调用。在这次执行期间，函数中的 this 将指向 o.b 。事实证明，这与他是对象 o 的成员没有多大关系，最靠近的引用才是最重要的。 o.b = &#123; g: independent, prop: 42 &#125;console.log(o.b.g()) 原型链中的 this对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法在对象上一样。 var o = &#123; f: function() &#123; return this.a + this.b; &#125;&#125;;var p = Object.create(o);p.a = 1;p.b = 4;console.log(p.f()); // 5 在这个例子中，对象 p 没有属于它自己的 f 属性，它的 f 属性继承自它的原型。虽然在对 f 的查找过程中，最终是在 o 中找到 f 属性的，这并没有关系；查找过程首先从 p.f 的引用开始，所以函数中的 this 指向 p。也就是说，因为 f 是作为 p 的方法调用的，所以它的 this 指向了 p 。这是 JavaScript 的原型继承中的一个有趣的特性。 作为构造函数当一个函数用作构造函数时（适用 new 关键字），它的 this 被绑定到正在构造的新对象。 虽然构造器返回的默认值是 this 所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回 this 对象） /* 构造函数这样工作: function MyConstructor()&#123; 函数实体写在这里 根据需要在this上创建属性，然后赋值给它们，比如： this.fum = &quot;nom&quot;; 等等... 如果函数具有返回对象的return语句， 则该对象将是 new 表达式的结果。 否则，表达式的结果是当前绑定到 this 的对象。 （即通常看到的常见情况）。 &#125; */function C()&#123; this.a = 37;&#125;var o = new C();console.log(o.a); // 37function C2()&#123; this.a = 37; return &#123;a:38&#125;;&#125;o = new C2();console.log(o.a); // 38 在刚刚的例子中（C2），因为在调用构造函数的过程中，手动的设置了返回对象，与 this 绑定的默认对象被丢弃了。（这基本上使得语句 this.a = 37; 成了“僵尸”代码，实际上并不是真正的“僵尸”，这条语句执行了，但是对于外部没有任何影响，因此完全可以忽略它）。 作为一个 DOM 事件处理函数 当函数被用作事件处理函数时，它的 this 指向触发事件的元素（一些浏览器在使用非 addEventListener 的函数动态添加监听函数时不遵守这个约定）。 // 被调用时，将关联的元素变成蓝色function bluify(e)&#123; console.log(this === e.currentTarget); // 总是 true // 当 currentTarget 和 target 是同一个对象时为 true console.log(this === e.target); this.style.backgroundColor = &#x27;#A5D9F3&#x27;;&#125;// 获取文档中的所有元素的列表var elements = document.getElementsByTagName(&#x27;*&#x27;);// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色for(var i=0 ; i&lt;elements.length ; i++)&#123; elements[i].addEventListener(&#x27;click&#x27;, bluify, false); 作为一个内联事件处理函数 当代码被内联 on-event 处理函数 调用时，它的 this 指向监听器所在的 DOM 元素 &lt;button onclick=&quot;alert(this.tagName.toLowerCase());&quot;&gt; Show this&lt;/button&gt; 上面的 alert 会显示 button 。注意只有外层代码中的 this 是这样设置的： &lt;button onclick=&quot;alert((function()&#123;return this&#125;)());&quot;&gt; Show inner this&lt;/button&gt; 在这种情况下，没有设置内部函数的 this，所以它指向 global/window 对象（即非严格模式下调用的函数未设置 this 时指向的默认对象）。","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://dongzhu.ink/tags/javascript/"}],"author":"M."},{"title":"webpack常用配置","slug":"前端/webpack/webpack常用配置","date":"2020-03-29T08:59:00.000Z","updated":"2020-08-08T01:40:54.874Z","comments":true,"path":"archives/c36507d3.html","link":"","permalink":"https://dongzhu.ink/archives/c36507d3.html","excerpt":"webpack创建项目 项目初始化 npm init （再输入项目） || npm init -y 下载包 npm i webpack webpack-cli -D 开发依赖 配置 webpack.config.js const path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)module.exports=&#123; entry: path.join(__dirname,&#x27;./src/main.js&#x27;), // 入口文件，要使用webpack打包的文件 output:&#123; // 输出文件相关的配置 path: path.join(__dirname,&#x27;./dist&#x27;), filenname:&#x27;bundle.js&#x27; //指定， 输出的文件名称 &#125;, devServer:&#123; // 配置 dev-server命令参数 open:true ,// 自动打开浏览器 port: 3000, contentBase:&#x27;src&#x27;, // 指定托管的 根目录 hot: true // 启动热更新，再在 plugins中 new一下 &#125;, plugins:[ // 配置插件的节点 new webpack.HotModuleReplacementPlugin() // new 一个热更新的模块 ], module:&#123;&#125;&#125;","text":"webpack创建项目 项目初始化 npm init （再输入项目） || npm init -y 下载包 npm i webpack webpack-cli -D 开发依赖 配置 webpack.config.js const path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)module.exports=&#123; entry: path.join(__dirname,&#x27;./src/main.js&#x27;), // 入口文件，要使用webpack打包的文件 output:&#123; // 输出文件相关的配置 path: path.join(__dirname,&#x27;./dist&#x27;), filenname:&#x27;bundle.js&#x27; //指定， 输出的文件名称 &#125;, devServer:&#123; // 配置 dev-server命令参数 open:true ,// 自动打开浏览器 port: 3000, contentBase:&#x27;src&#x27;, // 指定托管的 根目录 hot: true // 启动热更新，再在 plugins中 new一下 &#125;, plugins:[ // 配置插件的节点 new webpack.HotModuleReplacementPlugin() // new 一个热更新的模块 ], module:&#123;&#125;&#125; npm i webpack-dev-server 插件 自动打包编译工具（本地必须安装 webpack webpack-cli）,配置 package.json 启动命令 npm i html-webpack-plugin -D 插件 内存中生产html// --host 页面不刷新更新，--contentBace src 启动文件路径， --open 自动打开， // webpack-dev-server --open --port 3000 --contentBace src --host// 第二中，再配置文件中， webpack.config.js 修改///=》 在 webpack.config.js 配置// 导入在内存中生产HTML页面的插件const htmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)plugins:[ new webpack.HotModuleReplacementPlugin(), // 热更新 // 自动创建一一个，script引用正确路径 new htmlWebpackPlugin(&#123; // 创建一个 在内存中生成的 html template:path.join(__dirname,&#x27;./src/index.html&#x27;), // 指定模板页面，根据指定页面生成内存中 filename:&#x27;index.html&#x27; // 指定生成页面的名称 &#125;)] webpack 默认只能初始js文件， 处理不了css， css文件中的url地址，不管图片还是地址库，只要是url地址， 需要安装 loader 打包css文件安装 less-loader css-loader style-loader cnpm -i node-sass sass-loader 安装 npm -i url-loader file-loader css中 url路径的的处理在配置文件 webpack.config.js 中 module配置webpack处理第三方文件类型的过场： 发现要处理的文件不是js文件，然后就去配置文件中， 查找有没有对应的第三方loader 规则 如果能倒找对应的规则， 就会调用对应的 loader 处理， 这样文件类型 在调用loader的时间，是从后往前调用 当最后一个 loader 调用完毕，会把处理的结果，直接交给webpack进行打包合并，最终输出到js文件 module:&#123; // 用于配置所有第三方模板，加速器 rules:[ //所有第三方模板的比配规则， 参数格式和get请求一样 &#123;test:/\\.css$/,use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;]&#125;, &#123;test:/\\.less$/,use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;,&#x27;less-loader&#x27;]&#125;, // 配置.less文件处理 &#123;test:/\\.scss$/,use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;,&#x27;sass-loader&#x27;]&#125;, // 配置.less文件处理 // limit=8000，参数，给定的值是图片的大小byte，如果图片大于或等于给定的limt值，则不会被转成base64格式字符串，如果小于给定的limit值，则会被转成baser64格式 // name=[name].[ext], 修改文件名，[name].[ext] 原名和原后缀未修改,[hash:8]截取hash值前8位 &#123;test:/\\.(jpg|png|gif|bmp|jpeg)$/,use:&#x27;url-loader?limit=8000&amp;name=[hash:8]-[name].[ext]&#x27;&#125; // 处理图片的 路径 &#123;test:/\\.(ttf|eot|svg|woff|woff2)$/,use:&#x27;url-loader&#x27;&#125;, // 处理字体文件 &#123;test:/\\.js$/,use:&#x27;babel-loader&#x27;,exclude:/node_modules/&#125; // ES高级语法转换 ]&#125; bable的配置 webpack 中 默认只能处理一部分 ES6 的新语法， 一些更高级的ES6或者ES7语言，webpack是处理不了，这时候需要第三方loader，来处理通过 Babel， 可以将高级的语法转成，低级语法npm i babel-core babel-loader babel-plugin-transform-runtime -Dnpm i babel-preset-env babel-preset-stage-0 -D 在配置文件中 配置rules/exclude （过滤掉） 不编译 node_modules 里第三方都是已经编译好了的，如在在编译，消费cpu过大&#123;test:/\\.js$/,use:&#39;babel-loader&#39;,exclude:/node_modules/&#125;在项目根目录，创建 .babelrc配置文件 这个配置文件属于JSON &#123;&quot;presets&quot;: [&quot;env&quot;,&quot;stage-0&quot;], // 语法&quot;plugins&quot;:[&quot;transform-runtime&quot;] // 安装插件名字&#125; 工作中 webpack 的常用配置 配置一 const path = require(&#x27;path&#x27;)const htmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)// 导入每次删除文件夹的插件const cleanWebpackPlugin = require(&#x27;clean-webpack-plugin&#x27;)const webpack = require(&#x27;webpack&#x27;)// 导入抽取CSS的插件const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;)// 导入压缩CSS的插件const OptimizeCssAssetsPlugin = require(&#x27;optimize-css-assets-webpack-plugin&#x27;)module.exports = &#123; entry: &#123; // 配置入口节点 app: path.join(__dirname, &#x27;./src/main.js&#x27;), vendors1: [&#x27;jquery&#x27;] // 把要抽离的第三方包的名称，放到这个数组中 &#125;, output: &#123; path: path.join(__dirname, &#x27;./dist&#x27;), filename: &#x27;js/bundle.js&#x27; &#125;, plugins: [ // 插件 new htmlWebpackPlugin(&#123; template: path.join(__dirname, &#x27;./src/index.html&#x27;), filename: &#x27;index.html&#x27;, minify: &#123; collapseWhitespace: true, // 合并多余的空格 removeComments: true, // 移除注释 removeAttributeQuotes: true // 移除 属性上的双引号 &#125; &#125;), new cleanWebpackPlugin([&#x27;dist&#x27;]), new webpack.optimize.CommonsChunkPlugin(&#123; name: &#x27;vendors1&#x27;, // 指定要抽离的入口名称 filename: &#x27;js/vendors.js&#x27; // 将来再发布的时候，除了会有一个 bundle.js ，还会多一个 vendors.js 的文件，里面存放了所有的第三方包 &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; // 配置压缩选项 warnings: false // 移除警告 &#125; &#125;), new webpack.optimize.DedupePlugin(&#123; // 设置为产品上线环境，进一步压缩JS代码 &#x27;process.env.NODE_ENV&#x27;: &#x27;&quot;production&quot;&#x27; &#125;), new ExtractTextPlugin(&quot;css/styles.css&quot;), // 抽取CSS文件 new OptimizeCssAssetsPlugin()// 压缩CSS的插件 ], module: &#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: &quot;css-loader&quot;, publicPath: &#x27;../&#x27; // 指定抽取的时候，自动为我们的路径加上 ../ 前缀 &#125;) &#125;, &#123; test: /\\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: &#x27;style-loader&#x27;, use: [&#x27;css-loader&#x27;, &#x27;sass-loader&#x27;], publicPath: &#x27;../&#x27; // 指定抽取的时候，自动为我们的路径加上 ../ 前缀 &#125;) &#125;, &#123; test: /\\.(png|gif|bmp|jpg)$/, use: &#x27;url-loader?limit=5000&amp;name=images/[hash:8]-[name].[ext]&#x27; &#125;, &#123; test: /\\.js$/, use: &#x27;babel-loader&#x27;, exclude: /node_modules/ &#125; ] &#125;, // 打包时不生成.map文件 productionSourceMap: false, devServer: &#123; proxy: &#x27;http://localhost:3000&#x27; // 代理 &#125;&#125; 配置2&#x27;use strict&#x27;const path = require(&#x27;path&#x27;)const utils = require(&#x27;./utils&#x27;)const config = require(&#x27;../config&#x27;)const vueLoaderConfig = require(&#x27;./vue-loader.conf&#x27;)function resolve (dir) &#123; return path.join(__dirname, &#x27;..&#x27;, dir)&#125;const createLintingRule = () =&gt; (&#123; test: /\\.(js|vue)$/, loader: &#x27;eslint-loader&#x27;, enforce: &#x27;pre&#x27;, include: [resolve(&#x27;src&#x27;), resolve(&#x27;test&#x27;)], options: &#123; formatter: require(&#x27;eslint-friendly-formatter&#x27;), emitWarning: !config.dev.showEslintErrorsInOverlay &#125;&#125;)module.exports = &#123; context: path.resolve(__dirname, &#x27;../&#x27;), entry: &#123; app: [&quot;babel-polyfill&quot;, &#x27;./src/main.js&#x27;] &#125;, externals: &#123; &#x27;BMap&#x27;: &#x27;BMap&#x27;, &#x27;BMap_Symbol_SHAPE_POINT&#x27;: &#x27;BMap_Symbol_SHAPE_POINT&#x27; &#125;, output: &#123; path: config.build.assetsRoot, filename: &#x27;[name].js&#x27;, publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;, resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;], alias: &#123; &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27;, &#x27;@&#x27;: resolve(&#x27;src&#x27;), &#125; &#125;, module: &#123; rules: [ ...(config.dev.useEslint ? [createLintingRule()] : []), &#123; test: /\\.vue$/, loader: &#x27;vue-loader&#x27;, options: vueLoaderConfig &#125;, &#123; test: /\\.js$/, loader: &#x27;babel-loader&#x27;, include: [resolve(&#x27;src&#x27;), resolve(&#x27;test&#x27;), resolve(&#x27;node_modules/webpack-dev-server/client&#x27;)] &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &#x27;url-loader&#x27;, options: &#123; limit: 10000, name: utils.assetsPath(&#x27;img/[name].[hash:7].[ext]&#x27;) &#125; &#125;, &#123; test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: &#x27;url-loader&#x27;, options: &#123; limit: 10000, name: utils.assetsPath(&#x27;media/[name].[hash:7].[ext]&#x27;) &#125; &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: &#x27;url-loader&#x27;, options: &#123; limit: 10000, name: utils.assetsPath(&#x27;fonts/[name].[hash:7].[ext]&#x27;) &#125; &#125; ] &#125;, node: &#123; // prevent webpack from injecting useless setImmediate polyfill because Vue // source contains it (although only uses it if it&#x27;s native). setImmediate: false, // prevent webpack from injecting mocks to Node native modules // that does not make sense for the client dgram: &#x27;empty&#x27;, fs: &#x27;empty&#x27;, net: &#x27;empty&#x27;, tls: &#x27;empty&#x27;, child_process: &#x27;empty&#x27; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://dongzhu.ink/tags/webpack/"}],"author":"M."},{"title":"前端常考的问题","slug":"前端/前端参考的问题","date":"2020-01-20T14:59:00.000Z","updated":"2020-08-08T01:40:54.949Z","comments":true,"path":"archives/a5104644.html","link":"","permalink":"https://dongzhu.ink/archives/a5104644.html","excerpt":"vue相关的问题汇总 vue组件通信有哪些？ vue组件通信有好几种方法，具体介绍工作中常用的方法父子组件直接的通信，props $emit/$on父组件向子组件通信， 只需要 父组件中绑定响应方法， 子组件通过 props 直接接收使用即可，子组件向父组件通信， - 子组件上面绑定一个事件方法， 方法中通过 this.$emit(&#39;自定义事件名&#39;，&#39;传递的参数&#39;) - 父组件中需要接收 v-on:自定义事件名= 来获取数据子组件向父组件通信，$emit/$on 订阅者发布则模式， 实现 兄弟之间通信 var Event=new Vue(); // 创建一个消息队列Event.$emit(事件名,数据); // 子组件发送事件Event.$on(事件名,data =&gt; &#123;&#125;); // 父组件接收","text":"vue相关的问题汇总 vue组件通信有哪些？ vue组件通信有好几种方法，具体介绍工作中常用的方法父子组件直接的通信，props $emit/$on父组件向子组件通信， 只需要 父组件中绑定响应方法， 子组件通过 props 直接接收使用即可，子组件向父组件通信， - 子组件上面绑定一个事件方法， 方法中通过 this.$emit(&#39;自定义事件名&#39;，&#39;传递的参数&#39;) - 父组件中需要接收 v-on:自定义事件名= 来获取数据子组件向父组件通信，$emit/$on 订阅者发布则模式， 实现 兄弟之间通信 var Event=new Vue(); // 创建一个消息队列Event.$emit(事件名,数据); // 子组件发送事件Event.$on(事件名,data =&gt; &#123;&#125;); // 父组件接收 Vuex实现各个组件之间的通信简单点的理解就是 vuex类似第三方的数据管理，a,b,c..等待组件 只用调用vuex，就可以获取和修改上面的数据，这样就实现了通信 // 模块化管理 Vuex// 用户信息模块，user.js const user = new Vuex.Store(&#123; state:&#123; // 存放状态，变量数据 loginStartus:false &#125;, getters:&#123; // 加工 state成员给外界，，自带2个参数， state，getters // 通过: 参数， state.获取state中的变量， 通过getters. 调用自己内部其它的方法 &#125;, mutations:&#123; // 同步 操作 数据 login(state)&#123; &#125; &#125;, actions:&#123; // 用来异步操作数据，套装了 mutations， /* 带2个参数， context：上下文 payload 挂在参数 */ &#125;&#125;);// index.jsexport default new Vuex.Store(&#123; modules:&#123; user // 模块化的方式很多， 具体可以看业务需求来弄 &#123;&#125;的形式调用 &#125; &#125;) Vuex数据持久化 解答： 通过vuex-persistedstate 这个插件来完成本地数据存储，从而实现刷新后 state仍然存在 const vuexPres = new VuexPersistence(&#123; storage: window.localStorage, reducer: state=&gt;(&#123; user:state.user&#125;)&#125;)export default new Vuex.Store(&#123; state,actions,mutations,plugins:[vuexPres.plugin]&#125;) Vue的声明周期，各个阶段都干啥的 8个声明周期，如图 vue响应式原理 浅谈一下： vue2.x响应式的底层使用的方法 Object.defineProperty() 消息劫持方式 该方法中存在一个getter和setter的可选项，可以对属性值的获取和设置造成影响Vue中编写了一个 wather 来监听处理数据， 再使用 getter时，会通知water实力对view层渲染页面在使用 setter方法时， 总会在变值的同时， 通知wather实例对view层更新– Object.defineProperty() 方法只部分支持IE9，所以Vue兼容IE版本最低为IE9 v-on可以绑定多个函数吗？ 可以 路由钩子函数 全局的构造函数 beforeEach(to,from,next)针对单个路由钩子函数 beforeEnter(to,from,next)组件钩子函数 beforRouteEnter(to,from,next) 这个路由钩子函数比生命周期beforeCreate函数先执行，所以this实例还没有创建出来 next() 不写的话，不会跳转， sessionStorage localStorage cookie 的区别 他们的区别： 都是保存在浏览器端的， localStorage是永久缓存， 不主动删掉数据，数据不会消失，数据存储大小可以达到5m以上， 不同浏览器不同，在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。 sessionStorage 的生命周期是仅在当前会话下有效。sessionStorage 引入了一个“浏览器窗口”的概念，sessionStorage 是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是 sessionStorage 在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage 也是不一样的 cookie生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右, 有个数限制（各浏览器不同），一般不能超过20个。缺点是不能储存大数据且不易读取 computed和watch的区别 computed: 支持缓存，只有依赖数据发生改变，才会重新进行计算 不支持异步，当computed内有异步操作时无效，无法监听数据的变化 computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。监听函数内部watch 不支持缓存，数据变，直接会触发相应的操作； watch支持异步； 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值； 当一个属性发生变化时，需要执行对应的操作；一对多； 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数， immediate：组件加载立即触发回调函数执行， deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。 单页面和多页面应用什么时虚拟DOM 通过js 创建 和原dom 以对象嵌套的方式来表示的dom树, 来替换掉直接对原生 dom的操作，这样 dom 的更改就变成了 js 对象的属性的更改，这样一来就能查找 js 对象的属性变化要比查询 dom 树的性能开销小 v-for 中 key 的作用是什么v-show he v-if的区别 v-show 不显示，但也渲染v-if 显示就渲染，不显示就不渲染， vue-loader？ 作用： 解析和转换.vue文件。提取出其中的逻辑代码 script,样式代码style,以及HTML 模板template，再分别把他们交给对应的loader去处理将es6转换成es5 什么是 mixinvue-cli如何配置方向代理props 如何指定类型props:&#123;id:[Object,Number] &#125; Vue 声明周期中，created 通常用于做什么 获取数据 什么时候执行updated 周期Vue的钩子函数为何不能是用箭头函数 this指向未定义 keep-alive什么时候使用？路由传值有哪些方式？ 工作中常用的的2种方式： {name：’’,params:{id;’’}} params 不显示 获取参数 this.$route.params.id {path:’/path’,query:{id:’’}} query 显示 this.$route.query.id Vuex的使用过程？ state：vuex的基本数据，用来存储变量geeter：从基本数据(state)派生的数据，相当于state的计算属性mutation：提交更新数据的方法，必须是同步的(如果需要异步使用action)action：和mutation的功能大致相同，不同之处在于 ==》1. Action 提交的是 mutation，而不是直接变更状态。 2. Action 可以包含任意异步操作。 什么是异步组件 异步组件就是定义的时候什么都不做，只在组件需要渲染（组件第一次显示）的时候进行加载渲染并缓存，缓存是以备下次访问。 懒加载，按需加载 Vue.nextTickjs相关的问题汇总 new的作用 在内存中创建一个新的空对象 让this指向这个新的对象 执行构造函数里面的代码： 目的就是给这个新对象添加属性和方法 返回这个新对象 (构造函数里面不需要放回) 字符串反转// 方法一， 拆分，数组反转， 数组拼接字符串let op =&#x27;abcdefg&#x27;;let newOp = op.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);// 方法二let newOp2 = &#x27;&#x27;;for (let f in op)&#123;newOp2 = f +newOp2 &#125;// 方法三 proto 和 prototype __proto__ :私有属性，表示只能在内部使用 ==&gt; 该属性指向当前对象的构造函数的原型，它保证了对象实例能够访问在构造函数原型中定义的所有属性和方法。 prototype: 指向原型对象，这个对象包含所有实例共享的属性和方法 ==&gt;我们把prototype属性叫做原型属性。prototype指向的原型对象又有一个属性constructor，这个属性也是一个指针，指回原构造函数 js执行上下文 当函数执行时，会创建一个称为执行上下文的内部对象（可理解为作用域）。一个执行上下文定义了一个函数执行时的环境。 创建阶段 创建作用域链 创建变量对象 求 this 的值 激活/代码执行阶段。 原型链继承 参考JavaScript原型链和继承 call bind apply区别 都是改变函数this指向call和apply 参数传递不一样， call是以直接传入(obj,arg1,arg2...)， apply是以数组的形式传入(obj,[arg1,arg2...])call,apply 方法是再调用之后立即执行函数， 而bind方法不立刻执行， 需要将函数再执行一遍 列表去重 es6去重： let arr = [1,2,3,4,2,34,54,1,2,34,4];let newArr1 = arr.filter((x, index,self)=&gt;self.indexOf(x)===index) let newArr2 = Array.from( new Set(arr)); es5去重： var newArr =[]for (var i=0; i&lt;arr.length;i++)&#123; if (newArr.indexOf(arr[i]) !== -1) &#123;newArr.shift(arr[i])&#125; &#125; 宏任务，微任务，事务循环 微任务： promise 创建的任务，宏观任务： 定时器异步的任务， 原生js 实现冒泡排序， 和深拷贝 冒泡算法 let nums = [12,7,34,65,88,1,3,5,7,12] function bubble(art)&#123; for(let i=0;i&lt;art.length-1;i++)&#123; for (let j=0;j&lt;art.length-1-i;j++) if(art[j]&gt;art[j+1])&#123; // 当前项大于后一项 let temp = []; // art[j],art[j+1] = art[j+1],art[j] temp = art[j] art[j]=art[j+1] art[j+1] = temp &#125; &#125; return art&#125; 如何判断一个变量是数组还是对象？ 使用 toString()方法// 兼容性比较好 let a = [1,2,3,4];let b = &#123; &#x27;c&#x27;:2&#125;;Object.prototype.toString.call(a); //=&gt;&quot;[object Array]&quot;Object.prototype.toString.call(b) //=&gt; &quot;[object Object]&quot; 使用 Array.isArray() 方法 Array.isArray(a); // trueArray.isArray(b) // false// 不存在Array.isArray() 创建if (!Array.isArray) &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === &#x27;[object Array]&#x27;; &#125;;&#125; ES6中forEach和map方法有何区别？ map()根据当前数组映射出一个新的数组，map和forEach等遍历方法不同，在forEach中return语句是没有任何效果的，而map则可以改变当前循环的值，返回一个新的被改变过值之后的数组（map需return），一般用来处理需要修改某一个数组的值forEach遍历方式遍历数组全部元素，利用回调函数对数组进行操作，自动遍历数组.length次，且无法break中途跳出循环，不可控、不支持return操作输出，return只用于控制循环是否跳出当前循环 什么是闭包? js中的闭包 节流和防抖有何区别? 有什么作用? 节流：规定时间内触发一次，==&gt; 稀释函数的执行频率防抖：一个需要频繁触发的函数,在规定时间内,只让最后一次生效,前面不生效,再次触发，从新计算时间作用： 都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象 this是什么，如何改变其指向？ this: 包含他的函数，作为方法被调用时， 所属的对象谁调用函数，执行，this就指向谁， 什么是事件冒泡, 如何阻止默认事件 事件冒泡: 一个事件的执行从调用它的对象向它的父级对象传播，直到全部执行阻止冒泡： window.event? window.event.cancelBubble = true : e.stopPropagation(); //兼容性考虑阻止默认事件: event.preventDefault()， return false考虑到兼容行， 再别的浏览器中：IE： window.event.returnValue = false;//阻止事件的默认行为FireFor： event.preventDefault();// 阻止事件的默认行为 mouseenter和mouseover的区别 mouseover: 当鼠标指针位于元素上方时，会发生 mouseover 事件。mouseover最用于目标元素及其后代元素mouseenter: 当鼠标指针穿过元素时，会发生 mouseenter 事件。mouseenter事件只作用于目标元素 什么是事件委托？ 有什么作用？ 利用事件冒泡，只指定一个事件处理程序来管理某一类型的所有事件。减少DOM操作，节省内存空间，提高性能。 Eventloop JavaScript的一种运行机制Event Loop是一个程序结构，用于等待和发送消息和事件简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为&quot;主线程&quot;； 另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为&quot;Event Loop线程&quot;（可以译为&quot;消息线程&quot;） 跨域有哪几种，如何解决 当协议、子域名、主域名、端口号中任意一各不相同时，都算不同的“域”。 请求就出现了跨域， 工作中常遇到的的： CORS跨域 ： 各种请求， 只需要后端配置 JSONP ： 只持此get请求 手写原生ajaxwindow.onload 和 $(docunment.read)的区别 执行时机： window.onload ：必须在页面所有元素（包括图片，引用文件）加载完后执行。。 $(document).ready() ：是页面中所有HTML DOM，CSS DOM结构加载完之后就会执行，其他图片可能没有加载完。 编写个数不同 window.onload ：不能同时写多个，后面的将会覆盖前面的 $(document).ready() ：可以同时编写多个，并且都可以得到执行。 简写 window.onload ：无。 $(document).ready() ：=》 $().ready(function()&#123;&#125;) =&gt; $(function()&#123;&#125;) 原生js 获取和jQuery获取元素 原生js &lt;div id=&#x27;box&#x27; class=&quot;cp&quot;&gt;&lt;/div&gt;&lt;script&gt;document.getElementById(&#x27;box&#x27;)document.getElementsByTagName(&#x27;div&#x27;)document.getElementsByClassName(&#x27;cp&#x27;)// 选择器document.querySelector(&#x27;#box&#x27;)||document.querySelectorAll(&#x27;.cp&#x27;);document.getElementsByName(&#x27;x&#x27;); // 返回name属性为x的伪数组&lt;/script&gt; jQuery中获取元素 // 基础选择器$(&#x27;#id&#x27;)$(&#x27;li&#x27;)$(&#x27;.class&#x27;)// 交集，并列选择器$(&#x27;&#x27;,&#x27;&#x27;,)$(ul.li)// 层次选择器$(&#x27;li span&#x27;); //后代选择器，li后代中所有的span$(&#x27;li&gt;span&#x27;); //子代选择器，li子代中所有的span$(&#x27;#dv~span&#x27;);//#dv后方兄弟span标签$(&#x27;#dv+span&#x27;);//#dv后方直接跟着的兄弟span标签// 索引选$(对象:eq(索引值)); //选中该索引值对应的对象$(对象:lt(索引值)) //选中小于该索引值所有的对象$(对象:gt(索引值))//选中大于该索引值所有的对象$(对象:odd/even) //选中索引值为奇数/偶数的对象 DOM的增删改 Dom的操作 appendChild(追加为子元素) insertBefore(插入前面) removeChild(删除子元素) replaceChild(替换子元素) 选择器, id,tag, break continue 和for 循环的区别 break:终止循环continue:跳过这条循环for 循环 null 和 undefined的区别 , typeof null的值？ null: object类型，代表“空值”，代表一个空对象指针， 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。 undefined: 声明未给值，undefined类型 变量被声明了，但没有赋值时，就等于undefined。 例如， 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时或者return后面什么也没有，返回undefined。 typeof null: “object” console.log(null==undefined)//true console.log(null===undefined)//false GET和POST 的区别 get参数通过url传递，post放在request body中 get请求在url中传递的参数是有长度限制的，而post没有。 get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。 get请求只能进行url编码，而post支持多种编码方式 get请求会浏览器主动cache，而post支持多种编码方式。 get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。 手写实现原型链继承ES6 新特性（变量，数组方法，箭头函数）css 项目的问题汇总 标准盒子模型和怪异盒模型 在标准模式下，一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值） 什么是盒子模型水平垂直居中的方式flex布局 伸缩盒布局 阮一峰-flex布局容器（父元素设置）上的属性 flex-direction 属性决定主轴的方向（即项目的排列方向） row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap ：默认情况下，项目都排在一条线（又称”轴线”）上 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flow : 属性是flex-direction属性和flex-wrap属性的简写形式: 默认值为 row nowrap flex-flow: || justify-content : 布局方式 属性定义了项目在主轴上的对齐方式 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items 属性定义项目在交叉轴上如何对齐 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content : 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的（子元素）属性 order : ; 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow : ; /* default 0 */ 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink : 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。=&gt;负值对该属性无效。 flex-basis : | auto; /* default auto */ 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小 flex : none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ] 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-self : 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 css五种定位 static 定位(普通流定位) ————– 默认定位 relative 定位(相对定位) position:relative; 该元素不脱离文档流，依然占浏览器位置。 常用来作为绝对定位元素的容器。可通过left、top、right、bottom值进行偏移，不设偏移量时位置不变。可以通过z-index改变层叠顺序 absolute 定位(绝对定位) position:absolute; 脱离文档流，不再占据空间，因此，下面的元素会顶上来。 fixed；固定定位 position:fixed 脱离文档流，和绝对定位不同，固定定位会使该元素固定在某个位置不动。 sticky (粘性定位) position:sticky; CSS3新增的定位属性，用于页面滚动时的定位，一般用于吸顶效果, 粘性定位的父元素不能设置overflow:hidden和overflow:auto;否则不能实现吸顶效果。 css变量 用 -- 声明, var() 函数用于读取变量 阮一峰-css变量 body &#123; --foo: #7F583F; --bar: #F7EFD2;&#125;/*var() 函数用于读取变量。*/a &#123; color: var(--foo); text-decoration-color: var(--bar);&#125;/* 函数还可以使用第二个参数，表示变量的默认值。如果该变量不存在，就会使用这个默认值。*/color: var(--foo, #7F583F); 伪元素和伪类 before 和 after是经常经常重用的伪元素 hover 和active 属于UI伪类区别：伪类和选择器之间用一个冒号隔开，伪元素则是两个冒号隔. css如何实现左侧固定，右侧自动适应布局 定位， 左右2变固定定位， 中间 auto自动适应flex布局， 左右给定固定的宽度， 中间 flex：1 ~ + &gt; 在css3 中表示什么什么是浮动 如何清除浮动？@import 和 link 的区别 加载顺序不通， link是异步， @import 是页面加载完成后被加载 DOM操作 link引入的权重， 大于@improt ==》 引入的在最上面 从属关系， link 是html 标签， @import是css关键字 BFC FFC IFC BFC 块级格式化上下文 vw 和 rem 怎么用 vw 是视口单位，相当于把视口等分成了100，1vw = 1 rem是相对单位，设置根元素 html 的 font-size，比如给 html 设置字体大小为100px，1rem = 100px; 举例：我们以 iPhone6为基准，屏幕宽度为375px，然后换算成 vw 375 / 100 = 3.75;一般使用 rem 会给 html 的 font-size 设置大小为 100px，因为方便计算，这里需要把100px 换算为 vw 100 / 3.75 = 26.6666666vw 注：上面结果能最大限度减少像素偏差，经测试，若值舍五入为27vw或26vw都会有1-2像素的偏差 前端性能，多端适配， 综合题型 性能优化，简单说一下从输入网站到页面显示发生了什么？你从哪些方便考虑，来做性能优化？如何快速显示一个页面？网站打开速度优化的几种方式 借助外部力量优化，CDN加速、云存储等。 网站图片压缩优化， 对于网站代码优化这方面， 服务器端，在服务器端要记得开启GZIP压缩功能,客户端浏览器快速解压的原理 使用浏览器缓存 减少重定向请求","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://dongzhu.ink/tags/javascript/"},{"name":"React","slug":"react","permalink":"https://dongzhu.ink/tags/react/"},{"name":"css","slug":"css","permalink":"https://dongzhu.ink/tags/css/"},{"name":"vue","slug":"vue","permalink":"https://dongzhu.ink/tags/vue/"},{"name":"html","slug":"html","permalink":"https://dongzhu.ink/tags/html/"}],"author":"M."},{"title":"Coding加域名部署","slug":"网站建设/Coding加域名部署","date":"2019-11-13T10:49:00.000Z","updated":"2020-08-08T02:45:56.691Z","comments":true,"path":"archives/b96b1f.html","link":"","permalink":"https://dongzhu.ink/archives/b96b1f.html","excerpt":"注册Coding账号密码 Coding注册 注册完成后，登入创建 DevOpos 类型项目， 项目名称,项目表示，自己随定义取名， 跟Github一样 创建项目后，点击项目，找到代码创库，点击克隆项目，复制链接，跟github一样的操作 添加密钥，加本地git生成的公钥添加到Coding中， 个人中心- ssh公钥 中，windows下面的git一般存放再C盘用户名下的.ssh文件id_rsa.pub文件中 再Hexo博客项目根目录下 _config.yml 中设置,","text":"注册Coding账号密码 Coding注册 注册完成后，登入创建 DevOpos 类型项目， 项目名称,项目表示，自己随定义取名， 跟Github一样 创建项目后，点击项目，找到代码创库，点击克隆项目，复制链接，跟github一样的操作 添加密钥，加本地git生成的公钥添加到Coding中， 个人中心- ssh公钥 中，windows下面的git一般存放再C盘用户名下的.ssh文件id_rsa.pub文件中 再Hexo博客项目根目录下 _config.yml 中设置, deploy: type: git # repo: git@github.com:YouAge/youage.github.com.git repository: # 刚创建coding的项目的地址 coding: git@e.coding.net:facade/hexo-blog-matery.git branch: master 使用命令 scripthexo cleanhexo g hexo deploy 提交上去后， 点开项目，看到已更新了， 在点击构建与部署，点击静态网站创建静态网站，网站名字自定义， 项目和仓库选址刚创建的，点击保存，它会生产一个随机访问地址，这样就可以访问了 绑定域名域名设置，绑定 DNS 设置中添加 CNAME 记录指向 打开你购买的域名网站，找到域名，点击解析，点击添加记录，设置添加即可， 点击静态网站，点击右边的设置， 拉到最下面，找到 自定义域名 输入域名，点击绑定。 需要HTTPS, 开启即可，","categories":[{"name":"网站建设","slug":"网站建设","permalink":"https://dongzhu.ink/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://dongzhu.ink/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"M."},{"title":"Liunx常用命令","slug":"工具/Linux常用命令","date":"2019-10-02T08:29:00.000Z","updated":"2020-08-08T01:40:54.985Z","comments":true,"path":"archives/63f1ffdd.html","link":"","permalink":"https://dongzhu.ink/archives/63f1ffdd.html","excerpt":"查看系统相关命令查看系统版本cat /etc/redhat-release查看时间 date 查看磁盘信息 df dudf -h 显示磁盘剩余空间 disk freedu -h [目录名] 显示目录下的文件大小 disk usageps -ef |grep python # 查看python运行程序ps -ef|grep python|grep -u dz| grep -v grep # 查看dz用户下的python进程 过滤掉grep进程# 提取pid(awk以空格分割，显示第二个变量即为pid)ps -ef|grep elasticsearch|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;查看进程信息 psps aux process status 查看进程的详细状况top 动态显示运行中的进程并且排序kill [-9] 进程代号 终止指定代号的进程，-9 表示强行终止 -----参数含义------&gt;&gt;&gt;a 显示终端上的所有进程，包括其他用户的进程u 显示进程的详细状态x 显示没有控制终端的进程--------注意点-----&gt;&gt;&gt;ps 默认只会显示当前用户通过终端启动的应用程序使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃要退出 top 可以直接输入 q","text":"查看系统相关命令查看系统版本cat /etc/redhat-release查看时间 date 查看磁盘信息 df dudf -h 显示磁盘剩余空间 disk freedu -h [目录名] 显示目录下的文件大小 disk usageps -ef |grep python # 查看python运行程序ps -ef|grep python|grep -u dz| grep -v grep # 查看dz用户下的python进程 过滤掉grep进程# 提取pid(awk以空格分割，显示第二个变量即为pid)ps -ef|grep elasticsearch|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;查看进程信息 psps aux process status 查看进程的详细状况top 动态显示运行中的进程并且排序kill [-9] 进程代号 终止指定代号的进程，-9 表示强行终止 -----参数含义------&gt;&gt;&gt;a 显示终端上的所有进程，包括其他用户的进程u 显示进程的详细状态x 显示没有控制终端的进程--------注意点-----&gt;&gt;&gt;ps 默认只会显示当前用户通过终端启动的应用程序使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃要退出 top 可以直接输入 q 文件权限管理 chmodchmod 可以修改 用户／组 对 文件／目录 的权限chmod +/-rwx 文件名|目录名 -R 递归修改# 修改文件|目录的拥有者chown 用户名 文件名|目录名# 递归修改文件|目录的组chgrp -R 组名 文件名|目录名# 递归修改文件权限chmod -R 755 文件名|目录名权限数字对应r--&gt;4w--&gt;2x--&gt;1拥有者(rwx),组(rwx),其他(rwx)rwx--7rw- --&gt;6---查看log最后10行tail -n 10 test.logtail -n +10 test.log 查询10行之后的所有日志;head -n 10 test.log 查询日志文件中的头10行日志;head -n -10 test.log 查询日志文件除了最后10行的其他所有日志;grep “要查找的字符串” 文件名 yum安装软件卸载安装：yum -y install ...卸载：yum -y remove ... 通配符的使用* 代表任意个数个字符? 代表任意一个字符，至少 1 个[] 表示可以匹配字符组中的任一一个[abc] 匹配 a、b、c 中的任意一个[a-f] 匹配从 a 到 f 范围内的的任意一个字符 liunx文件和目录常用命令查看目录 ls ls -a (ll)显示指定目录下所有子目录与文件，包括隐藏文件ls -l 以列表方式显示文件的详细信息ls -h 配合 -l 以人性化的方式显示文件大小创建文件 touch ..创建文件夹 mkdir ..-p 可以递归创建目录删除 rm -f:强制删除-i:交互模式，在删除前询问用户是否操作-r:递归删除，常用在目录的删除复制 cp-i 覆盖文件前提示-r 若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名移动 mv-f:force，强制直接移动而不询问-i:若目标文件(destination)已经存在，就会询问是否覆盖-u:若目标文件已经存在，且源文件比较新，才会更新-------------------------------Linux 系统中 grep 命令是一种强大的文本搜索工具grep允许对文本文件进行 模式查找，所谓模式查找，又被称为正则表达式，在就业班会详细讲解-n 显示匹配行及行号-v 显示不包含匹配文本的所有行（相当于求反）-i 忽略大小写常用的两种模式查找^a 行首，搜寻以 a 开头的行ke$ 行尾，搜寻以 ke 结束的行 远程管理常用命令重启操作系统，now表现在$ shutdown -r now立刻关机$ shutdown mow系统在今天 20:25关机$ shutdown 20:25系统再过十分钟后关机$ shutdown +10取消之前制定的关机计划shutdown -c重启系统 reboot now查看网卡 Ipifconfigping Ip地址linux系统间文件传输：# 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py# 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径scp -P port 01.py user@remote:Desktop/01.py# 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.pyscp -P port user@remote:Desktop/01.py 01.py# 加上 -r 选项可以传送文件夹# 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktopscp -r demo user@remote:Desktop# 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹scp -r user@remote:Desktop demo--------参数含义-r 若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名-P 若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口-------------------------------- tar解压打包命令# 打包文件tar -cvf 打包文件.tar 被打包的文件／路径...# 解包文件tar -xvf 打包文件.tar------&gt;&gt;参数含义---------&gt;&gt;c 生成档案文件，创建打包文件x 解开档案文件v 列出归档解档的详细过程，显示进度f 指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后---------&gt;&gt;&gt;gzip 压缩/解压# 压缩文件tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...# 解压缩文件tar -zxvf 打包文件.tar.gz# 解压缩到指定路径tar -zxvf 打包文件.tar.gz -C 目标路径-C 解压缩到指定目录，注意：要解压缩的目录必须存在&lt;&lt;&lt;&lt;-------------------------- ### Supervisor 进程守护安装及其配置 【安装】 pip install supervisor【生成supervisor默认配置文件】echo_supervisord_conf &gt; /etc/supervisord.conf【启动 】supervisord -c /etc/supervisord.conf 【centos 配置开启自动启动】#supervisord.service-------------------------------------------------[Unit] Description=Supervisor daemon[Service] Type=forking ExecStart=/usr/bin/supervisord -c /etc/supervisord.conf ExecStop=/usr/bin/supervisorctl shutdown ExecReload=/usr/bin/supervisorctl reload KillMode=process Restart=on-failure RestartSec=42s[Install] WantedBy=multi-user.target---------------------------------------------------// 把文件深拷贝到 /usr/lib/systemd/system/cp supervisord.service /usr/lib/systemd/system/// 启动服务systemctl enable supervisordreboot new 重启电脑-------------------相关命令-----------supervisorctl status --#查看所以进程supervisorctl stop all --#关闭所有supervisorctl stop 加要关闭的程序名restart重启supervisorctl update #新增任务----系统systemctl stop firewalld.service 停止systemctl disable firewalld.service 关闭开启 Liunx定时任务crontab// TODO 查看是否安装：rpm -qa | grep crontab // TODO 任务存在路径， 对应用户名文件/var/spool/cron新增调度任务可用两种方法： 1)、在命令行输入: crontab -e 然后添加相应的任务，wq存盘退出。 2)、直接编辑/etc/crontab 文件，即vi /etc/crontab，添加相应的任务。查看调度任务 crontab -l //列出当前的所有调度任务 crontab -l -u jp //列出用户jp的所有调度任务删除任务调度工作 crontab -r //删除所有任务调度工作任务编写命令: Minute Hour Day Month Dayofweek command 分钟 小时 天 月 天每星期 命令--在这些字段里，除了“Command”是每次都必须指定的字段以外，其它字段皆为可选字段，可视需要决定。对于不指定的字段，要用“*”来填补其位置5 * * * * ll 指定每小时的第5分钟执行一次ll命令30 5 * * * ll 指定每天的 5:30 执行ll命令30 7 8 * * ll 指定每月8号的7：30分执行ll命令30 5 8 6 * ll 指定每年的6月8日5：30执行ll命令30 6 * * 0 ll 指定每星期日的6:30执行ll命令[注：0表示星期天，1表示星期1，以此类推，也可以用英文来表示，sun表示星期天，mon表示星期一等。]30 3 10,20 * * ll 每月10号及20号的3：30执行ll命令[注：“，”用来连接多个不连续的时段]25 8-11 * * * ll 每天8-11点的第25分钟执行ll命令[注：“-”用来连接连续的时段]*/15 * * * * ll 每15分钟执行一次ll命令 [即每个小时的第0 15 30 45 60分钟执行ls命令 ]在shell脚本中&gt; ，这个表示向文件重新添加内容，该文件首先被清空而 &gt;&gt; ，这个表示想文件追加内容，原来的内容不会被清理掉。","categories":[{"name":"工具","slug":"工具","permalink":"https://dongzhu.ink/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://dongzhu.ink/tags/linux/"}],"author":"M."},{"title":"Linux安装python","slug":"工具/Linux安装python","date":"2019-09-02T05:49:00.000Z","updated":"2020-08-08T01:40:55.176Z","comments":true,"path":"archives/c7c488b9.html","link":"","permalink":"https://dongzhu.ink/archives/c7c488b9.html","excerpt":"编写 shell脚本自动安装python环境 #!/bin/bash#set -x # 脚本运行情况输出## 安装EPEL和IUS软件源# 获取用户名username=$(whoami)yum install epel-release -yyum install https://centos7.iuscommunity.org/ius-release.rpm -y## 安装python3.6版本yum install python36u -yyum install python36u-devel -y## 安装python需要的系统环境yum install -y openssl-devel openssl-static zlib-devel lzma tk-devel xz-devel bzip2-devel ncurses-devel gdbm-devel readline-devel sqlite-devel gcc libffi-devel gcc-c++# 修改pip下载源， 创建当前用户目录创建使用mkdir /$username/.pipcat &gt; /$username/.pip/pip.conf &lt;&lt; eof[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.comeof# mv pip.conf /root/.pip/pip.confif [ $username == &quot;root&quot; ]; then #supervisor 安装需要 root 权限， # 安装supervisor 进程守护 pip3 install supervisor # 【生成supervisor默认配置文件】 echo_supervisord_conf &gt; /etc/supervisord.conf # 启动 supervisord 启动项目 supervisord -c /etc/supervisord.conf # 配置开机自启， 检查一下 whereis supervisord 的路径，修改对应的 ExecStart=/usr/bin/supervisord # ExecStart=/usr/bin/supervisord # 生成开机自启的配置 cat &gt; /usr/lib/systemd/system/supervisord.service &lt;&lt; eof[Unit]Description=Supervisor daemon[Service]Type=forking#ExecStart=/usr/local/bin/supervisord -c /etc/supervisord.confExecStop=/usr/local/bin/supervisorctl shutdownExecReload=/usr/local/bin/supervisorctl reloadKillMode=processRestart=on-failureRestartSec=42s[Install]WantedBy=multi-user.targeteof# mv supervisord.service /usr/lib/systemd/system/ # 启动服务 systemctl enable supervisordelse echo &quot;请在 root权限下安装，supervisor&quot;fi","text":"编写 shell脚本自动安装python环境 #!/bin/bash#set -x # 脚本运行情况输出## 安装EPEL和IUS软件源# 获取用户名username=$(whoami)yum install epel-release -yyum install https://centos7.iuscommunity.org/ius-release.rpm -y## 安装python3.6版本yum install python36u -yyum install python36u-devel -y## 安装python需要的系统环境yum install -y openssl-devel openssl-static zlib-devel lzma tk-devel xz-devel bzip2-devel ncurses-devel gdbm-devel readline-devel sqlite-devel gcc libffi-devel gcc-c++# 修改pip下载源， 创建当前用户目录创建使用mkdir /$username/.pipcat &gt; /$username/.pip/pip.conf &lt;&lt; eof[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.comeof# mv pip.conf /root/.pip/pip.confif [ $username == &quot;root&quot; ]; then #supervisor 安装需要 root 权限， # 安装supervisor 进程守护 pip3 install supervisor # 【生成supervisor默认配置文件】 echo_supervisord_conf &gt; /etc/supervisord.conf # 启动 supervisord 启动项目 supervisord -c /etc/supervisord.conf # 配置开机自启， 检查一下 whereis supervisord 的路径，修改对应的 ExecStart=/usr/bin/supervisord # ExecStart=/usr/bin/supervisord # 生成开机自启的配置 cat &gt; /usr/lib/systemd/system/supervisord.service &lt;&lt; eof[Unit]Description=Supervisor daemon[Service]Type=forking#ExecStart=/usr/local/bin/supervisord -c /etc/supervisord.confExecStop=/usr/local/bin/supervisorctl shutdownExecReload=/usr/local/bin/supervisorctl reloadKillMode=processRestart=on-failureRestartSec=42s[Install]WantedBy=multi-user.targeteof# mv supervisord.service /usr/lib/systemd/system/ # 启动服务 systemctl enable supervisordelse echo &quot;请在 root权限下安装，supervisor&quot;fi pip源修改pip.conf[global] index-url = http://mirrors.aliyun.com/pypi/simple/ [install] trusted-host=mirrors.aliyun.com supervisord.service 文件[Unit] Description=Supervisor daemon[Service] Type=forking ExecStart=/usr/local/bin/supervisord -c /etc/supervisord.confExecStop=/usr/local/bin/supervisorctl shutdownExecReload=/usr/local/bin/supervisorctl reloadKillMode=process Restart=on-failure RestartSec=42s[Install] WantedBy=multi-user.target","categories":[],"tags":[{"name":"Python","slug":"python","permalink":"https://dongzhu.ink/tags/python/"},{"name":"Linux","slug":"linux","permalink":"https://dongzhu.ink/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://dongzhu.ink/tags/shell/"}],"author":"M."},{"title":"谷歌开发工具的使用","slug":"工具/谷歌开发工具的使用","date":"2019-07-14T12:50:00.000Z","updated":"2020-08-08T01:40:54.956Z","comments":true,"path":"archives/63c75ff8.html","link":"","permalink":"https://dongzhu.ink/archives/63c75ff8.html","excerpt":"合理的运用好工具，再开发中的效率会有成倍的增长 Elements 栏使用简介：渲染后的代码，搜索，定位元素，调试样式","text":"合理的运用好工具，再开发中的效率会有成倍的增长 Elements 栏使用简介：渲染后的代码，搜索，定位元素，调试样式 Console 栏使用简介： 命令行，js交互模式， Sources 栏使用简介： 用来调试和定位js代码，快速分析和逆向解析 Network简介： 主要用来抓包，分析url参数 Application简介： 查看cookie，数据缓存 参数","categories":[{"name":"工具","slug":"工具","permalink":"https://dongzhu.ink/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://dongzhu.ink/tags/%E7%88%AC%E8%99%AB/"},{"name":"介绍","slug":"介绍","permalink":"https://dongzhu.ink/tags/%E4%BB%8B%E7%BB%8D/"},{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/tags/%E5%89%8D%E7%AB%AF/"}],"author":"M."},{"title":"DOM的增删改查","slug":"前端/DOM的增删改查","date":"2019-05-04T14:12:00.000Z","updated":"2020-08-08T01:40:54.891Z","comments":true,"path":"archives/c229250e.html","link":"","permalink":"https://dongzhu.ink/archives/c229250e.html","excerpt":"增1. createElement传件自定义标签，IE8以下浏览器不支持自定义标签 let cat = document.createElement(&#x27;cat&#x27;) 通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中; 2. createTexNode创建一个文本节点 var textCont = document.createTextNode(&#x27;一个textCont&#x27;) createTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要append Child将其添加到HTML文档树中 3. cloneNodecloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素 var parent = document.getElementById(&quot;parentElement&quot;); var parent2 = parent.cloneNode(true);// 传入trueparent2.id = &quot;parent2&quot;;","text":"增1. createElement传件自定义标签，IE8以下浏览器不支持自定义标签 let cat = document.createElement(&#x27;cat&#x27;) 通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中; 2. createTexNode创建一个文本节点 var textCont = document.createTextNode(&#x27;一个textCont&#x27;) createTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要append Child将其添加到HTML文档树中 3. cloneNodecloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素 var parent = document.getElementById(&quot;parentElement&quot;); var parent2 = parent.cloneNode(true);// 传入trueparent2.id = &quot;parent2&quot;; 4. createDocumentFragmentcreateDocumentFragment方法用来创建一个DocumentFragment。在前面我们说到DocumentFragment表示一种轻量级的文档，它的作用主要是存储临时的节点用来准备添加到文档中createDocumentFragment方法主要是用于添加大量节点到文档中时会使用到。假设要循环一组数据，然后创建多个节点添加到文档中 &lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt;&lt;input type=&quot;button&quot; value=&quot;添加多项&quot; id=&quot;btnAdd&quot; /&gt;document.getElementById(&quot;btnAdd&quot;).onclick = function()&#123; var list = document.getElementById(&quot;list&quot;); for(var i = 0;i &lt; 100; i++)&#123; var li = document.createElement(&quot;li&quot;); li.textContent = i; list.appendChild(li); &#125;&#125;;/*这段代码将按钮绑定了一个事件，这个事件创建了100个li节点，然后依次将其添加HTML文档中。这样做有一个缺点：每次一创建一个新的元素，然后添加到文档树中，这个过程会造成浏览器的回流。所谓回流简单说就是指元素大小和位置会被重新计算，如果添加的元素太多，会造成性能问题。*/// 修改，保存在内存中， 不会造成回流document.getElementById(&quot;btnAdd&quot;).onclick = function()&#123; var list = document.getElementById(&quot;list&quot;); var fragment = document.createDocumentFragment(); for(var i = 0;i &lt; 100; i++)&#123; var li = document.createElement(&quot;li&quot;); li.textContent = i; fragment.appendChild(li); &#125; list.appendChild(fragment);&#125;/*优化后的代码主要是创建了一个fragment，每次生成的li节点先添加到fragment，最后一次性添加到list*/ 它们创建的节点只是一个孤立的节点， 要通过appendChild添加到文档中 cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题 使用createDocumentFragment来解决添加大量节点时的性能问题 页面修改，删除1. appendChild(追加为子元素)2. insertBefore(插入前面)3. removeChild(删除子元素)4. replaceChild(替换子元素)查， 选择器 document.getElementById(&#39;box&#39;) document.getElementsByTagName(&#39;div&#39;) document.getElementsByClassName(&#39;cp&#39;) document.querySelector(&#39;#box&#39;)||document.querySelectorAll(&#39;.cp&#39;); document.getElementsByName(&#39;x&#39;); // 返回name属性为x的伪数组 元素属性型操作（属性节点的操作） getAttribute(name)用于获取元素的属性值 createAttribute(name)方法生成一个新的属性对象节点，并返回它。 setAttribute(name, value)方法用于设置元素属性 removeAttribute(name)用于删除元素属性 element.attributes（将属性生成数组对象） innerText和innerHTML（outerHTML）区别？ innerText返回的是元素内包含的文本内容（只返回文本节点类型）； innerHTML返会元素内HTML结构，包括元素节点、注释节点、文本节点； outerHTML返回包括元素节点自身和里面的所有元素节点、注释节点、文本节点；","categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javaScript","slug":"javascript","permalink":"https://dongzhu.ink/tags/javascript/"}],"author":"M."},{"title":"Redis-Python操作","slug":"数据库/Redis-Python操作","date":"2019-05-02T07:47:00.000Z","updated":"2020-08-08T01:40:54.996Z","comments":true,"path":"archives/f6341479.html","link":"","permalink":"https://dongzhu.ink/archives/f6341479.html","excerpt":"redis 的一些常用命令，与python的交互 redis性能分析软件 查看redis内存大小&gt;&gt; select 6 # 指定db库&gt;&gt; INFO MEMORY # 查看 Redis数据库import redis # 连接redisclient =redis.StrictRedis(host=&#x27;&#x27;,port=&#x27;&#x27;,db=&#x27;&#x27;)# ----- (1)直接连接 -------- # 导入redis模块，通过python操作redis 也可以直接在redis主机的服务端操作缓存数据库#加上decode_responses=True，写入的键值对中的value为str类型，不加这个参数写入的则为字节类型。r = redis.Redis(host=&#x27;localhost&#x27;, port=6379, decode_responses=True) # host是redis主机，需要redis服务端和客户端都启动 redis默认端口是6379r.set(&#x27;name&#x27;, &#x27;junxi&#x27;) # key是&quot;foo&quot; value是&quot;bar&quot; 将键值对存入redis缓存print(r[&#x27;name&#x27;])print(r.get(&#x27;name&#x27;)) # 取出键name对应的值print(type(r.get(&#x27;name&#x27;)))#-----（2）连接池 ---------pool = redis.ConnectionPool(host=&#x27;localhost&#x27;, port=6379, decode_responses=True) # host是redis主机，需要redis服务端和客户端都起着 redis默认端口是6379r = redis.Redis(connection_pool=pool)r.set(&#x27;gender&#x27;, &#x27;male&#x27;) # key是&quot;gender&quot; value是&quot;male&quot; 将键值对存入redis缓存print(r.get(&#x27;gender&#x27;)) # gender 取出键male对应的值# -----redis 基本命令 String -----------set(name, value, ex=None, px=None, nx=False, xx=False)&#x27;&#x27;&#x27;ex，过期时间（秒）px，过期时间（毫秒）nx，如果设置为True，则只有name不存在时，当前set操作才执行xx，如果设置为True，则只有name存在时，当前set操作才执行&#x27;&#x27;&#x27;# -----redis 集群连接------from rediscluster import StrictRedisCluster### 存在 redis-py-cluster 和redis 版本要对应， 不然会导入不了StrictRedisCluster包client = StrictRedisCluster(startup_nodes=REDIS_HOSTS, decode_responses=True) # redis==2.10.6# redis-py-cluster==1.3.4","text":"redis 的一些常用命令，与python的交互 redis性能分析软件 查看redis内存大小&gt;&gt; select 6 # 指定db库&gt;&gt; INFO MEMORY # 查看 Redis数据库import redis # 连接redisclient =redis.StrictRedis(host=&#x27;&#x27;,port=&#x27;&#x27;,db=&#x27;&#x27;)# ----- (1)直接连接 -------- # 导入redis模块，通过python操作redis 也可以直接在redis主机的服务端操作缓存数据库#加上decode_responses=True，写入的键值对中的value为str类型，不加这个参数写入的则为字节类型。r = redis.Redis(host=&#x27;localhost&#x27;, port=6379, decode_responses=True) # host是redis主机，需要redis服务端和客户端都启动 redis默认端口是6379r.set(&#x27;name&#x27;, &#x27;junxi&#x27;) # key是&quot;foo&quot; value是&quot;bar&quot; 将键值对存入redis缓存print(r[&#x27;name&#x27;])print(r.get(&#x27;name&#x27;)) # 取出键name对应的值print(type(r.get(&#x27;name&#x27;)))#-----（2）连接池 ---------pool = redis.ConnectionPool(host=&#x27;localhost&#x27;, port=6379, decode_responses=True) # host是redis主机，需要redis服务端和客户端都起着 redis默认端口是6379r = redis.Redis(connection_pool=pool)r.set(&#x27;gender&#x27;, &#x27;male&#x27;) # key是&quot;gender&quot; value是&quot;male&quot; 将键值对存入redis缓存print(r.get(&#x27;gender&#x27;)) # gender 取出键male对应的值# -----redis 基本命令 String -----------set(name, value, ex=None, px=None, nx=False, xx=False)&#x27;&#x27;&#x27;ex，过期时间（秒）px，过期时间（毫秒）nx，如果设置为True，则只有name不存在时，当前set操作才执行xx，如果设置为True，则只有name存在时，当前set操作才执行&#x27;&#x27;&#x27;# -----redis 集群连接------from rediscluster import StrictRedisCluster### 存在 redis-py-cluster 和redis 版本要对应， 不然会导入不了StrictRedisCluster包client = StrictRedisCluster(startup_nodes=REDIS_HOSTS, decode_responses=True) # redis==2.10.6# redis-py-cluster==1.3.4 redis字符串Strings Python操作Redis的redis模块对字符串（string）的主要操作函数包括：SET、GET、GETSET、SETEX、SETNX、MSET、MSETNX、INCR(INCRBY,DECR,DECRBY在python中庸同一个函数incr实现)、APPEND、SETRANGE、STRLEN。函数说明如下： SET： 为指定的键（key）设置值（value）， set(self, name, value, **kwargs)。 GET：获取指定键（key）绑定的值（value），get(self, name)。 GETSET：为指定的键（key）设置新的值（value），并返回旧的值（old Value），getset(self, name, value) SETEX：为指定的键（key）设置过期以秒（second）计的过期时间，setex(self, name, value, time) SETNX：键（key）不存在时，为键（key）指定值（value），setnx(self, name, value) MSET：一次性设置多个键-值(key-value)对,函数设置的键-值对（即mapping所指内容）数据要以Python字典数据类型传入，mset(self, mapping) MSETNX：键-值(key-value)对不存在时，设置键-值（key-value）对,msetnx(self, mapping)，mapping值参考6 INCR：自增函数，默认步长为1，通过对步长（amount）大小以及字符的控制实现了INCRBY（amount&gt;=1）、DECR（amount=-1）、DECRBY（amount&lt;=-1）等函数功能，incr(self, name, amount=1) APPEND：为指定的字符串追加值，若不存在则直接创建，append(self, key, value) SETRANGE：用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始，setrange(self, name, offset, value) STRLEN：返回字符串的长度，当name不存在时返回0，strlen(self, name) #!/usr/bin/python# -*- coding:utf-8 -*-import redisimport timepool = redis.ConnectionPool(host=&#x27;127.0.0.1&#x27;, port=6379,decode_responses=True)## pool = redis.StrictRedis(host=&#x27;127.0.0.1&#x27;, port=6379,decode_responses=True)r = redis.Redis(connection_pool=pool)r.flushall() # 清空Redisr.setex(&#x27;name&#x27;, value=&#x27;liaogx&#x27;, time=2) # 设置新值，过期时间为3sr.mset(k1 = &#x27;v1&#x27;, k2 = &#x27;v2&#x27;, k3 = &#x27;v3&#x27;) # 批量设置新值print(r.mget(&#x27;k1&#x27;, &#x27;k2&#x27;, &#x27;k3&#x27;, &#x27;k4&#x27;)) # 批量获取新值print(r.getset(&#x27;name&#x27;, &#x27;liaogaoxiang&#x27;)) # 设置新值并获取原来的值print(r.getrange(&#x27;name&#x27;, 0, 1)) # 获取子序列 0 &lt;= x &lt;= 1r.setrange(&#x27;name&#x27;, 0, &#x27;LIAO&#x27;) # 修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加），返回值的长度i = 0while i &lt; 4: print(r.get(&#x27;name&#x27;)) time.sleep(1) i += 1source = &#x27;foo&#x27;r.set(&#x27;n1&#x27;, source)r.setbit(&#x27;n1&#x27;, 7, 1)&#x27;&#x27;&#x27;注：如果在Redis中有一个对应： n1 = &quot;foo&quot;， 那么字符串foo的二进制表示为：01100110 01101111 01101111 所以，如果执行 setbit(&#x27;n1&#x27;, 7, 1)，则就会将第7位设置为1， 那么最终二进制则变成 01100111 01101111 01101111，即：&quot;goo&quot;&#x27;&#x27;&#x27;print(r.get(&#x27;n1&#x27;))print(r.getbit(&#x27;n1&#x27;, 7)) # 获取n1对应的值的二进制表示中的某位的值 （0或1）r.set(&#x27;n2&#x27;, &#x27;廖高祥&#x27;)print(r.strlen(&#x27;n2&#x27;)) # 返回对应的字节长度（一个汉字3个字节）r.set(&#x27;num&#x27;, 1)r.incr(&#x27;num&#x27;, amount=10)r.decr(&#x27;num&#x27;, amount=1)print(r.get(&#x27;num&#x27;)) # 自增num对应的值，当name不存在时，则创建name＝amount，否则，则自增。r.append(&#x27;num&#x27;, 111)print(r.get(&#x27;num&#x27;)) # 在redis num对应的值后面追加内容 redis列表list Python操作Redis主要利用了redis模块来实现，list表操作函数主要模拟了Redis操作命令LPUSH，LRANGE，LINDEX，BLPOP，BRPOP。函数说明如下： lpush函数实现了从向指定redis列表头部压入数据功能，lpush key value lrange获取列表指定范围的函数，lrange key start end lindex根据列表下标量获取列表元素值， lindex key index blpop从列表头部取出第一个元素，返回该元素值并从列表删除（l代表left，左边） brpop从列表尾部取出第一个元素，返回该元素值并从列表删除（l代表right，右边） LPUSHX、RPUSHX以及其他一些Redis列表（List）函数目前版本无法实现，如有可实现方法博客代码事例将会得到更新。 import redispool = redis.ConnectionPool(host=&#x27;127.0.0.1&#x27;, port=6379,decode_responses=True)r = redis.Redis(connection_pool=pool)r.flushall() # 清空Redisr.lpush(&#x27;oo&#x27;, 11) # 保存顺序为: 33,22,11r.lpushx(&#x27;oo&#x27;, 00) # 在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边print(r.llen(&#x27;oo&#x27;)) # name对应的list元素的个数r.linsert(&#x27;oo&#x27;, &#x27;before&#x27;, 11, 99) # 在11之前插入值99r.lset(&#x27;oo&#x27;, 1, 88) # 对name对应的list中的某一个索引位置重新赋值print(r.lrange(&#x27;oo&#x27;, 0, -1)) # 在name对应的列表分片获取数据r.lrem(&#x27;oo&#x27;, 88, num=1) # 在name对应的list中删除指定的值.num=0，删除列表中所有的指定值；num=2,从前到后，删除2个；num=-2,从后向前，删除2个print(r.lrange(&#x27;oo&#x27;, 0, -1))print(r.lpop(&#x27;oo&#x27;)) # 在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素print(r.lindex(&#x27;oo&#x27;, 0)) # 在name对应的列表中根据索引获取列表元素r.lpush(&#x27;l1&#x27;, 11) # index为0r.rpush(&#x27;l1&#x27;, 22)r.rpush(&#x27;l1&#x27;, 33)r.rpush(&#x27;l1&#x27;, 44)r.rpush(&#x27;l1&#x27;, 55) # index为4r.ltrim(&#x27;l1&#x27;, 1, 3) # 在name对应的列表中移除没有在[start-end]索引之间的值print(r.lrange(&#x27;l1&#x27;, 0, -1))r.rpoplpush(&#x27;l1&#x27;, &#x27;l1&#x27;) # 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边;src要取数据的列表的name, dst要添加数据的列表的nameprint(r.lrange(&#x27;l1&#x27;, 0, -1))r.brpoplpush(&#x27;l1&#x27;, &#x27;l1&#x27;, timeout=3) # # timeout，当src对应的列表中没有数据时，阻塞等待其有数据的超时时间（秒），0 表示永远阻塞print(r.lrange(&#x27;l1&#x27;, 0, -1))print(r.blpop(&#x27;l1&#x27;, 3)) # 从列表头部取出第一个元素，返回该元素值并从列表删除（l代表left，左边）print(r.lrange(&#x27;l1&#x27;, 0, -1))&#x27;&#x27;&#x27; # 由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要： # 1、获取name对应的所有列表 # 2、循环列表 # 但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能：&#x27;&#x27;&#x27;print(&#x27;自定义增量迭代：&#x27;)r.flushall()r.lpush(&#x27;l1&#x27;, 11) # index为0r.rpush(&#x27;l1&#x27;, 22)r.rpush(&#x27;l1&#x27;, 33)r.rpush(&#x27;l1&#x27;, 44)r.rpush(&#x27;l1&#x27;, 55) # index为4def list_iter(name): list_count = r.llen(name) for index in range(list_count): yield r.lindex(name, index)for item in list_iter(&#x27;l1&#x27;): print(item) redis集合sets Redis 数据库集合对象(set object)是由string类型的无重复元素的无需集合，底层编码可以是intset或者hashtable。intset编码的集合对象用整数集合最为底层实现，所有对象元素保存在整数集合中。Python的redis模块实现了 SADD、SCARD 、SDIFF 、SDIFFSTORE、SINTER 、SINTERSTORE、SISMEMBER 、SMEMBERS 、SMOVE、SPOP、SRANDMEMBER、SREM、SUNION、SUNIONSTORE操作命令的基本用法。函数说明如下： SADD：向集合对象添加成员，sadd(self, name, value) SCARD：获取集合元素个数，scard(self, name) SDIFF：返回给定多个集合对象的差集(set key1-set key2..-set keyn)，从左到右计算集合差集，sdiff(self, keys, *args) SDIFFSTORE：返回给定给定多个集合对象的差集并存储在目标（dest）集合中，sdiffstore(self, dest, keys, *args) SINTER：返回给定所有集合（keys, args）的交集, sinter(self, keys, args) SINTERSTORE：返回给定所有集合（keys, args）的交集并存储在 集合(dest) 中, sinterstore(self, dest, keys, args) SISMEMBER：判断 value元素是否是集合 name 的成员,返回布尔逻辑值True或者False，sismember(self, name, value) SMEMBERS：返回集合中所元素值的Python集合类型数据，smembers(self, name) SMOVE：将元素value从集合src移动到 集合 dest。若元素value在集合src中不存在，则集合dest中不会添加元素value， smove(self, src, dest, value) SPOP：移除并返回集合中的一个随机元素, spop(self, name) SRANDMEMBER：返回集合中一个随机数，但是不做移除操作, srandmember(self, name)。从Redis 2.6 版本开始， 在命令行下Srandmember 命令接受可选返回元素数量的参数 redis&gt;SRANDMEMBER name count SREM：移除集合中一个元素，srem(self, name, value)，redis模块任然沿用Redis 2.4 版本以前的只接受单个元素的用法。 SUNION：返回所有给定集合的并集中所有元素，sunion(self, keys, *args) SUNIONSTORE：所有给定集合的并集存储在集合dest 中, sunionstore(self, dest, keys, *args) SSCAN：迭代集合中的元素，sscan(self, name, cursor=0, match=None, count=None) import redispool = redis.ConnectionPool(host=&#x27;127.0.0.1&#x27;, port=6379)r = redis.Redis(connection_pool=pool)r.flushall() # 清空Redisr.sadd(&#x27;s1&#x27;, &#x27;v1&#x27;, &#x27;v1&#x27;, &#x27;v2&#x27;, &#x27;v3&#x27;) # name对应的集合中添加元素r.sadd(&#x27;s2&#x27;, &#x27;v2&#x27;, &#x27;v4&#x27;) # name对应的集合中添加元素print(r.scard(&#x27;s1&#x27;)) # 获取name对应的集合中元素个数print(r.sdiff(&#x27;s1&#x27;, &#x27;s2&#x27;)) #在第一个name对应的集合中且不在其他name对应的集合的元素集合r.sdiffstore(&#x27;s3&#x27;, &#x27;s1&#x27;, &#x27;s2&#x27;) # 获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中print(r.smembers(&#x27;s3&#x27;)) # 获取s3对应的集合的所有成员print(r.sinter(&#x27;s1&#x27;, &#x27;s2&#x27;)) # 获取s1, s2对应集合的交集r.sinterstore(&#x27;s4&#x27;, &#x27;s1&#x27;, &#x27;s2&#x27;) # 获取s1, s2对应集合的交集，并将其存放到集合是s4中print(r.smembers(&#x27;s4&#x27;))print(r.sunion(&#x27;s1&#x27;, &#x27;s2&#x27;)) # 获取s1, s2对应集合的并集r.sunionstore(&#x27;s5&#x27;, &#x27;s1&#x27;, &#x27;s2&#x27;) # 获取s1, s2对应集合的交集，并将其存放到集合是s5中print(r.smembers(&#x27;s5&#x27;))print(r.sismember(&#x27;s4&#x27;, &#x27;v4&#x27;)) # 检查value是否是name对应的集合的成员r.smove(&#x27;s2&#x27;, &#x27;s1&#x27;, &#x27;v4&#x27;) # 将集合s2中成员v4移至集合s1中print(r.smembers(&#x27;s1&#x27;))r.srem(&#x27;s1&#x27;, &#x27;v1&#x27;) # 在name对应的集合中删除某些值print(r.spop(&#x27;s1&#x27;)) # 从集合的右侧（尾部）移除一个成员，并将其返回 注意：集合是无序的，故结果随机！print(r.srandmember(&#x27;s1&#x27;)) # 从name对应的集合中随机获取 numbers 个元素(Redis 2.6+) 有序集合 sortrd sets Redis Zadd 命令 向有序集合添加一个或多个成员，或者更新已存在成员的分数 Redis Zcard 命令 获取有序集合的成员数 Redis Zcount 命令 计算在有序集合中指定区间分数的成员数 Redis Zincrby 命令 有序集合中对指定成员的分数加上增量 increment Redis Zinterstore 命令 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 Redis Zlexcount 命令 在有序集合中计算指定字典区间内成员数量 Redis Zrange 命令 通过索引区间返回有序集合成指定区间内的成员 Redis Zrangebylex 命令 通过字典区间返回有序集合的成员 Redis Zrangebyscore 命令 通过分数返回有序集合指定区间内的成员 Redis Zrank 命令 返回有序集合中指定成员的索引 Redis Zrem 命令 移除有序集合中的一个或多个成员 Redis Zremrangebylex 命令 移除有序集合中给定的字典区间的所有成员 Redis Zremrangebyrank 命令 移除有序集合中给定的排名区间的所有成员 Redis Zremrangebyscore 命令 移除有序集合中给定的分数区间的所有成员 Redis Zrevrange 命令 返回有序集中指定区间内的成员，通过索引，分数从高到底 Redis Zrevrangebyscore 命令 返回有序集中指定分数区间内的成员，分数从高到低排序 Redis Zrevrank 命令 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 Redis Zscore 命令 返回有序集中，成员的分数值 Redis Zunionstore 命令 计算给定的一个或多个有序集的并集，并存储在新的 key 中 Redis Zscan 命令 迭代有序集合中的元素（包括元素成员和元素分值） pool = redis.ConnectionPool(host=&#x27;127.0.0.1&#x27;, port=6379)r = redis.Redis(connection_pool=pool)r.flushall() # 清空Redisr.zadd(&#x27;z1&#x27;, &#x27;11&#x27;, 1, &#x27;22&#x27;, 2, &#x27;33&#x27;, 3, &#x27;44&#x27;, 4, &#x27;55&#x27;, 5, &#x27;66&#x27;, 6, &#x27;66&#x27;, 7) # 在name对应的有序集合中添加元素print(r.zcard(&#x27;z1&#x27;)) # 获取name对应的有序集合元素的数量print(r.zcount(&#x27;z1&#x27;, 1, 2)) # 获取name对应的有序集合中分数 在 [min,max] 之间的个数r.zincrby(&#x27;z1&#x27;, &#x27;11&#x27;, amount=5) # 自增name对应的有序集合的 name 对应的分数print(r.zrange(&#x27;z1&#x27;, 0, -1, desc=False, withscores=True)) # 值11被排序到最后;此处表示按元素的值升序排列print(r.zrank(&#x27;z1&#x27;, 33)) # 获取某个值在 name对应的有序集合中的排行（从 0 开始）r.zrem(&#x27;z1&#x27;, &#x27;66&#x27;) # 删除name对应的有序集合中值是values的成员print(r.zrange(&#x27;z1&#x27;, 0, -1, desc=False, withscores=True))r.zremrangebyrank(&#x27;z1&#x27;, 0, 1) # 根据排行范围删除print(r.zrange(&#x27;z1&#x27;, 0, -1, desc=False, withscores=True))r.zremrangebyscore(&#x27;z1&#x27;, 4.5, 5.5) # 根据分数范围删除print(r.zrange(&#x27;z1&#x27;, 0, -1, desc=False, withscores=True))print(r.zscore(&#x27;z1&#x27;, 11)) # 获取name对应有序集合中 value 对应的分数r.zadd(&quot;zset_name&quot;, &quot;a1&quot;, 6, &quot;a2&quot;, 2, &quot;a3&quot;, 5)r.zadd(&#x27;zset_name1&#x27;, a1=7, b1=10, b2=5)&#x27;&#x27;&#x27; 获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作 aggregate的值为: SUM MIN MAX&#x27;&#x27;&#x27;r.zinterstore(&#x27;zset_name2&#x27;, (&#x27;zset_name&#x27;, &#x27;zset_name1&#x27;), aggregate=&#x27;Sum&#x27;)print(r.zrange(&#x27;zset_name2&#x27;, 0, -1, desc=False, withscores=True)) redis 哈希 hashes Redis 数据库hash数据类型是一个string类型的key和value的映射表，适用于存储对象。redis 中每个hash可以存储键值对多达40亿。Python的redis模块实现了Redis哈希（Hash）命令行操作的几乎全部命令，包括HDEL、HEXISTS、HGET、HGETALL、HINCRBY、HKEYS、HLEN 、HMGET 、HMSET 、HSET 、HSETNX 、HVALS 、HINCRBYFLOAT等命令。函数说明如下： HDEL：删除对应哈希（Hash）表的指定键（key）的字段，hdel(self, name, key) HEXISTS：检测哈希（Hash）表对应键（key）字段是否存在，返回布尔逻辑，hexists(self, name, key) HGET：获取哈希（Hash）指定键（key）对应的值，hget(self, name, key) HGETALL：获取哈希(Hash)表的键-值对（key-value pairs）,返回python字典类型数据，hgetall(self, name) HINCRBY：为哈希表（Hash）指定键（key）对应的值（key）加上指定的整数数值（int，可为负值）hincrby(self&gt;, name, key, amount=1)，Redis 中本操作的值被限制在 64 位(bit)有符号数字。 HKEYS：返回哈希表（Hash）对应键（key）的数组（Python称之为列表List），hkeys(self, name) HLEN： 获取哈希表（Hash）中键-值对（key-value pairs）个数，hlen(self, name) HMGET：获取哈希表（Hash）中一个或多个给点字段的值，不存在返回nil(Redis命令行)/None(Python)，hmget(self, name, keys)，其中keys可以为列表（list） HMSET：设置对个键-值对（key-value pairs）到哈希表（Hash）中，python输入值（mapping）为字典（dictionary）类型，hmset(self, name, mapping) HSET：为哈希表（Hash）赋值，若键（key）存在值（value）则覆盖，不存在则创建，hset(self, name, key, value) HSETNX：为哈希表（Hash）不存值（value）的键（key）赋值，存在操作无效，对应值（value）无变化，hsetnx(self, name, key, value) HVALS：返回哈希表（Hash）对应值（value）的列表，hvals(self, name) HINCRBYFLOAT：为哈希表 key 中的指定字段的浮点数值加上增量 increment ，hincrbyfloat(self, name, key, amount=1.0) pool = redis.ConnectionPool(host=&#x27;127.0.0.1&#x27;, port=6379)r = redis.Redis(connection_pool=pool)r.flushall() # 清空Redisr.hset(&#x27;n1&#x27;, &#x27;k1&#x27;, &#x27;v1&#x27;) # hset(name, key, value),name对应的hash中设置一个键值对（不存在，则创建；否则，修改）print(r.hget(&#x27;n1&#x27;, &#x27;k1&#x27;))r.hmset(&#x27;n2&#x27;, &#123;&#x27;k1&#x27;: &#x27;v1&#x27;, &#x27;k2&#x27;: &#x27;v2&#x27;, &#x27;k3&#x27;: &#x27;v3&#x27;&#125;) # hmset(name, mapping),在name对应的hash中批量设置键值对print(r.hmget(&#x27;n2&#x27;, &#x27;k2&#x27;))print(r.hgetall(&#x27;n2&#x27;)) # 获取name对应hash的所有键值print(r.hlen(&#x27;n2&#x27;)) # 获取name对应的hash中键值对的个数print(r.hkeys(&#x27;n2&#x27;)) # 获取name对应的hash中所有的key的值print(r.hvals(&#x27;n2&#x27;)) # 获取name对应的hash中所有的value的值print(r.hexists(&#x27;n2&#x27;, &#x27;k4&#x27;)) # 检查name对应的hash是否存在当前传入的keyr.hdel(&#x27;n2&#x27;, &#x27;k3&#x27;) # 将name对应的hash中指定key的键值对删除r.hset(&#x27;n3&#x27;, &#x27;k1&#x27;, 1)r.hincrby(&#x27;n3&#x27;, &#x27;k1&#x27;, amount=1) # hincrby(name, key, amount=1),自增name对应的hash中的指定key的value的值，不存在则创建key=amountprint(r.hgetall(&#x27;n3&#x27;))","categories":[{"name":"数据库","slug":"数据库","permalink":"https://dongzhu.ink/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Python","slug":"python","permalink":"https://dongzhu.ink/tags/python/"},{"name":"Redis","slug":"redis","permalink":"https://dongzhu.ink/tags/redis/"}],"author":"M."},{"title":"Mysql数据库的配置安装","slug":"数据库/Mysql数据库的安装","date":"2019-04-26T11:11:00.000Z","updated":"2020-08-08T01:40:54.918Z","comments":true,"path":"archives/27a7b644.html","link":"","permalink":"https://dongzhu.ink/archives/27a7b644.html","excerpt":"在安装mysql和使用，中出现的一些的问题，自己找到并实际解决的方法做一下记录 MySQL数据库安装–windows下安装，下一步 或者下载 直接下载 phpstudy_pro 管理工具，带redis库 –liunx下安装–## 网上资料 yum install mysqlyum install mysql-serveryum install mysql-devel### 在安装mysql-server是出现报错 &quot;&quot;&quot;Loaded plugins: fastestmirrorLoading mirror speeds from cached hostfile * base: mirrors.sina.cn * extras: mirrors.sina.cn * updates: mirrors.sina.cnNo package mysql-server available.Error: Nothing to do&quot;&quot;&quot;方法一 安装 yum install mariadb-server mariadb &quot;&quot;&quot;mariadb数据库的相关命令是：systemctl start mariadb #启动MariaDBsystemctl stop mariadb #停止MariaDBsystemctl restart mariadb #重启MariaDBsystemctl enable mariadb #设置开机启动所以先启动数据库&quot;&quot;&quot;## 启动数据库，进入后感觉怪怪 的 mysql -u root -p放法二 官网下载mysql-server ## 下载地址 https://dev.mysql.com/downloads/repo/yum/ 找到适合版本的liunxrpm -ivh（安装软件包并显示安装进度） 版本 .rpnyum -y install mysql-community-server&quot;&quot;&quot;service mysqld start (5.0版本是mysqld) 启动service mysql start (5.5.7版本是mysql)----停止----service mysqld stop----重启----service mysqld restart service mysql restart (5.5.7版本命令)----查看MySQL运行状态--systemctl status mysqld.service2、使用 mysqld 脚本启动：/etc/inint.d/mysqld stop&quot;&quot;&quot;------------------初始登入-------&gt;## 如果首次登入不上，需要查看一下零时密码## 查看临时密码 grep &quot;password&quot; /var/log/mysqld.log &quot;&quot;&quot;使用临死密码登入， 成功后ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Root_12root&#x27;;只能先修改密码 不能进行任何操作，设置密码也有规范不能太简单先修改一个符合条件的密码 Root_12root查看密码设置条件 SHOW VARIABLES LIKE &#x27;validate_password%&#x27;;通过设置 set global validate_password.policy=0;set global validate_password.length=1;这样就可以修改简单密码了，在重置一下密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;mysql&#x27;;&quot;&quot;&quot;----------------注-----如果使用方法二去覆盖方法一的安装， 此时会出现MySQL 服务器开不起来的解决方法出现错误 Failed to start MySQL Server&quot;&quot;&quot;查看 cat /etc/my.cnfdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock删除-- rm -rf /var/lib/mysql/*在启动mysql服务器， 安装方法二的操作&quot;&quot;&quot;","text":"在安装mysql和使用，中出现的一些的问题，自己找到并实际解决的方法做一下记录 MySQL数据库安装–windows下安装，下一步 或者下载 直接下载 phpstudy_pro 管理工具，带redis库 –liunx下安装–## 网上资料 yum install mysqlyum install mysql-serveryum install mysql-devel### 在安装mysql-server是出现报错 &quot;&quot;&quot;Loaded plugins: fastestmirrorLoading mirror speeds from cached hostfile * base: mirrors.sina.cn * extras: mirrors.sina.cn * updates: mirrors.sina.cnNo package mysql-server available.Error: Nothing to do&quot;&quot;&quot;方法一 安装 yum install mariadb-server mariadb &quot;&quot;&quot;mariadb数据库的相关命令是：systemctl start mariadb #启动MariaDBsystemctl stop mariadb #停止MariaDBsystemctl restart mariadb #重启MariaDBsystemctl enable mariadb #设置开机启动所以先启动数据库&quot;&quot;&quot;## 启动数据库，进入后感觉怪怪 的 mysql -u root -p放法二 官网下载mysql-server ## 下载地址 https://dev.mysql.com/downloads/repo/yum/ 找到适合版本的liunxrpm -ivh（安装软件包并显示安装进度） 版本 .rpnyum -y install mysql-community-server&quot;&quot;&quot;service mysqld start (5.0版本是mysqld) 启动service mysql start (5.5.7版本是mysql)----停止----service mysqld stop----重启----service mysqld restart service mysql restart (5.5.7版本命令)----查看MySQL运行状态--systemctl status mysqld.service2、使用 mysqld 脚本启动：/etc/inint.d/mysqld stop&quot;&quot;&quot;------------------初始登入-------&gt;## 如果首次登入不上，需要查看一下零时密码## 查看临时密码 grep &quot;password&quot; /var/log/mysqld.log &quot;&quot;&quot;使用临死密码登入， 成功后ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Root_12root&#x27;;只能先修改密码 不能进行任何操作，设置密码也有规范不能太简单先修改一个符合条件的密码 Root_12root查看密码设置条件 SHOW VARIABLES LIKE &#x27;validate_password%&#x27;;通过设置 set global validate_password.policy=0;set global validate_password.length=1;这样就可以修改简单密码了，在重置一下密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;mysql&#x27;;&quot;&quot;&quot;----------------注-----如果使用方法二去覆盖方法一的安装， 此时会出现MySQL 服务器开不起来的解决方法出现错误 Failed to start MySQL Server&quot;&quot;&quot;查看 cat /etc/my.cnfdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock删除-- rm -rf /var/lib/mysql/*在启动mysql服务器， 安装方法二的操作&quot;&quot;&quot; 解决Navicat 连接MySQL 8.0.11 出现2059错误mysql -uroot -ppassword #登录use mysql; #选择数据库## ---&gt; select user,plugin from user where user=&#x27;root&#x27;; 查看加密方式ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27; PASSWORD EXPIRE NEVER; #更改加密方式ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;; #更新用户密码FLUSH PRIVILEGES; #刷新权限-----------注-------------&quot;&quot;&quot;修改时出现 ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 错误需要修改数据库的策略查看mysql 初始的密码策略 SHOW VARIABLES LIKE &#x27;validate_password%&#x27;;需要设置密码的验证强度等级，设置 validate_password_policy 的全局参数为 LOW 即可set global validate_password.policy=LOW;当前密码长度为 8 ，如果不介意的话就不用修改了 set global validate_password.length=6; update user set password=(&#x27;123.com&#x27;) where user=&#x27;root&#x27;;关于 mysql 密码策略相关参数；1）、validate_password_length 固定密码的总长度；2）、validate_password_dictionary_file 指定密码验证的文件路径；3）、validate_password_mixed_case_count 整个密码中至少要包含大/小写字母的总个数；4）、validate_password_number_count 整个密码中至少要包含阿拉伯数字的个数；5）、validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM；关于 validate_password_policy 的取值：0/LOW：只验证长度；1/MEDIUM：验证长度、数字、大小写、特殊字符；2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；6）、validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；--------------------- &quot;&quot;&quot;-------------（liunx）如果mysql登入密码忘记，--------------------首先 vim /etc/my.cnf 在[mysql] 下面增加一行 skip-grant-tables重启mysql重新登入不用输入密码更具网上的重置更新密码的语法 update user set authentication_string=password(&#x27;123.com&#x27;) where user=&#x27;root&#x27;; 如果报语法错误就使用下面一条，密码已经是加密过的 为mysql （先查看一样，密码的加密方式是否是 mysql_native_password）是的就是可行的，update mysql.user set authentication_string=&#x27;*E74858DB86EBA20BC33D0AECAE8A8108C56B17FA where user&#x27;=&#x27;root&#x27;;-----查看密码---select host,user,authentication_string from user;------------更改mysql远程连接---------------方式一 直接修改修改 update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;; ------查看修改后的状态---select host, user from user;","categories":[{"name":"工具","slug":"工具","permalink":"https://dongzhu.ink/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"MySql","slug":"mysql","permalink":"https://dongzhu.ink/tags/mysql/"}],"author":"M."},{"title":"模拟器安装","slug":"工具/模拟器安装","date":"2019-04-15T12:54:00.000Z","updated":"2020-08-08T01:40:54.941Z","comments":true,"path":"archives/1b78260c.html","link":"","permalink":"https://dongzhu.ink/archives/1b78260c.html","excerpt":"安卓模拟器环境搭建 开发者有时候会用到模拟器来完成一些工作… 安卓安卓模拟器需要安卓java的环境，直接下载Android SDK 安装时会给我们一个java的下载地址 然后下载java包，再安装java，安装后没有jre这个模块， 再安装的jdk目录下的输入 bin\\jlink.exe --module-path jmods --add-modules java.desktop --output jre 后就会出现了 配置java, 直接点， 系统变量中， 创建 变量名： JAVA_HOME 变量值： D:\\Program Files\\Java\\jdk, 再系统变量path中，添加，/jdk/bin，jre/bin 目录路径 配置好java环境后，再 从新点击刚刚下载的 Android SDK 进行安装， 安装完成后，再在系统变量中配置一下环境，G:\\Android\\android-sdk\\toolsG:\\Android\\android-sdk\\platform-tools","text":"安卓模拟器环境搭建 开发者有时候会用到模拟器来完成一些工作… 安卓安卓模拟器需要安卓java的环境，直接下载Android SDK 安装时会给我们一个java的下载地址 然后下载java包，再安装java，安装后没有jre这个模块， 再安装的jdk目录下的输入 bin\\jlink.exe --module-path jmods --add-modules java.desktop --output jre 后就会出现了 配置java, 直接点， 系统变量中， 创建 变量名： JAVA_HOME 变量值： D:\\Program Files\\Java\\jdk, 再系统变量path中，添加，/jdk/bin，jre/bin 目录路径 配置好java环境后，再 从新点击刚刚下载的 Android SDK 进行安装， 安装完成后，再在系统变量中配置一下环境，G:\\Android\\android-sdk\\toolsG:\\Android\\android-sdk\\platform-tools Hbuilde使用夜神模拟器时 将 hBuilde的手机端口改成 62001adb connect 127.0.0.1:62001adb devices","categories":[{"name":"工具","slug":"工具","permalink":"https://dongzhu.ink/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"介绍","slug":"介绍","permalink":"https://dongzhu.ink/tags/%E4%BB%8B%E7%BB%8D/"}],"author":"M."},{"title":"Mysql常用命令","slug":"数据库/Mysql常用命令","date":"2019-04-13T16:46:00.000Z","updated":"2020-08-08T01:40:54.971Z","comments":true,"path":"archives/64129a24.html","link":"","permalink":"https://dongzhu.ink/archives/64129a24.html","excerpt":"MySql 常用命令的基本使用篇章初始操作-- 查看所有数据库 show databases;-- 选择数据库use db;-- 查看到但钱使用的数据库select database();-- 创建数据库create database dbname charset=utf8;-- 查看当前数据库中所有的表show tables;-- 查看表结构desc 表名;-- sql格式数据导入数据insert into 表名 values (数据)-- 创建数据表-- 创建班级表 -----create table classes ( id int unsigned auto_increment primary key not null, name varchar(30) not null);-- students表create table students( id int unsigned primary key auto_increment not null, name varchar(20) default &#x27;&#x27;, age tinyint unsigned default 0, height decimal(5,2), gender enum(&#x27;男&#x27;,&#x27;女&#x27;,&#x27;中性&#x27;,&#x27;保密&#x27;) default &#x27;保密&#x27;, cls_id int unsigned default 0, is_delete bit default 0);","text":"MySql 常用命令的基本使用篇章初始操作-- 查看所有数据库 show databases;-- 选择数据库use db;-- 查看到但钱使用的数据库select database();-- 创建数据库create database dbname charset=utf8;-- 查看当前数据库中所有的表show tables;-- 查看表结构desc 表名;-- sql格式数据导入数据insert into 表名 values (数据)-- 创建数据表-- 创建班级表 -----create table classes ( id int unsigned auto_increment primary key not null, name varchar(30) not null);-- students表create table students( id int unsigned primary key auto_increment not null, name varchar(20) default &#x27;&#x27;, age tinyint unsigned default 0, height decimal(5,2), gender enum(&#x27;男&#x27;,&#x27;女&#x27;,&#x27;中性&#x27;,&#x27;保密&#x27;) default &#x27;保密&#x27;, cls_id int unsigned default 0, is_delete bit default 0); 查-- 基础查询-----查询表格所以字段&gt;&gt; select * from 表名;-- 指定字段查询&gt;&gt; select 字1,字2,.. from 表名;-- 对于表名 跟字段名长的可以通过 as 别名&gt;&gt; select id as 标号, name as 名字, gender as 性别 from students;-- 跟表名起别名&gt;&gt; select s.id,s.name,s.gender from students as s;-- 在select后面列前使用distinct可以消除重复的行&gt;&gt; select distinct 列1,... from 表名; 例： &gt;&gt; select distinct gender from students; 条件查询 -- 使用where子句对表中的数据筛选，结果为true的行会出现在结果集中&gt;&gt; select * from 表名 where 条件; 例： &gt;&gt; select * from students where id=1;----where后面支持多重运算符，进行比较 &gt;&gt; 比较运算符 | 逻辑运算符| 模糊查询| 范围查询 | 空判断---比较运行符 -- 等于: = | 大于: &gt; |大于等于: &gt;= |小于: &lt; | 小于等于: &lt;= | 不等于: != 或 &lt;&gt;&gt;&gt; 例如： -- 例1：查询编号大于3的学生 &gt;&gt; select * from students where id &gt; 3; --例2：查询编号不大于4的学生 &gt;&gt; select * from students where id &lt;= 4; --例3：查询姓名不是“黄蓉”的学生 &gt;&gt; select * from students where name != &#x27;黄蓉&#x27;; --例4：查询没被删除的学生 &gt;&gt; select * from students where is_delete=0;--- 逻辑运算符、 &gt;&gt; and | or | not&gt;&gt; 例如： --例5：查询编号大于3的女同学 &gt;&gt; select * from students where id &gt; 3 and gender=0; --例6：查询编号小于4或没被删除的学生 &gt;&gt; select * from students where id &lt; 4 or is_delete=0;-- 模糊查询 like | %表示任意多个任意字符 | _表示一个任意字符&gt;&gt; 例如： --例7：查询姓黄的学生 select * from students where name like &#x27;黄%&#x27;; --例8：查询姓黄并且名字是一个字的学生 select * from students where name like &#x27;黄_&#x27;; --例9：查询姓黄或叫靖的学生 select * from students where name like &#x27;黄%&#x27; or name like &#x27;%靖&#x27;;-- 范围查询 in 表示在一个非连续的范围内 | between ... and ...表示在一个连续的范围内&gt;&gt; 例如： --例10：查询编号是1或3或8的学生 select * from students where id in(1,3,8); --例11：查询编号为3至8的学生 select * from students where id between 3 and 8; --例12：查询学生是3至8的男生 select * from students where id between 3 and 8 and gender=1;-- 空判断 判空 is null | 判非空is not null&gt;&gt; 例如： --例13：查询没有填写身高的学生 select * from students where height is null; --例14：查询填写了身高的学生 select * from students where height is not null; --例15：查询填写了身高的男生 select * from students where height is not null and gender=1;-- 优先级 --优先级由高到低的顺序为：小括号，not，比较运算符，逻辑运算符 --and比or先运算，如果同时出现并希望先算or，需要结合()使用 增删&gt;&gt; delete from 表名 where 条件如：&gt;&gt; delete from students where id=5;--逻辑删除，本质就是修改操作,表中有逻辑删除的字段is_delete&gt;&gt; update students set is_delete=1 where id=1; 改备份--- 在未登入mysql下进行mysqldump -uroot -p 库名 &gt; python.sql; -- 提示输入mysql密码， 在-- 导入备份数据-- 库名mysql -uroot -p 库名 &lt; python.sql","categories":[{"name":"数据库","slug":"数据库","permalink":"https://dongzhu.ink/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySql","slug":"mysql","permalink":"https://dongzhu.ink/tags/mysql/"}],"author":"M."},{"title":"hexo博客主题","slug":"网站建设/hexo快速搭建博客","date":"2018-09-07T01:25:00.000Z","updated":"2020-08-08T02:45:27.802Z","comments":true,"path":"archives/21ba1a18.html","link":"","permalink":"https://dongzhu.ink/archives/21ba1a18.html","excerpt":"快的构建博客首先准备工作： 安装node.js, 安装git, 配置好node.js 后安装hexo环境 scriptnpm install hexonpm install -g hexo-cli 开始创建blog： 创建一个空的文件夹， 再使用命令， wind使用管理权限打开cmd，或者使用git 使用 scripthexo init blogcd blognpm install 运行博客,再blog根目录下 scripthexo s 运行成功后，初始的博客就搭建完成了，再部署github上面,先需要再GitHub上面创建一个仓库， # 先再然后再blog根目录下配置deploy: type: git repo: git@github.com:YouAge/youage.github.com.git # git ssh地址# 再执行下列命令，编译，提交hexo ghexo d# 或者 hexo clean &amp;&amp; hexo deploy","text":"快的构建博客首先准备工作： 安装node.js, 安装git, 配置好node.js 后安装hexo环境 scriptnpm install hexonpm install -g hexo-cli 开始创建blog： 创建一个空的文件夹， 再使用命令， wind使用管理权限打开cmd，或者使用git 使用 scripthexo init blogcd blognpm install 运行博客,再blog根目录下 scripthexo s 运行成功后，初始的博客就搭建完成了，再部署github上面,先需要再GitHub上面创建一个仓库， # 先再然后再blog根目录下配置deploy: type: git repo: git@github.com:YouAge/youage.github.com.git # git ssh地址# 再执行下列命令，编译，提交hexo ghexo d# 或者 hexo clean &amp;&amp; hexo deploy 下列hexo主题参考使用 next主题 next第三方插件 next深度优化定制 本站主题-matery butterfly主题 豆瓣插件的使用 根目录下安装 npm install hexo-douban --save 再根目录下配置_config.xml 文件 插件地址 douban: user: # 你的豆瓣ID，个人中心 url中的 people/xxxx builtin: false # true book: title: &#x27;书香满园&#x27; # 页面标题 quote: &#x27;学如逆水行舟，不进则退&#x27; # 写在页面前面的化 movie: title: &#x27;影视基地&#x27; quote: &#x27;一场电影，一部人生&#x27; timeout: 20000 # 请求超时 启动命令:hexo clean &amp;&amp; hexo douban -bgm &amp;&amp; hexo g &amp;&amp; hexo s 注意其中开启hexo-douban的命令中，-bgm代表的是book、game、movie三个参数，如果只需要其中的一部分就只带你想要的那些参数 关于Markdown 的使用和好的编译器前期可以使用 IDEA的工具来编写文章，相对很方便， PyCharm WebStorm 在设置中添加创建初始模板， 相关语法可用的预定义文件模板变量为：$ &#123;PROJECT_NAME&#125; - 当前项目的名称。$ &#123;NAME&#125; - 在文件创建过程中在“新建文件”对话框中指定的新文件的名称。$ &#123;USER&#125; - 当前用户的登录名。$ &#123;DATE&#125; - 当前的系统日期。$ &#123;TIME&#125; - 当前系统时间。$ &#123;YEAR&#125; - 今年。$ &#123;MONTH&#125; - 当月。$ &#123;DAY&#125; - 当月的当天。$ &#123;HOUR&#125; - 目前的小时。$ &#123;MINUTE&#125; - 当前分钟。$ &#123;PRODUCT_NAME&#125; - 将在其中创建文件的IDE的名称。$ &#123;MONTH_NAME_SHORT&#125; - 月份名称的前3个字母。 示例：1月，2月等$ &#123;MONTH_NAME_FULL&#125; - 一个月的全名。 示例：1月，2月等 Markdown语法记入点常用的 字体设置*加粗**这是倾斜的文字*`***这是斜体加粗***~~这是加删除线的文字~~ 这是效果 这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 引用&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 这是引用的内容 这是引用的内容 这是引用的内容 分割线-------******** 图片![插入图片](/images/17.jpg &quot;图片title&quot;) 链接[超链接名](超链接地址 &quot;超链接title&quot;)- 超链接title 可以不写- 或者使用html &lt;a&gt;标签&lt;a href=&quot;https://www.dongzhu.ink/&quot; target=&quot;本站&quot;&gt;本站&lt;/a&gt;&lt;http://baidu.com&gt; 小站百度 http://baidu.com本站 视频添加 使用html的H5标签即可，&lt;video src=&quot;视频地址&quot; width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; 列表无需列表- 列表内容+ 列表内存* 列表内存有序列表1. 列表内容2. 列表内容3. 列表内容...- + * 1. 2. 3. 跟内容之间都要有一个空格#### 列表嵌套 在上一个和下一个敲一个 tab 键 表格表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 栏目一 栏目二 栏目三 1 1 1 2 2 2 3 3 3","categories":[{"name":"网站建设","slug":"网站建设","permalink":"https://dongzhu.ink/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"},{"name":"hexo","slug":"网站建设/hexo","permalink":"https://dongzhu.ink/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/hexo/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://dongzhu.ink/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"M."}],"categories":[{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Typescript","slug":"前端/typescript","permalink":"https://dongzhu.ink/categories/%E5%89%8D%E7%AB%AF/typescript/"},{"name":"数据库","slug":"数据库","permalink":"https://dongzhu.ink/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PostgreSql","slug":"数据库/postgresql","permalink":"https://dongzhu.ink/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/postgresql/"},{"name":"后端","slug":"后端","permalink":"https://dongzhu.ink/categories/%E5%90%8E%E7%AB%AF/"},{"name":"node","slug":"后端/node","permalink":"https://dongzhu.ink/categories/%E5%90%8E%E7%AB%AF/node/"},{"name":"工具","slug":"工具","permalink":"https://dongzhu.ink/categories/%E5%B7%A5%E5%85%B7/"},{"name":"网站建设","slug":"网站建设","permalink":"https://dongzhu.ink/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"},{"name":"hexo","slug":"网站建设/hexo","permalink":"https://dongzhu.ink/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/hexo/"}],"tags":[{"name":"TypeScript","slug":"typescript","permalink":"https://dongzhu.ink/tags/typescript/"},{"name":"环境配置","slug":"环境配置","permalink":"https://dongzhu.ink/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"PostgreSql","slug":"postgresql","permalink":"https://dongzhu.ink/tags/postgresql/"},{"name":"node.js","slug":"node-js","permalink":"https://dongzhu.ink/tags/node-js/"},{"name":"koa.js","slug":"koa-js","permalink":"https://dongzhu.ink/tags/koa-js/"},{"name":"javaScript","slug":"javascript","permalink":"https://dongzhu.ink/tags/javascript/"},{"name":"css","slug":"css","permalink":"https://dongzhu.ink/tags/css/"},{"name":"webpack","slug":"webpack","permalink":"https://dongzhu.ink/tags/webpack/"},{"name":"npm","slug":"npm","permalink":"https://dongzhu.ink/tags/npm/"},{"name":"收藏","slug":"收藏","permalink":"https://dongzhu.ink/tags/%E6%94%B6%E8%97%8F/"},{"name":"vue","slug":"vue","permalink":"https://dongzhu.ink/tags/vue/"},{"name":"html","slug":"html","permalink":"https://dongzhu.ink/tags/html/"},{"name":"React","slug":"react","permalink":"https://dongzhu.ink/tags/react/"},{"name":"Python","slug":"python","permalink":"https://dongzhu.ink/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://dongzhu.ink/tags/%E7%88%AC%E8%99%AB/"},{"name":"博客","slug":"博客","permalink":"https://dongzhu.ink/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Linux","slug":"linux","permalink":"https://dongzhu.ink/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://dongzhu.ink/tags/shell/"},{"name":"介绍","slug":"介绍","permalink":"https://dongzhu.ink/tags/%E4%BB%8B%E7%BB%8D/"},{"name":"前端","slug":"前端","permalink":"https://dongzhu.ink/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Redis","slug":"redis","permalink":"https://dongzhu.ink/tags/redis/"},{"name":"MySql","slug":"mysql","permalink":"https://dongzhu.ink/tags/mysql/"}]}