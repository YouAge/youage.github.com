<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TypeScript学习(1)-环境搭建</title>
      <link href="/archives/50a9dd25.html"/>
      <url>/archives/50a9dd25.html</url>
      
        <content type="html"><![CDATA[<h2 id="TypeScript环境安装"><a href="#TypeScript环境安装" class="headerlink" title="TypeScript环境安装"></a>TypeScript环境安装</h2><h3 id="1-全局安装包"><a href="#1-全局安装包" class="headerlink" title="1.全局安装包"></a>1.全局安装包</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install typescript tslint ts-node  -g</span><br></pre></td></tr></table></figure><h3 id="2-项目环境包安装"><a href="#2-项目环境包安装" class="headerlink" title="2. 项目环境包安装"></a>2. 项目环境包安装</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install typescript ts-loader -s   #ts编译</span><br><span class="line">npm install clean-webpack-plugin cross-env html-webpack-plugin  webpack webpack-cli webpack-dev-server -s</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="3-项目架构创建"><a href="#3-项目架构创建" class="headerlink" title="3. 项目架构创建"></a>3. 项目架构创建</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">mkdir client-type</span><br><span class="line">cd client-type</span><br><span class="line"></span><br><span class="line">npm init -y # 直接初始化生成项目（注意刚刚创建项目名的名字（最好全小写），否者初始化出错）</span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功后 就会出现  package.json</span></span><br><span class="line">tsc --init # 生成ts配置文件</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;client-side&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;source code of ts-learning&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;./src/index.ts&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development webpack-dev-server --config ./build/webpack.config.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=production webpack --config ./build/webpack.config.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;typescript&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;cheo&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;clean-webpack-plugin&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cross-env&quot;</span>: <span class="string">&quot;^7.0.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^4.3.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ts-loader&quot;</span>: <span class="string">&quot;^8.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;typescript&quot;</span>: <span class="string">&quot;^3.9.7&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;^4.43.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^3.3.12&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^3.11.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client-type</span><br><span class="line">    -build</span><br><span class="line">        - webpack.config.js</span><br><span class="line">    -src</span><br><span class="line">        - api    &#x2F;*项目接口*&#x2F;</span><br><span class="line">        - assets  &#x2F;*项目静态资源存放*&#x2F;</span><br><span class="line">        - config  &#x2F;*项目的配置文件*&#x2F;</span><br><span class="line">        - components &#x2F;*项目组件*&#x2F;</span><br><span class="line">        - example  &#x2F;*学习ts代码的编写存放*&#x2F; </span><br><span class="line">        - router  &#x2F;*项目路由*&#x2F;</span><br><span class="line">        - views  &#x2F;*项目视图*&#x2F;</span><br><span class="line">        - template</span><br><span class="line">            -index.html &#x2F;*静态模板*&#x2F;</span><br><span class="line">        - tools     &#x2F;*项目工具*&#x2F;</span><br><span class="line">        - utils  &#x2F;*项目公共方法*&#x2F;</span><br><span class="line">    - index.ts  &#x2F;*入口文件*&#x2F; </span><br><span class="line">    - typings</span><br><span class="line">    - package.json </span><br><span class="line">    - tsconfig.json  &#x2F;*ts配置文件 tsc --init*&#x2F;</span><br><span class="line">    - tslint.json</span><br><span class="line">    - package-lock.json</span><br></pre></td></tr></table></figure><h3 id="webpack-config-js配置设置"><a href="#webpack-config-js配置设置" class="headerlink" title="webpack.config.js配置设置"></a>webpack.config.js配置设置</h3><h4 id="1-入口文件配置-编译后生成名"><a href="#1-入口文件配置-编译后生成名" class="headerlink" title="1.入口文件配置,编译后生成名"></a>1.入口文件配置,编译后生成名</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    entry:<span class="string">&#x27;./src/index.ts&#x27;</span>,</span><br><span class="line">    output:&#123;</span><br><span class="line">            filename:<span class="string">&quot;main.js&quot;</span> <span class="comment">// 指定，输出文件名称</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-文件导包的后缀省略"><a href="#2-文件导包的后缀省略" class="headerlink" title="2. 文件导包的后缀省略"></a>2. 文件导包的后缀省略</h4><blockquote><p>这样 再导入文件时，只要是这样的文件，后缀都可以省略<br><code>import  &#39;./example/interface_.ts&#39;</code> =&gt; <code>import  &#39;./example/interface_&#39;</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    resolve:&#123;</span><br><span class="line">        extensions:[<span class="string">&#x27;.ts&#x27;</span>,<span class="string">&#x27;.tsx&#x27;</span>,<span class="string">&#x27;.js&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-module-文件编译处理"><a href="#3-module-文件编译处理" class="headerlink" title="3. module 文件编译处理"></a>3. module 文件编译处理</h4><blockquote><p>编译时， 针对不通的文件换换编译成浏览器能识别的，<br>对ts文件的转换<br>需要下载相应的扩展包</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:<span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">            use:<span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动配置"><a href="#启动配置" class="headerlink" title="启动配置"></a>启动配置</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>  &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    devtool:process.env.NODE_ENV ===<span class="string">&#x27;production&#x27;</span>? <span class="literal">false</span>:  <span class="string">&#x27;inline-source-map&#x27;</span>,</span><br><span class="line">    <span class="comment">// 启动端口设置， 代理配置</span></span><br><span class="line">    devServer:&#123;</span><br><span class="line">        contentBase:<span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">        stats:<span class="string">&#x27;errors-only&#x27;</span>,</span><br><span class="line">        compress:<span class="literal">false</span>,</span><br><span class="line">        host:<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">        port:<span class="number">8088</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 一些插件配置</span></span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin() ,<span class="comment">// new 一个热更新的模块</span></span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">// 注意更新后的使用方式，</span></span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            template:<span class="string">&#x27;./src/template/index.html&#x27;</span> ,</span><br><span class="line">            filename: <span class="string">&#x27;index.html&#x27;</span> <span class="comment">// 指定生成页面的名称</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一行代码"><a href="#第一行代码" class="headerlink" title="第一行代码"></a>第一行代码</h3><blockquote><p>配置完成后， 开始写代码吧</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 再example 目录下 创建一个文件， 写入代码</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts 导入该文件 ，运行</span></span><br><span class="line"><span class="keyword">import</span> ./example/xxx</span><br></pre></td></tr></table></figure><p><strong>个人学习的一些资料， 文档,视频分享</strong></p><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postgresql查询</title>
      <link href="/archives/bee85523.html"/>
      <url>/archives/bee85523.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>公司使用的PostgreSql库，学习一下，写一些视图查询， 跟mysql基本上是长不多，在某些地方存在细微差距， 底层原理咋也不过多深入， 满足了工作中日常使用</p></blockquote><h2 id="window安装"><a href="#window安装" class="headerlink" title="window安装"></a>window安装</h2><ol><li>下载地址 <a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads</a></li><li>下一步，全勾上，设置密码， 去掉勾选，直接点 Finish，完成</li></ol><h2 id="设置pgAdmin4-为中文"><a href="#设置pgAdmin4-为中文" class="headerlink" title="设置pgAdmin4 为中文"></a>设置pgAdmin4 为中文</h2><ol><li>点击 file-1-选择语言</li></ol><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><h2 id="python操作postgresql"><a href="#python操作postgresql" class="headerlink" title="python操作postgresql"></a>python操作postgresql</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> psycopg2</span><br><span class="line">conn = psycopg2.connect(database=<span class="string">&quot;postgres&quot;</span>, user=<span class="string">&quot;postgres&quot;</span>, password=<span class="string">&quot;123456789&quot;</span>, host=<span class="string">&quot;10.128.212.164&quot;</span>, port=<span class="string">&quot;5432&quot;</span>)</span><br><span class="line">cur = conn.cursor()  <span class="comment"># 创建指针对象</span></span><br><span class="line">cur.execute(<span class="string">&quot;select * from statu&quot;</span>)</span><br><span class="line">results = cur.fetchall()</span><br><span class="line">conn.commit()</span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="python-Pandas-读取和写入数据库"><a href="#python-Pandas-读取和写入数据库" class="headerlink" title="python Pandas 读取和写入数据库"></a>python Pandas 读取和写入数据库</h2><h3 id="读取数据库"><a href="#读取数据库" class="headerlink" title="读取数据库"></a>读取数据库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> psycopg2</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">localhost=dict(</span><br><span class="line">    database=<span class="string">&quot;demo1&quot;</span>,</span><br><span class="line">    user=<span class="string">&quot;postgres&quot;</span>,</span><br><span class="line">    password=<span class="string">&quot;123456789&quot;</span>,</span><br><span class="line">    host=<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    port=<span class="string">&quot;5432&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redPostGresql</span>(<span class="params">config,sql</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;读取数据 config配置文件 sql语句&quot;&quot;&quot;</span></span><br><span class="line">    conn = psycopg2.connect(**config)  <span class="comment"># 连接数据库</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = pd.read_sql(sql, con=conn) <span class="comment"># 读取数据库数据</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br><span class="line"><span class="comment"># 直接获取数据库数据， 以DataFrame格式返回，（）</span></span><br><span class="line">IfsstepID = redPostGresql(cnctum0pgsql02,<span class="string">&#x27;SELECT * FROM &quot;Report&quot;.&quot;IFSStepID&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="写入数据库"><a href="#写入数据库" class="headerlink" title="写入数据库"></a>写入数据库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建连接</span></span><br><span class="line">engine = create_engine(<span class="string">&quot;postgresql://postgres:123456789@localhost:5432/demo1&quot;</span>) </span><br><span class="line"><span class="comment"># 获取要写入的数据，</span></span><br><span class="line">posData = pd.DataFrame(snWIPlist)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">     <span class="string">&quot;&quot;&quot;if_exists：</span></span><br><span class="line"><span class="string">    * fail: Raise a ValueError.</span></span><br><span class="line"><span class="string">    * replace: Drop the table before inserting new values.</span></span><br><span class="line"><span class="string">    * append: Insert new values to the existing table.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    posData.to_sql(<span class="string">&#x27;wip&#x27;</span>,engine,index=<span class="literal">False</span>,if_exists=<span class="string">&#x27;replace&#x27;</span>) <span class="comment"># 写入数据库</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure><h3 id="LIKE-模糊查询"><a href="#LIKE-模糊查询" class="headerlink" title="LIKE 模糊查询"></a>LIKE 模糊查询</h3><h4 id=""><a href="#" class="headerlink" title="%"></a>%</h4><blockquote><p>任意0个和多个字符</p></blockquote><h4 id="-1"><a href="#-1" class="headerlink" title="_"></a>_</h4><blockquote><p>任意单个字符</p></blockquote><h4 id="-2"><a href="#-2" class="headerlink" title="[]"></a>[]</h4><blockquote><p>[正则表达式]</p></blockquote><h4 id="-3"><a href="#-3" class="headerlink" title="[^]"></a>[^]</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *  <span class="keyword">FROM</span> <span class="string">&quot;public&quot;</span>.ifactoryreportdata  <span class="keyword">WHERE</span>  daytime &gt;=<span class="string">&#x27;2020-07-09&#x27;</span> <span class="keyword">and</span> daytime &lt;=<span class="string">&#x27;2020-07-23&#x27;</span>  <span class="keyword">and</span> reportname <span class="keyword">LIKE</span> <span class="string">&#x27;ic(ng)%&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="时间段查询"><a href="#时间段查询" class="headerlink" title="时间段查询"></a>时间段查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_info <span class="keyword">where</span> create_date&gt;= <span class="string">&#x27;2015-07-01&#x27;</span> <span class="keyword">and</span> create_date &lt; <span class="string">&#x27;2015-08-15&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_info <span class="keyword">where</span> create_date <span class="keyword">between</span> <span class="string">&#x27;2015-07-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2015-08-15&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">方法三：</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_info <span class="keyword">where</span> create_date &gt;= <span class="string">&#x27;2015-07-01&#x27;</span>::<span class="built_in">timestamp</span> <span class="keyword">and</span> create_date &lt; <span class="string">&#x27;2015-08-15&#x27;</span>::<span class="built_in">timestamp</span>;</span><br><span class="line"> </span><br><span class="line">方法四：</span><br><span class="line"> </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_info <span class="keyword">where</span> create_date <span class="keyword">between</span> <span class="keyword">to_date</span>(<span class="string">&#x27;2015-07-01&#x27;</span>,<span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="keyword">and</span> <span class="keyword">to_date</span>(<span class="string">&#x27;2015-08-15&#x27;</span>,<span class="string">&#x27;YYYY-MM-DD&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_info <span class="keyword">where</span> create_date <span class="keyword">between</span> <span class="keyword">to_date</span>(<span class="string">&#x27;2015-07-01&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) <span class="keyword">and</span> <span class="keyword">to_date</span>(<span class="string">&#x27;2015-08-15&#x27;</span>,<span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="表连接"><a href="#表连接" class="headerlink" title="表连接"></a>表连接</h3><h3 id="union不合并重复数据"><a href="#union不合并重复数据" class="headerlink" title="union不合并重复数据"></a>union不合并重复数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T1 <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> * <span class="keyword">from</span> T2 </span><br></pre></td></tr></table></figure><h3 id="union合并重复数据"><a href="#union合并重复数据" class="headerlink" title="union合并重复数据"></a>union合并重复数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T1 <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> T2 </span><br></pre></td></tr></table></figure><h3 id="except-左查询中返回右查询没有找到的所有非重复值"><a href="#except-左查询中返回右查询没有找到的所有非重复值" class="headerlink" title="except 左查询中返回右查询没有找到的所有非重复值"></a>except 左查询中返回右查询没有找到的所有非重复值</h3><h3 id="intersect-两个结果集的交集（即两个查询都返回的所有非重复值）"><a href="#intersect-两个结果集的交集（即两个查询都返回的所有非重复值）" class="headerlink" title="intersect 两个结果集的交集（即两个查询都返回的所有非重复值）"></a>intersect 两个结果集的交集（即两个查询都返回的所有非重复值）</h3><h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><ol><li><code>inner join</code> 内连接查询 (2表 合并，显示相同的数据)</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.*,b.* <span class="keyword">FROM</span> table_a a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table_b b <span class="keyword">ON</span> a.id=b.id</span><br></pre></td></tr></table></figure><ol start="2"><li><code>left jion</code> 左关联查询</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.*,b.* <span class="keyword">FROM</span> table_a a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table_b b <span class="keyword">ON</span> a.id=b.id</span><br></pre></td></tr></table></figure><ol start="3"><li><p>right join 右关联查询 </p></li><li><p>左连接-内连接 （取左表的部分集合，但又不存在右表中）</p></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.*,b.* <span class="keyword">FROM</span> table_a a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table_b b <span class="keyword">ON</span> a.id=b.id <span class="keyword">WHERE</span> b.id <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- SELECT a.*,b.* FROM table_a a LEFT JOIN table_b b ON a.id=b.id WHERE b.id IS NULL  只需要几秒钟中完成</span></span><br><span class="line">    <span class="comment">-- SELECT a.*,b.* FROM table_a a LEFT JOIN table_b b ON a.id !=b.id   谨慎测试，单机十几万的数据，直接把库跑挂了</span></span><br><span class="line">    <span class="comment">-- 根据测试，，你会发现， 后者比前者的查询速度相差太大了</span></span><br></pre></td></tr></table></figure><ol start="5"><li>右连接-内连接 (取有表的部分数据，但又不存在左表中)</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.*,b.* <span class="keyword">FROM</span> table_a a <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table_b b <span class="keyword">ON</span> a.id=b.id <span class="keyword">WHERE</span> a.id <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><h2 id="创建临时表查询-whit"><a href="#创建临时表查询-whit" class="headerlink" title="创建临时表查询 whit"></a>创建临时表查询 whit</h2><ol><li><code> WITH abcd AS (select * from table)</code> 语法</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 例如</span></span><br><span class="line"> <span class="keyword">WITH</span> abcd <span class="keyword">AS</span> (</span><br><span class="line">         <span class="keyword">SELECT</span> a.<span class="string">&quot;SN&quot;</span>,</span><br><span class="line">            a.<span class="string">&quot;Process&quot;</span>,</span><br><span class="line">            a.<span class="string">&quot;ProcessID&quot;</span>,</span><br><span class="line">            to_char(<span class="keyword">now</span>(), <span class="string">&#x27;yyyy-mm-dd&#x27;</span>::<span class="built_in">text</span>) <span class="keyword">AS</span> lasttime,</span><br><span class="line">            a.<span class="string">&quot;Project&quot;</span></span><br><span class="line">           <span class="keyword">FROM</span> <span class="string">&quot;Report&quot;</span>.<span class="string">&quot;mainSnWithFirstTimeStationAndResult&quot;</span> a</span><br><span class="line">          <span class="keyword">WHERE</span> (to_char(<span class="keyword">now</span>(), <span class="string">&#x27;yyyy-mm-dd&#x27;</span>::<span class="built_in">text</span>) = to_char(a.<span class="string">&quot;FirstTime&quot;</span>, <span class="string">&#x27;yyyy-mm-dd&#x27;</span>::<span class="built_in">text</span>))</span><br><span class="line">        )</span><br><span class="line"> <span class="keyword">SELECT</span> a.<span class="string">&quot;SN&quot;</span>,</span><br><span class="line">    <span class="keyword">upper</span>((a.<span class="string">&quot;Process&quot;</span>)::<span class="built_in">text</span>) <span class="keyword">AS</span> process,</span><br><span class="line">    a.lasttime,</span><br><span class="line">    a.<span class="string">&quot;ProcessID&quot;</span>,</span><br><span class="line">    a.<span class="string">&quot;Project&quot;</span></span><br><span class="line">   <span class="keyword">FROM</span> abcd a</span><br><span class="line">  <span class="keyword">WHERE</span> (<span class="string">&quot;RawData&quot;</span>.isnumeric(a.<span class="string">&quot;Process&quot;</span>) &lt;&gt; <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"> <span class="keyword">SELECT</span> a.<span class="string">&quot;SN&quot;</span>,</span><br><span class="line">    <span class="keyword">upper</span>(b.<span class="string">&quot;StepName&quot;</span>) <span class="keyword">AS</span> process,</span><br><span class="line">    a.lasttime,</span><br><span class="line">    a.<span class="string">&quot;ProcessID&quot;</span>,</span><br><span class="line">    a.<span class="string">&quot;Project&quot;</span></span><br><span class="line">   <span class="keyword">FROM</span> (abcd a</span><br><span class="line">     <span class="keyword">JOIN</span> <span class="string">&quot;Report&quot;</span>.<span class="string">&quot;IFSStepID&quot;</span> b <span class="keyword">ON</span> (((a.<span class="string">&quot;Process&quot;</span>)::<span class="built_in">text</span> = b.<span class="string">&quot;StepID&quot;</span>)));</span><br><span class="line"></span><br><span class="line">   <span class="comment">-- 创建 临时表 abcd， </span></span><br><span class="line"><span class="comment">-- 创建多个临时表， 只需要用 , 分割就好， 最后一定要有sql语句</span></span><br><span class="line"><span class="comment">-- 多个语句语法语法</span></span><br><span class="line"><span class="keyword">WITH</span> so1 <span class="keyword">AS</span> (),so2 <span class="keyword">AS</span>(),so3 <span class="keyword">AS</span> ()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="排序ORDER-BY"><a href="#排序ORDER-BY" class="headerlink" title="排序ORDER BY"></a>排序ORDER BY</h2><blockquote><p>查询后，按什么字段排序 升序：<code>ASC</code>；降序：<code>DESC</code>；</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 例句：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="聚合查询-分组"><a href="#聚合查询-分组" class="headerlink" title="聚合查询,分组"></a>聚合查询,分组</h2><blockquote><p>GROUP BY我们可以先从字面上来理解，GROUP表示分组，BY后面写字段名，就表示根据哪个字段进行分组，如果有用Excel比较多的话，GROUP BY比较类似Excel里面的透视表。<br>GROUP BY必须得配合聚合函数来用，分组之后你可以计数（COUNT），求和（SUM），求平均数（AVG）等</p></blockquote><h3 id="常用的-聚合查询"><a href="#常用的-聚合查询" class="headerlink" title="常用的 聚合查询"></a>常用的 聚合查询</h3><blockquote><ol><li><code>count()</code> 计数</li><li><code>sum()</code> 求和</li><li><code>avg()</code> 平均数</li><li><code>max()</code> 最大值</li><li><code>min()</code> 最小值</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 以a.customer, a.factory, a.lineid, a.reportprocess, a.wip分组， 计算sum(a.sn) 的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> a.customer,</span><br><span class="line">    a.factory,</span><br><span class="line">    a.lineid,</span><br><span class="line">    a.reportprocess,</span><br><span class="line">    a.wip,</span><br><span class="line">    to_char(<span class="keyword">now</span>(), <span class="string">&#x27;yyyy-mm-dd&#x27;</span>::<span class="built_in">text</span>) <span class="keyword">AS</span> lasttime,</span><br><span class="line">    <span class="keyword">sum</span>(a.sn) <span class="keyword">AS</span> wipsn</span><br><span class="line">   <span class="keyword">FROM</span> stationamecount a</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.customer, a.factory, a.lineid, a.reportprocess, a.wip;</span><br></pre></td></tr></table></figure><h3 id="HAVING-筛选"><a href="#HAVING-筛选" class="headerlink" title="HAVING 筛选"></a>HAVING 筛选</h3><blockquote><p><code>HAVING</code>是对于<code>GROUP BY</code>对象进行筛选， 可以使用聚合函数筛选</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.customer,</span><br><span class="line">    a.factory,</span><br><span class="line">    a.lineid,</span><br><span class="line">    a.reportprocess,</span><br><span class="line">    a.wip,</span><br><span class="line">    to_char(<span class="keyword">now</span>(), <span class="string">&#x27;yyyy-mm-dd&#x27;</span>::<span class="built_in">text</span>) <span class="keyword">AS</span> lasttime,</span><br><span class="line">    <span class="keyword">sum</span>(a.sn) <span class="keyword">AS</span> wipsn</span><br><span class="line">   <span class="keyword">FROM</span> stationamecount a</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.customer, a.factory, a.lineid, a.reportprocess, a.wip</span><br><span class="line">  <span class="keyword">HAVING</span> a.wip=<span class="string">&#x27;yes&#x27;</span>  <span class="comment">-- 筛选除 wip=yes的 组， </span></span><br></pre></td></tr></table></figure><h2 id="Postgresql-子查询"><a href="#Postgresql-子查询" class="headerlink" title="Postgresql 子查询"></a>Postgresql 子查询</h2><blockquote><p>子查询或称为内部查询、嵌套查询，指的是在 PostgreSQL 查询中的 WHERE 子句中嵌入查询语句</p></blockquote><h2 id="函数集"><a href="#函数集" class="headerlink" title="函数集"></a>函数集</h2><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="initcap-首字母大写"><a href="#initcap-首字母大写" class="headerlink" title="initcap(首字母大写)"></a>initcap(首字母大写)</h4><h4 id="lower-字母全部小写"><a href="#lower-字母全部小写" class="headerlink" title="lower(字母全部小写)"></a>lower(字母全部小写)</h4><h4 id="upper-字母全部大写"><a href="#upper-字母全部大写" class="headerlink" title="upper(字母全部大写)"></a>upper(字母全部大写)</h4><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><h4 id="now-获取当前日期"><a href="#now-获取当前日期" class="headerlink" title="now() 获取当前日期"></a>now() 获取当前日期</h4><h4 id="localtime-当前时间-SELECT-localtime"><a href="#localtime-当前时间-SELECT-localtime" class="headerlink" title="localtime 当前时间 SELECT localtime"></a>localtime 当前时间 <code>SELECT localtime</code></h4><h4 id="localtimestamp-当前日期和时间-SELECT-localtimestamp"><a href="#localtimestamp-当前日期和时间-SELECT-localtimestamp" class="headerlink" title="localtimestamp 当前日期和时间 SELECT localtimestamp"></a>localtimestamp 当前日期和时间 <code>SELECT localtimestamp</code></h4><h4 id="current-date-当前日期-select-current-date"><a href="#current-date-当前日期-select-current-date" class="headerlink" title="current_date 当前日期 select current_date;"></a>current_date 当前日期 <code>select current_date;</code></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">to_char(now(), &#x27;yyyy-mm-dd&#x27;::text) <span class="comment">-- 2020-07-14</span></span><br></pre></td></tr></table></figure><h4 id="timeofday-当前日期和时间"><a href="#timeofday-当前日期和时间" class="headerlink" title="timeofday()当前日期和时间"></a>timeofday()当前日期和时间</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> timeofday()</span><br><span class="line"><span class="comment">-- Tue Jul 14 09:32:24.894371 2020 HKT</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 时间计算</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>() + <span class="built_in">interval</span> <span class="string">&#x27;1 years&#x27;</span> <span class="comment">-- 一年后 </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>() + <span class="built_in">interval</span> <span class="string">&#x27;1 month&#x27;</span> <span class="comment">-- 一月后</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>() - <span class="built_in">interval</span> <span class="string">&#x27;3 week&#x27;</span>  <span class="comment">--三周后</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>() + <span class="string">&#x27;10 min&#x27;</span> <span class="comment">-- 10分钟后</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>() + <span class="string">&#x27;10 D&#x27;</span>      <span class="comment">-- 一天后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Abbreviation    Meaning</span></span><br><span class="line"><span class="comment">    Y            Years</span></span><br><span class="line"><span class="comment">    M            Months (in the date part)</span></span><br><span class="line"><span class="comment">    W            Weeks</span></span><br><span class="line"><span class="comment">    D            Days</span></span><br><span class="line"><span class="comment">    H            Hours</span></span><br><span class="line"><span class="comment">    M            Minutes (in the time part)</span></span><br><span class="line"><span class="comment">    S            Seconds</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="age-计算2个时间差"><a href="#age-计算2个时间差" class="headerlink" title="age() 计算2个时间差"></a>age() 计算2个时间差</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> age(<span class="built_in">timestamp</span> <span class="string">&#x27;2019-09-15&#x27;</span>); <span class="comment">-- 9 mons 29 days</span></span><br><span class="line"><span class="keyword">select</span> age(<span class="keyword">now</span>(), <span class="built_in">timestamp</span> <span class="string">&#x27;2022-02-05&#x27;</span>); <span class="comment">-- -1 years -6 mons -21 days -14:12:19.288452</span></span><br><span class="line"><span class="keyword">select</span> age(<span class="keyword">now</span>(), <span class="built_in">timestamp</span> <span class="string">&#x27;2019-02-05&#x27;</span>); <span class="comment">-- 1 year 5 mons 9 days 09:48:08.012659</span></span><br></pre></td></tr></table></figure><h4 id="EXTRACT-field-FROM-source-时间字段截取"><a href="#EXTRACT-field-FROM-source-时间字段截取" class="headerlink" title="EXTRACT(field FROM source)时间字段截取"></a>EXTRACT(field FROM source)时间字段截取</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取年</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="keyword">now</span>()); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取月份</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">month</span> <span class="keyword">from</span> <span class="keyword">now</span>());    </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取 天数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">day</span> <span class="keyword">from</span> <span class="built_in">timestamp</span> <span class="string">&#x27;2013-04-13&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXTRACT</span>(<span class="keyword">DAY</span> <span class="keyword">FROM</span> <span class="built_in">INTERVAL</span> <span class="string">&#x27;40 days 1 minute&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看今天是一年中的多少天</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">extract</span>(doy <span class="keyword">from</span> <span class="keyword">now</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><h4 id="to-number-数值类型的字符-将字符转换为数值"><a href="#to-number-数值类型的字符-将字符转换为数值" class="headerlink" title="to_number(数值类型的字符):将字符转换为数值"></a>to_number(数值类型的字符):将字符转换为数值</h4><h4 id="to-char-数值或者是日期-将数值或者日期转换为字符"><a href="#to-char-数值或者是日期-将数值或者日期转换为字符" class="headerlink" title="to_char(数值或者是日期):将数值或者日期转换为字符"></a>to_char(数值或者是日期):将数值或者日期转换为字符</h4><h4 id="to-date-日期格式的字符-：将字符转换为日期"><a href="#to-date-日期格式的字符-：将字符转换为日期" class="headerlink" title="to_date(日期格式的字符)：将字符转换为日期"></a>to_date(日期格式的字符)：将字符转换为日期</h4><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><h4 id="函数基本语法"><a href="#函数基本语法" class="headerlink" title="函数基本语法"></a>函数基本语法</h4><blockquote><p>实践中，官方函数没法满足需求，就需要自己写函数， 那么了解 函数的语法构建</p></blockquote><blockquote><p>自定义函数像内置函数一样返回标量值，也可以将结果集用表格变量返回。sql函数必须有返回值</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="自定义函数整理"><a href="#自定义函数整理" class="headerlink" title="自定义函数整理"></a>自定义函数整理</h4><h5 id="判断为存数字函数"><a href="#判断为存数字函数" class="headerlink" title="判断为存数字函数"></a>判断为存数字函数</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span></span><br><span class="line"><span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> isnumeric (txtStr <span class="built_in">VARCHAR</span>) <span class="keyword">RETURNS</span> <span class="built_in">BOOLEAN</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">RETURN</span> txtStr ~ <span class="string">&#x27;^([0-9]+[.]?[0-9]*|[.][0-9]+)$&#x27;</span> ;</span><br><span class="line"><span class="keyword">END</span> ; $$ LANGUAGE &#x27;plpgsql&#x27;;</span><br></pre></td></tr></table></figure><h3 id="ALTER-TABLE-曾删表的列"><a href="#ALTER-TABLE-曾删表的列" class="headerlink" title="ALTER TABLE 曾删表的列"></a>ALTER TABLE 曾删表的列</h3><blockquote><p>alter table命令用于添加、修改、删除一张已经存在表的列, 也可以添加，删除约束</p></blockquote><p><strong>语法</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- table_name ：表名 ; column_name：新列名; datatype：数据类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> column_name datatype;</span><br></pre></td></tr></table></figure><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><blockquote><p>视图： 就是查询语句的别名，生成的新的表</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> viewName <span class="keyword">AS</span> <span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">id</span>,age <span class="keyword">FROM</span> student <span class="keyword">WITH</span> <span class="keyword">id</span>&gt;<span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 这样 viewName 就是一个视图， 可以理解为一张新的表在数据库了</span></span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p>一组操作，要么成功，要么失败</p></blockquote><h2 id="Postgresql-触发器"><a href="#Postgresql-触发器" class="headerlink" title="Postgresql 触发器"></a>Postgresql 触发器</h2><blockquote><p>触发器是数据库的回调函数，它会在指定的数据库事件发生时自动执行/调用</p></blockquote><blockquote><ul><li>PostgreSQL 触发器 触发情况！<ul><li>在执行操作之前（在检查约束并尝试插入、更新或删除之前）。</li><li>在执行操作之后（在检查约束并插入、更新或删除完成之后）。</li><li>更新操作（在对一个视图进行插入、更新、删除时）</li></ul></li></ul></blockquote><h2 id="Postgresql索引"><a href="#Postgresql索引" class="headerlink" title="Postgresql索引"></a>Postgresql索引</h2><blockquote><p>索引是加速搜索引擎检索数据的一种特殊表查询。简单地说，索引是一个指向表中数据的指针。 方便快速检索数据，<br>创建的索引多了， 也会影响查询效率</p></blockquote><blockquote><p>语法：  使用 CREATE INDEX 语句创建索引，它允许命名索引，指定表及要索引的一列或多列，并指示索引是升序排列还是降序排列。<br>索引也可以是唯一的，与 UNIQUE 约束类似，在列上或列组合上防止重复条目。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">创建索引： <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name;</span><br><span class="line">删除所有： <span class="keyword">drop</span> <span class="keyword">index</span> index_name</span><br></pre></td></tr></table></figure><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><table><thead><tr><th><strong>类型</strong></th><th align="left"><strong>语法</strong></th></tr></thead><tbody><tr><td>单列索引</td><td align="left">CREATE INDEX index_name ON table_name(column_name);</td></tr><tr><td>组合索引</td><td align="left">CREATE INDEX index_name ON table_name(column1_name,column2_name);</td></tr><tr><td>唯一索引</td><td align="left">CREATE UNIQUE INDEX index_name on table_name (column_name);</td></tr><tr><td>局部索引</td><td align="left">CREATE INDEX index_name on table_name (conditional)</td></tr><tr><td>隐式索引</td><td align="left">建表时由数据库服务器自动创建，一般为主键约束和唯一约束</td></tr></tbody></table><blockquote><p>不管是单列索引还是组合索引，该索引必须是在WHERE子句的过滤条件中使用非常频繁的列。<br>唯一索引的使用，一方面提高了查询性能，同时也保护了数据的完整性，不允许任何重复的值插入到表中。</p></blockquote><blockquote><ul><li>什么情况下避免使用索引？<ul><li>表数据较小时不需要使用索引</li><li>进行频繁插入或更新操作的表不需要使用</li><li>不应该使用在含有大量的NULL值的列上</li><li>不使用在频繁操作的列上</li></ul></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(to_char(now(), &#x27;yyyy-mm-dd&#x27;::text) = to_char(a.&quot;LastTime&quot;, &#x27;yyyy-mm-dd&#x27;::text)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">SELECT</span> a.*,b.wipsn,b.wip <span class="keyword">FROM</span> pvder <span class="keyword">as</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">&quot;RawData&quot;</span>.<span class="string">&quot;wipCounts&quot;</span> <span class="keyword">as</span> b <span class="keyword">ON</span> <span class="keyword">upper</span>(a.factory) = b.factory </span><br><span class="line"> <span class="keyword">and</span> <span class="keyword">upper</span>(a.customer)=b.customer </span><br><span class="line"> <span class="keyword">and</span> <span class="keyword">upper</span>(a.lineid) =  b.lineid </span><br><span class="line"> <span class="keyword">and</span> <span class="keyword">upper</span>(a.reportprocess) = b.reportprocess</span><br><span class="line"> <span class="keyword">and</span> a.date = b.lasttime <span class="keyword">WHERE</span> a.date =b.lasttime</span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> a.*,b.wip <span class="keyword">FROM</span> pvder <span class="keyword">as</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">&quot;RawData&quot;</span>.<span class="string">&quot;wipCount&quot;</span> <span class="keyword">as</span> b <span class="keyword">ON</span> <span class="keyword">upper</span>(a.factory) = b.factory </span><br><span class="line"><span class="keyword">and</span> <span class="keyword">upper</span>(a.customer)=b.customer </span><br><span class="line"><span class="keyword">and</span> <span class="keyword">upper</span>(a.lineid) =  b.lineid </span><br><span class="line"><span class="keyword">and</span> <span class="keyword">upper</span>(a.reportprocess) = b.reportprocess</span><br><span class="line"><span class="keyword">and</span> a.date =to_char(<span class="keyword">now</span>(), <span class="string">&#x27;yyyy-mm-dd&#x27;</span>) <span class="keyword">WHERE</span> a.date = to_char(<span class="keyword">now</span>(), <span class="string">&#x27;yyyy-mm-dd&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> PostgreSql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koa.js的路由请求（2）</title>
      <link href="/archives/2d20ecd4.html"/>
      <url>/archives/2d20ecd4.html</url>
      
        <content type="html"><![CDATA[<h2 id="koa-js中路由的理解"><a href="#koa-js中路由的理解" class="headerlink" title="koa.js中路由的理解"></a>koa.js中路由的理解</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">router</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> page = <span class="string">&#x27;404.html&#x27;</span></span><br><span class="line">    <span class="keyword">switch</span>(url)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            page=<span class="string">&#x27;index.html&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;index&#x27;</span>:</span><br><span class="line">            page=<span class="string">&#x27;index&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/todo&#x27;</span>:</span><br><span class="line">            page=<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ol><li>方法一</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.use(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> ctx=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.method==<span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">        ctx.body=&#123;<span class="attr">msg</span>:<span class="string">&quot;测试成功&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Koa-bodyparser-中间件"><a href="#Koa-bodyparser-中间件" class="headerlink" title="Koa-bodyparser 中间件"></a>Koa-bodyparser 中间件</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node.js </tag>
            
            <tag> koa.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs环境配置</title>
      <link href="/archives/12affc36.html"/>
      <url>/archives/12affc36.html</url>
      
        <content type="html"><![CDATA[<p>node.js 相关配置</p><h3 id="node-js-Windons安装配置"><a href="#node-js-Windons安装配置" class="headerlink" title="node.js Windons安装配置"></a>node.js Windons安装配置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">官网下载直接安装（选择路径安装）</span><br><span class="line">找到安装路径，下创建<span class="number">2</span>个文件</span><br><span class="line">node_cache, node_gloal</span><br><span class="line">然后在cmd中输入</span><br><span class="line">npm config set prefix <span class="string">&quot;D:\Program Files\nodejs\node_global&quot;</span></span><br><span class="line">npm config set cache <span class="string">&quot;D:\Program Files\nodejs\node_cache&quot;</span></span><br><span class="line"></span><br><span class="line">在在环境配置中修改</span><br><span class="line">系统变量中 添加 </span><br><span class="line">NODE_PATH   D:\Program Files\nodejs\node_cache</span><br><span class="line">个人变量中path 中把原来的npm路径修改 成 D:\Program Files\nodejs\node_global</span><br><span class="line">这样下载的全局安装就会在node_global 文件中 </span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="npm-修改源"><a href="#npm-修改源" class="headerlink" title="npm 修改源"></a>npm 修改源</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 淘宝镜像源</span></span><br><span class="line">npm config set registry https:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看 使用的 镜像源</span></span><br><span class="line">npm config get registry</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装 淘宝镜像源</span></span><br><span class="line">npm install -g cnpm --registry=https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure><h3 id="centos下安装"><a href="#centos下安装" class="headerlink" title="centos下安装"></a>centos下安装</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">稳定版：</span><br><span class="line">1. 软件预存：</span><br><span class="line"><span class="meta">$</span><span class="bash"> yum clean all &amp;&amp; yum makecache fast</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install -y gcc-c++ make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -sL https://rpm.nodesource.com/setup_10.x | sudo -E bash -</span></span><br><span class="line"></span><br><span class="line">2. sudo yum install nodejs -y</span><br><span class="line"></span><br><span class="line">3. node -v， npm -v</span><br><span class="line"></span><br><span class="line">最新版安装：</span><br><span class="line"><span class="meta">$</span><span class="bash"> yum clean all &amp;&amp; yum makecache fast</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install -y gcc-c++ make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -sL https://rpm.nodesource.com/setup_12.x | sudo -E bash -</span></span><br></pre></td></tr></table></figure><h3 id="相关包安装"><a href="#相关包安装" class="headerlink" title="相关包安装"></a>相关包安装</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一. nrm 安装</span><br><span class="line">    <span class="number">1.</span> npm i nrm -g全局安装`nrm`包；</span><br><span class="line">    <span class="number">2.</span> nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；</span><br><span class="line">    <span class="number">3.</span> nrm use npm 或nrm use taobao`切换不同的镜像源地址；</span><br></pre></td></tr></table></figure><h3 id="js动画库"><a href="#js动画库" class="headerlink" title="js动画库"></a>js动画库</h3><ol><li>Three.js</li><li>Anime.js</li><li>Mo.js</li><li>Velocity.js</li><li>Popmotion</li><li>Vivus</li><li>GreenSock js</li><li>Scroll Reveal</li><li>Hover(css)</li><li>Kute.js</li><li>Typed.js</li><li>echarts</li></ol><p><a href="http://jxhx2.yangqq.com/blog/#">http://jxhx2.yangqq.com/blog/#</a><br><a href="https://www.yangqq.com/link.html">https://www.yangqq.com/link.html</a><br><a href="http://ww.aliwen.vip/">http://ww.aliwen.vip/</a><br><a href="https://shawnzeng.com/">https://shawnzeng.com/</a><br><a href="https://blog.csdn.net/weixin_44387725/article/details/90904191">https://blog.csdn.net/weixin_44387725/article/details/90904191</a></p><p><a href="https://www.bilibili.com/video/av83101450?p=26">https://www.bilibili.com/video/av83101450?p=26</a></p><p><a href="https://www.bilibili.com/video/av88732281?p=46">https://www.bilibili.com/video/av88732281?p=46</a></p><p><a href="https://www.cnblogs.com/AlexanderZhao/p/LearnCSSGrid.html">https://www.cnblogs.com/AlexanderZhao/p/LearnCSSGrid.html</a>  css</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koa.js项目架构搭建(1)</title>
      <link href="/archives/89dec30a.html"/>
      <url>/archives/89dec30a.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://baijiahao.baidu.com/s?id=1666457840325027566&wfr=spider&for=pc">pycharm最新方法</a></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ nvm install <span class="number">7</span></span><br><span class="line">$ npm i koa</span><br><span class="line">$ node my-koa-app.js</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node.js </tag>
            
            <tag> koa.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-数组和对象类型判断</title>
      <link href="/archives/6091f578.html"/>
      <url>/archives/6091f578.html</url>
      
        <content type="html"><![CDATA[<h3 id="js-如何判断数组和对象的类型"><a href="#js-如何判断数组和对象的类型" class="headerlink" title="js 如何判断数组和对象的类型"></a>js 如何判断数组和对象的类型</h3><p>在使用 <code>typeOf</code> 判断的时候 都是 <code>Object</code></p><blockquote><p>在es6中 可以使用 <code>instanceof</code> <code>Array.isArray(ary)</code> <code>constructor </code></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> art = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(art <span class="keyword">instanceof</span> <span class="built_in">Array</span>)</span><br><span class="line"><span class="built_in">console</span>.log(art.constructor === <span class="built_in">Array</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(art))</span><br></pre></td></tr></table></figure><blockquote><p>考虑兼容性问题可以使用 <code>Object.prototype.toString.call()</code>来判断</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(art) === <span class="string">&quot;[object Array]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是对象&#123;&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(art) === <span class="string">&quot;[object object]&quot;</span></span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css权重和属性继承</title>
      <link href="/archives/f4ae9910.html"/>
      <url>/archives/f4ae9910.html</url>
      
        <content type="html"><![CDATA[<h3 id="可继承的样式"><a href="#可继承的样式" class="headerlink" title="可继承的样式"></a>可继承的样式</h3><p>1.字体系列属性 font，font-family，font-weight，font-size，font-style，font-variant，font-stretch，font-size-adjust</p><p>2.文本系列属性 text-indent，text-align，line-height，word-spacing，letter-spacing，text-transform，direction，color</p><p>3.元素可见性 visibility</p><p>4.表格布局属性 caption-side，border-collapse，border-spacing，empty-cells，table-layout</p><p>5.列表布局属性 list-style-type，list-style-image，list-style-position，list-style</p><p>6.生成内容属性 quotes</p><p>7.光标属性 cursor</p><p>8.页面样式属性 page，page-break-inside，windows，orphans</p><p>9.声音样式属性 speak，speak-punctuation，speak-numeral，speak-header，speech-rate，volume，voice-family，pitch，pitch-range，stress，richness，azimuth，elevation</p><h3 id="优先级算法如何计算"><a href="#优先级算法如何计算" class="headerlink" title="优先级算法如何计算"></a>优先级算法如何计算</h3><p>1.优先级就近原则，同权重情况下样式定义最近者为准；</p><p>2.载入样式以最后载入的定位为准；</p><p>3.!important &gt; id &gt; class &gt; tag；</p><p>4.important 比 内联优先级高，但内联比id要高,id比class高</p><a id="more"></a><h3 id="CSS-选择符有哪些"><a href="#CSS-选择符有哪些" class="headerlink" title="CSS 选择符有哪些"></a>CSS 选择符有哪些</h3><blockquote><p>1.id选择器<code>（#id）</code><br>2.类选择器<code>（.class）</code><br>3.标签选择器<code>（div，h1，p）</code><br>4.相邻选择器<code>（h1 + p）</code><br>5.子选择器<code>（ul &gt; li）</code><br>6.后代选择器<code>（li a）</code><br>7.通配符选择器<code>（ * ）</code><br>8.属性选择器<code>（a[title]）</code><br>9.伪类选择器<code>（a:hover，li:nth-child）</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm项目初始化</title>
      <link href="/archives/d478e240.html"/>
      <url>/archives/d478e240.html</url>
      
        <content type="html"><![CDATA[<h2 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h2><ol><li><p><code>npm init</code> 初始化项目， 一值 ent</p></li><li><p>创建 <code>scr</code> 文件夹 <code>index.js  </code>  /  <code>index.html</code></p></li><li><p><code>npm install webpack  webpack-cli -save-dev</code></p></li><li><p>创建 <code>webpack.dev.config.js</code>  配置</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    entry: <span class="string">&#x27;./scr/index.js&#x27;</span>,  <span class="comment">// 入口文件路径</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        path: __dirname,</span><br><span class="line">        filename:<span class="string">&#x27;./releasse/bundle.js&#x27;</span>    <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ol start="5"><li><p><code>npm install webpack-dev-server html-webpack-plugin --save-dev</code></p></li><li><p><code>npm i bacbel-core babel-loader babel-polyfill babel-preset-es2015 babel-prset-latest</code></p></li></ol><p><code>.babelrc</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-time时间转换操作</title>
      <link href="/archives/44876dc0.html"/>
      <url>/archives/44876dc0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>将时间戳和时间格式转成，str类型<br>格林尼治2019-03-19T16:00:00.000Z  ==&gt;&gt;  2019-03-20 00:00:00   与北京时间8小时时差</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> formDate = <span class="function"><span class="params">dateForm</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dateForm === <span class="string">&#x27;&#x27;</span>)<span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> dateee = <span class="keyword">new</span> <span class="built_in">Date</span>(dateForm).toJSON();</span><br><span class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(+<span class="keyword">new</span> <span class="built_in">Date</span>(dateee)+ <span class="number">8</span> * <span class="number">3600</span> * <span class="number">1000</span>).toISOString().replace(<span class="regexp">/T/g</span>,<span class="string">&#x27; &#x27;</span>).replace(<span class="regexp">/\.[\d]&#123;3&#125;Z/</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符串2019-03-20 00:00:00，转成 Date格式Sat Apr 20 2019 00:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="keyword">let</span> getDate= <span class="function"><span class="params">strDate</span>=&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">const</span> st = strDate; </span><br><span class="line">  <span class="keyword">const</span> a = st.split(<span class="string">&quot; &quot;</span>); </span><br><span class="line">  <span class="keyword">const</span> b = a[<span class="number">0</span>].split(<span class="string">&quot;-&quot;</span>); </span><br><span class="line">  <span class="keyword">const</span> c = a[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>); </span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(b[<span class="number">0</span>], b[<span class="number">1</span>], b[<span class="number">2</span>], c[<span class="number">0</span>], c[<span class="number">1</span>], c[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">return</span> date; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将时间戳1553547600000  转 //  2019-03-25T21:00:00.000Z</span></span><br><span class="line"><span class="keyword">let</span> formatDate = <span class="function"><span class="params">datatime</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timestamp = datatime;</span><br><span class="line">    <span class="keyword">let</span> newDate = <span class="keyword">new</span> <span class="built_in">Date</span>(datatime)</span><br><span class="line">    <span class="comment">// let newDate = new Date(datatime+8*36000*1000)</span></span><br><span class="line">    newDate.getTime(timestamp*<span class="number">1000</span>)</span><br><span class="line">    <span class="comment">// console.log(newDate.toDateString());//Mon Mar 11 2019          </span></span><br><span class="line">    <span class="comment">// console.log(newDate.toGMTString()); //Mon, 11 Mar 2019 06:55:07 GMT </span></span><br><span class="line">    <span class="comment">// console.log(newDate.toISOString()); //2019-03-11T06:55:07.622Z</span></span><br><span class="line">    <span class="keyword">return</span> newDate.toISOString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间倒计时"><a href="#时间倒计时" class="headerlink" title="时间倒计时"></a>时间倒计时</h2><h2 id="时间计时器"><a href="#时间计时器" class="headerlink" title="时间计时器"></a>时间计时器</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机读书-文件收藏</title>
      <link href="/archives/91580c5e.html"/>
      <url>/archives/91580c5e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>coding只能部署不超过134217728 字节大小的博客， 文件将部署到其它服务上</p></blockquote><h2 id="高等数据-算法"><a href="#高等数据-算法" class="headerlink" title="高等数据-算法"></a>高等数据-算法</h2><blockquote></blockquote><h2 id="python电子书籍"><a href="#python电子书籍" class="headerlink" title="python电子书籍"></a>python电子书籍</h2><blockquote><p>暂无</p></blockquote><ul><li><a href="/file/python/%E3%80%8A%E7%96%AF%E7%8B%82Python%E8%AE%B2%E4%B9%89%E3%80%8B.pdf">疯狂Python讲义</a></li><li><a href="/file/python/%E3%80%8AFlask%20Web%E5%BC%80%E5%8F%91%EF%BC%9A%E5%9F%BA%E4%BA%8EPython%E7%9A%84Web%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E3%80%8B.pdf">Flask Web开发 基于Python的Web应用开发实战</a></li><li><a href="/file/python/%E3%80%8AFlask+Web%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%EF%BC%9A%E5%85%A5%E9%97%A8%E3%80%81%E8%BF%9B%E9%98%B6%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E6%9D%8E%E8%BE%89%E8%91%97+%EF%BC%89%E3%80%8BPDF.pdf">Flask+Web开发实战：入门、进阶与原理解析（李辉著+）</a></li><li><a href="/file/python/%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.pdf">利用Python进行数据分析</a></li></ul><a id="more"></a><h2 id="前端电子书"><a href="#前端电子书" class="headerlink" title="前端电子书"></a>前端电子书</h2><blockquote><p>可看</p></blockquote><ul><li><a href="/file/%E5%89%8D%E7%AB%AF/%5BJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97(%E7%AC%AC%E4%B8%83%E7%89%88)%5D.(%E7%BE%8E)David.Flanagan.%E4%B8%AD%E6%96%87%E6%89%AB%E6%8F%8F%E7%89%88.pdf">JavaScript权威指南(第七版)-中文</a></li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><blockquote><p>暂无</p></blockquote><ul><li><a href="/file/python/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA_%E4%BD%9B%E7%BD%97%E8%B5%9E.pdf">计算机科学导论</a></li><li><a href="/file/Linux/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C_%E7%AC%AC%E5%9B%9B%E7%89%88.pdf">鸟哥的Linux私房菜_第四版</a></li></ul><h2 id="常用ARM指令集及汇编"><a href="#常用ARM指令集及汇编" class="headerlink" title="常用ARM指令集及汇编"></a>常用ARM指令集及汇编</h2><blockquote><p>可看  </p></blockquote><ul><li><a href="/file/%E9%80%86%E5%90%91/%E5%B8%B8%E7%94%A8ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E5%8F%8A%E6%B1%87%E7%BC%96.pdf">常用ARM指令集及汇编-点击下载</a></li></ul><p><a href="https://demo.jerryc.me/">https://demo.jerryc.me/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios请求封装</title>
      <link href="/archives/c88f0c02.html"/>
      <url>/archives/c88f0c02.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>项目中对 axios 请求的封装 </p></blockquote><blockquote><p>axios.js 文件</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baseUrl = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;/api/&#x27;</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 参数初始化</span></span><br><span class="line">  <span class="keyword">constructor</span> (baseUrl = baseURL) &#123;</span><br><span class="line">    <span class="built_in">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="built_in">this</span>.queue = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  getInsideConfig () &#123;</span><br><span class="line">    <span class="keyword">const</span> config = &#123;</span><br><span class="line">      baseURL: <span class="built_in">this</span>.baseUrl,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;</span><br><span class="line">  distroy (url) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.queue[url]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.queue).length) &#123;</span><br><span class="line">      <span class="comment">// Spin.hide()</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors (instance, url) &#123;</span><br><span class="line">    <span class="comment">// 请求拦截</span></span><br><span class="line">    instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 添加全局的loading...</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.queue).length) &#123;</span><br><span class="line">        <span class="comment">// Spin.show()</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.queue[url] = <span class="literal">true</span>;</span><br><span class="line">      config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = getToken()</span><br><span class="line">      <span class="keyword">return</span> config</span><br><span class="line">    &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 对请求结果拦截处理</span></span><br><span class="line">    instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.distroy(url)</span><br><span class="line">      <span class="keyword">const</span> &#123; data &#125; = res</span><br><span class="line">      <span class="keyword">return</span> data</span><br><span class="line">    &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.distroy(url)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error.response.data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  request (options) &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = axios.create()</span><br><span class="line">    options = <span class="built_in">Object</span>.assign(<span class="built_in">this</span>.getInsideConfig(), options)</span><br><span class="line">    <span class="built_in">this</span>.interceptors(instance, options.url)</span><br><span class="line">    <span class="keyword">return</span> instance(options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> axios = <span class="keyword">new</span> HttpRequest()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios</span><br><span class="line"><span class="comment">// export default HttpRequest</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>使用</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中数组常用方法</title>
      <link href="/archives/98ca42b0.html"/>
      <url>/archives/98ca42b0.html</url>
      
        <content type="html"><![CDATA[<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><blockquote><p>用来过滤数组，返回一个新的数组，filter方法需要在循环的时候判断一下是true还是false，是true才会返回这个元素；<br>接收一个方法，该方法可传入三个参数，第一个为数组的一个元素，第二位为该元素的下标，第三个为原数组。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">22</span>,<span class="number">44</span>,<span class="number">22</span>,<span class="number">1</span>,<span class="number">90</span>];</span><br><span class="line"><span class="keyword">let</span> ary2 = ary.filter(<span class="function">(<span class="params">value,key,arr</span>)=&gt;</span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(value); <span class="comment">//=&gt; 值</span></span><br><span class="line">        <span class="built_in">console</span>.log(key);  <span class="comment">// =&gt; 索引</span></span><br><span class="line">        <span class="built_in">console</span>.log(arr); <span class="comment">// =&gt; ary数组</span></span><br><span class="line">       <span class="keyword">return</span> value &gt;<span class="number">10</span>? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ary); <span class="comment">// 不变</span></span><br><span class="line"><span class="built_in">console</span>.log(ary2) <span class="comment">//[22, 44, 22, 90]</span></span><br></pre></td></tr></table></figure><p><strong>去重</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ary= [<span class="number">2</span>,<span class="number">3</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> new_ary = ary.filter(<span class="function">(<span class="params">x,index,self</span>)=&gt;</span>self.indexOf(x)===index)</span><br><span class="line"><span class="comment">//new_ary =&gt;[2, 3, 23, 12, 1, 4, 56]</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><blockquote><p>map()根据当前数组映射出一个新的数组,可以改变当前循环的值，返回一个新的被改变过值之后的数组（map需return）<br>接收一个方法，该方法可传入三个参数，第一个为数组的一个元素，第二位为该元素的下标，第三个为原数组</p></blockquote><p><strong>一般用来处理需要修改某一个数组的值</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> newArr= arr.map(<span class="function">(<span class="params">value, index, array</span>)=&gt;</span>value*<span class="number">10</span>)</span><br><span class="line"><span class="comment">// newArr =&gt; [10, 20, 30, 40, 50, 60]</span></span><br></pre></td></tr></table></figure><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><blockquote><p>forEach遍历方式遍历数组全部元素，利用回调函数对数组进行操作，自动遍历数组.length次，且无法break中途跳出循环，不可控、不支持return操作输出，return只用于控制循环是否跳出当前循环<br>接收一个方法，该方法可传入三个参数，第一个为数组的一个元素，第二位为该元素的下标，第三个为原数组。</p></blockquote><p><strong>循环</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>].forEach(<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">console</span>.log(item))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><blockquote><p>返回 布尔值， true，false，  遍历数组并使用传入参数方法，如果参数方法返回值为false，则继续循环，如果参数方法返回值为true，则终止循环，都不满足为false<br>接收一个方法，该方法可传入三个参数，第一个为数组的一个元素，第二位为该元素的下标，第三个为原数组。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].some(<span class="function"><span class="params">item</span>=&gt;</span>item&gt;<span class="number">3</span>);<span class="comment">//&gt;true</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].some(<span class="function"><span class="params">item</span>=&gt;</span>item&lt;<span class="number">0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><blockquote><p>数组常用的一些方法</p></blockquote><ul><li>[].indexOf(item) =&gt; 半段该元素是否存在，返回下标，否则 -1 <blockquote><p><strong>添加新元素</strong></p></blockquote></li><li>[].push(item) =&gt; 将一个或多个元素加入数组，返回新数组的长度 </li><li>[].unshift(item) =&gt;将一个或多个元素加入到数组的开始位置，原有元素位置自动后移，返回 新数组的长度</li><li>[].splice(start,delCount,item…) =&gt;从start的位置开始向后删除delCount个元素，然后从start的位置开始插入一个或多个新元素 </li></ul><p><strong>删除元素</strong></p><ul><li>[].pop()  =&gt; 删除最后一个元素，并返回该元素 </li><li>[].shift() =&gt; 删除第一个元素，数组元素位置自动前移，返回被删除的元素 </li><li>[].splice(start,delCount) =&gt; 从start的位置开始向后删除delCount个元素 </li></ul><p><strong>数组的合并，截取</strong></p><ul><li>[].slice(start,end) =&gt;  以数组的形式返回数组的一部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素 </li><li>[].concat(array1,array2) =&gt; 将多个数组拼接成一个数组 </li></ul><p><strong>排序</strong></p><ul><li>[].reverse() =&gt; 数组反转 </li><li>[].sort() =&gt; 数组排序，返回数组地址 </li></ul><p><strong>拼接成字符串</strong></p><ul><li>[].join(‘,’) =&gt;  安什么拼接，返回字符串</li></ul><p><strong>根据下标删除元素</strong></p><ul><li>使用<code>splice()</code> 方法，写道 Array的原型链接上</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.del =<span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isNaN</span>(index)||index&gt;<span class="built_in">this</span>.length)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">this</span>.splice(index,<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.del(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//=&gt; [1,2,3,5]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue双向数据绑定原理</title>
      <link href="/archives/e2e1e8ad.html"/>
      <url>/archives/e2e1e8ad.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue数据双向绑定"><a href="#vue数据双向绑定" class="headerlink" title="vue数据双向绑定"></a>vue数据双向绑定</h1><blockquote><p>VUE2.0 双向绑定底层原理  ES5中的 Object.defineProperty</p></blockquote><p><strong>简单实现</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">    姓名： <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> obj=&#123; <span class="attr">name</span>:<span class="string">&#x27;&#x27;</span>&#125;;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> newobj =&#123;...obj&#125;;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Object</span>.defineProperty(obj,<span class="string">&#x27;name&#x27;</span>,&#123;</span></span><br><span class="line">        get()&#123;</span><br><span class="line"><span class="javascript">            <span class="comment">// 返回数据， 不能使用 this.name , 会造成死循环， this指向defineProperties</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 换回一个新值， 将值克隆一份返回</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> newobj.name  </span></span><br><span class="line">        &#125;</span><br><span class="line">        set(value)&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(value === obj.name) <span class="keyword">return</span>;</span></span><br><span class="line">            newobj.name =value;</span><br><span class="line">            observe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">      name.innerHTML = obj.name;</span><br><span class="line">        text.value = obj.name</span><br><span class="line">    &#125;</span><br><span class="line">    observe();</span><br><span class="line"><span class="javascript">    <span class="comment">//text, 监听输入框的值改变，赋予obj，是现实双向绑定</span></span></span><br><span class="line"><span class="javascript">    text.oninput= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      obj.name = <span class="built_in">this</span>.name</span></span><br><span class="line">    &#125;</span><br><span class="line">/*</span><br><span class="line">1. 对原始数据克隆</span><br><span class="line">2. 需要分别给对象中而定每一个属性设置监听</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>VUE 3.0 使用的是 ES6中  Proxy</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> obj=&#123;&#125;;</span></span><br><span class="line"><span class="javascript">obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj,&#123;</span></span><br><span class="line">    get(target,prop)&#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> target[prop]</span></span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, p, value, receiver) &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;set&#x27;</span>);</span></span><br><span class="line">        target[props] = value;</span><br><span class="line">        observe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">   <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">      name.innerHTML = obj.name;</span><br><span class="line">        text.value = obj.name</span><br><span class="line">    &#125;</span><br><span class="line">    observe();</span><br><span class="line"><span class="javascript">    <span class="comment">//text, 监听输入框的值改变，赋予obj，是现实双向绑定</span></span></span><br><span class="line"><span class="javascript">    text.oninput= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      obj.name = <span class="built_in">this</span>.name</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="订阅者和发布者模式"><a href="#订阅者和发布者模式" class="headerlink" title="订阅者和发布者模式"></a>订阅者和发布者模式</h2><blockquote><p>订阅者向消息队列中，订阅消息， 发布者只要发布到队列中，就会被订阅者收到<br>如何实现： </p><ol><li>初始化，发布者，订阅者</li><li>订阅者需要注册到发布者，发布者发布消息的时候，依次向订阅者发布消息</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的题（1）</title>
      <link href="/archives/35f01edd.html"/>
      <url>/archives/35f01edd.html</url>
      
        <content type="html"><![CDATA[<h1 id="掌握几大今典布局方案"><a href="#掌握几大今典布局方案" class="headerlink" title="掌握几大今典布局方案"></a>掌握几大今典布局方案</h1><blockquote><p>圣杯布局<br>双飞翼布局<br>  ==&gt; 左右固定，中间自适应</p></blockquote><p><strong>圣杯布局：浮动和负MARGIN</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="对象（数组）的深拷贝和浅拷贝"><a href="#对象（数组）的深拷贝和浅拷贝" class="headerlink" title="对象（数组）的深拷贝和浅拷贝"></a>对象（数组）的深拷贝和浅拷贝</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123; </span><br><span class="line">    a:<span class="number">100</span>,</span><br><span class="line">    b:[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>],</span><br><span class="line">    c:&#123;<span class="attr">x</span>:<span class="number">10</span>&#125;,</span><br><span class="line">    d:<span class="regexp">/^\d+$/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arrr =[<span class="number">10</span>,[<span class="number">100</span>,<span class="number">200</span>],&#123;<span class="attr">x</span>:<span class="number">10</span>,<span class="attr">y</span>:<span class="number">20</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="堆栈内存的问题"><a href="#堆栈内存的问题" class="headerlink" title="堆栈内存的问题"></a>堆栈内存的问题</h1><h3 id="题一"><a href="#题一" class="headerlink" title="题一"></a>题一</h3><figure class="highlight javascript"><figcaption><span>1.8</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;&#125;,</span><br><span class="line">    b=<span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    c=<span class="number">0</span>;</span><br><span class="line">a[b]=<span class="string">&#x27;one&#x27;</span>;</span><br><span class="line">a[c]=<span class="string">&#x27;two&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[b])  <span class="comment">// ==&gt; two</span></span><br><span class="line"><span class="comment">// &gt; 对象key 不能重复， 字符串属性名和数字相等， value 被替换掉了</span></span><br><span class="line"><span class="comment">// ==&gt; 对象和数组的区别？</span></span><br></pre></td></tr></table></figure><blockquote><p>堆，存储引用值内存空间， 没顺序<br>栈，存储基本类型值和指定代码环境 ， 有顺序</p></blockquote><h3 id="题二"><a href="#题二" class="headerlink" title="题二"></a>题二</h3><figure class="highlight javascript"><figcaption><span>1.8</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;&#125;,</span><br><span class="line">    b=<span class="built_in">Symbol</span>(<span class="string">&#x27;0&#x27;</span>),</span><br><span class="line">    c=<span class="built_in">Symbol</span>(<span class="number">0</span>);</span><br><span class="line">a[b]=<span class="string">&#x27;one&#x27;</span>;</span><br><span class="line">a[c]=<span class="string">&#x27;two&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[b])  <span class="comment">// ==&gt; one</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol 创建的是 唯一的值， b和c的 值不相等</span></span><br><span class="line"><span class="comment">// 如何实现 Symbol</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="题三"><a href="#题三" class="headerlink" title="题三"></a>题三</h3><figure class="highlight javascript"><figcaption><span>1.8</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;&#125;,</span><br><span class="line">    b=&#123;<span class="attr">n</span>:<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">    c=&#123;<span class="attr">m</span>:<span class="string">&#x27;2&#x27;</span>&#125;;</span><br><span class="line">a[b]=<span class="string">&#x27;one&#x27;</span>;</span><br><span class="line">a[c]=<span class="string">&#x27;two&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[b])  <span class="comment">// ==&gt; two</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a[b],a[c] =&gt; [&#x27;object object&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==》 Object.prototype.toString /valueOf</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>1.8</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          alert(i*<span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(<span class="number">2</span>)</span><br><span class="line">    test(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; &#x27;4&#x27; </span></span><br></pre></td></tr></table></figure><h2 id="深拷贝-简单实现方式"><a href="#深拷贝-简单实现方式" class="headerlink" title="深拷贝 简单实现方式"></a>深拷贝 简单实现方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123; </span><br><span class="line">    <span class="comment">// 先判断一些类型，重新new对象生产新的地址空间</span></span><br><span class="line">    <span class="keyword">if</span>(obj ===<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> ) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);   </span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span>  <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">    <span class="comment">// = 不直接创建空对象目的， 克隆的结果和之前保持相同的所有类</span></span><br><span class="line">    <span class="keyword">let</span> newObj = <span class="keyword">new</span>  obj.constructor</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">        newObj[key] = deepClone(obj[key])    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>)&#123;</span><br><span class="line">    consple.log(<span class="string">&#x27;条件成立&#x27;</span>)    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>对象==字符串， 对象.toString() 变成字符串<br>null==undefined 相等，但是和其它值比较就不在相等<br>NaN == NaN 不相等，和其它都不想等<br>剩下的都转成为数字比较</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> a=&#123;</span><br><span class="line">    i:<span class="number">0</span>,</span><br><span class="line"> <span class="comment">// 每次调用前都会调用toString ，</span></span><br><span class="line">    <span class="comment">// toString</span></span><br><span class="line">     valueOf()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> ++<span class="built_in">this</span>.i    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.toString=a.shift()</span><br></pre></td></tr></table></figure><blockquote><p>采用数据劫持来实现， </p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( <span class="built_in">window</span>,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">    <span class="comment">//defineProperty geter 不能再次获取当前属性，‘a’ ，会溢出报错</span></span><br><span class="line">    <span class="keyword">return</span> i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>实现上面的方式，思维方式，， 1. 就是变成字符串比较， 2. 采用数据劫持方式，。  方式很多</p></blockquote><h2 id="let和var"><a href="#let和var" class="headerlink" title="let和var"></a>let和var</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age =<span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> years =<span class="number">6</span>;</span><br><span class="line"><span class="keyword">if</span> (age&gt;<span class="number">12</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> age =<span class="number">10</span>;</span><br><span class="line">     <span class="keyword">var</span> years=age*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 输出什么=&gt; Uncaught SyntaxError: Identifier &#x27;years&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
            <tag> css </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React(学习一)</title>
      <link href="/archives/926d3aa6.html"/>
      <url>/archives/926d3aa6.html</url>
      
        <content type="html"><![CDATA[<h2 id="组件化方面"><a href="#组件化方面" class="headerlink" title="组件化方面"></a>组件化方面</h2><ol><li><p>什么是模块化：从 <strong>代码</strong> 的角度，去分析问题，把我们编程时候的业务逻辑，分割到不同的模块中来进行开发，这样能够<strong>方便代码的重用</strong>；</p></li><li><p>什么是组件化：从 <strong>UI</strong> 的角度，去分析问题，把一个页面，拆分为一些互不相干的小组件，随着我们项目的开发，我们手里的组件会越来越多，最后，我们如果要实现一个页面，可能直接把现有的组件拿过来进行拼接，就能快速得到一个完整的页面， 这样方<strong>便了UI元素的重用</strong>；<strong>组件是元素的集合体</strong>；</p></li><li><p>组件化的好处：</p></li><li><p>Vue是如何实现组件化的：.vue 组件模板文件，浏览器不识别这样的.vue文件，所以，在运行前，会把 .vue 预先编译成真正的组件；</p><ul><li>template： UI结构</li><li>script： 业务逻辑和数据</li><li>style： UI的样式</li></ul></li><li><p><code>React</code>如何实现组件化：在React中实现组件化的时候，根本没有 像 .vue 这样的模板文件，而是，直接使用JS代码的形式，去创建任何你想要的组件；</p><ul><li><code>React</code>中的组件，都是直接在 <code>js</code> 文件中定义的；</li><li><code>React</code>的组件，并没有把一个组件 拆分为 三部分（结构、样式、业务逻辑），而是全部使用JS来实现一个组件的；（也就是说：结构、样式、业务逻辑是混合在JS里面一起编写出来的）</li></ul></li></ol><a id="more"></a><h3 id="开发团队方面"><a href="#开发团队方面" class="headerlink" title="开发团队方面"></a>开发团队方面</h3><ul><li>React是由FaceBook前端官方团队进行维护和更新的；因此，<code>React</code>的维护开发团队，技术实力比较雄厚；</li><li>Vue：第一版，主要是有作者 尤雨溪 专门进行维护的，当 Vue更新到 2.x 版本后，也有了一个小团队进行相关的维护和开发；</li></ul><h3 id="社区方面"><a href="#社区方面" class="headerlink" title="社区方面"></a>社区方面</h3><ul><li>在社区方面，React由于诞生的较早，所以社区比较强大，一些常见的问题、坑、最优解决方案，文档、博客在社区中都是可以很方便就能找到的；</li><li>Vue是近两年才诞生开源出来的，所以，它的社区相对于React来说，要小巧一些，所以，可能有的一些坑，没人踩过；</li></ul><h3 id="移动APP开发体验方面"><a href="#移动APP开发体验方面" class="headerlink" title="移动APP开发体验方面"></a>移动APP开发体验方面</h3><ul><li>Vue，结合 <code>Weex</code> 这门技术，提供了 迁移到 移动端App开发的体验（<code>Weex</code>，目前只是一个 小的玩具， 并没有很成功的 大案例；）</li><li>React，结合 <code>ReactNative</code>，也提供了无缝迁移到 移动App的开发体验（<code>RN</code>用的最多，也是最火最流行的）；</li></ul><h2 id="React中的核心概念"><a href="#React中的核心概念" class="headerlink" title="React中的核心概念"></a>React中的核心概念</h2><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><ul><li><p>DOM： 用js表示的ui元素， 是由js提供的功能， 所以我们只能人为的使用 浏览器提供的固定的API来操作DOM对象；</p></li><li><p>虚拟DOM: 并不是由浏览器提供的，而是我们程序员手动模拟实现的，类似于浏览器中的DOM，但是有着本质的区别；</p></li><li><p>虚拟DOM的本质： 就是使用js对象来模拟DOM树，</p></li><li><p>目的： 为了实现DOM节点的搞笑更新：</p></li></ul><h3 id="DIff算法"><a href="#DIff算法" class="headerlink" title="DIff算法"></a>DIff算法</h3><p><img src="/images/react/Diff.png"></p><ul><li>tree diff:新旧DOM树，逐层对比的方式，就叫做 tree diff,每当我们从前到后，把所有层的节点对比完后，必然能够找到那些 需要被更新的元素；</li><li>component diff：在对比每一层的时候，组件之间的对比，叫做 component diff;当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换到被移除的位置；</li><li>element diff:在组件中，每个元素之间也要进行对比，那么，元素级别的对比，叫做 element diff；</li><li>key：key这个属性，可以把 页面上的 DOM节点 和 虚拟DOM中的对象，做一层关联关系；</li></ul><h3 id="react项目创建"><a href="#react项目创建" class="headerlink" title="react项目创建"></a>react项目创建</h3><h3 id="有状态组件和无状态组件"><a href="#有状态组件和无状态组件" class="headerlink" title="有状态组件和无状态组件"></a>有状态组件和无状态组件</h3><blockquote><p>function 创建的组件是 无状态组件， class 创建的组件是有状态组件</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中类的使用</title>
      <link href="/archives/bec7cdca.html"/>
      <url>/archives/bec7cdca.html</url>
      
        <content type="html"><![CDATA[<h2 id="类的原理"><a href="#类的原理" class="headerlink" title="类的原理"></a>类的原理</h2><blockquote><p>在面向对象编程中，类（class）是对象（object）的模板，定义了同一组对象（又称”实例”）共有的属性和方法。<br>Javascript语言不支持”类”，但是可以用一些变通的方法，模拟出”类”。<br>在 javaScript中， 类的所有实例对象都是从通一个原型对象上继承属性，因此，原型对象是类的核心</p></blockquote><a id="more"></a><h2 id="原型链类的继承"><a href="#原型链类的继承" class="headerlink" title="原型链类的继承"></a>原型链类的继承</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包-生成器-迭代器</title>
      <link href="/archives/e8c457c6.html"/>
      <url>/archives/e8c457c6.html</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript-中闭包的理解"><a href="#JavaScript-中闭包的理解" class="headerlink" title="JavaScript 中闭包的理解"></a>JavaScript 中闭包的理解</h2><blockquote><p>知识点的总结，也是一种好的表达方式，也能更好的理解</p></blockquote><p>什么是闭包:</p><blockquote><p>函数对象通过作用域链相互关联起来， 函数体内部的变量都可以保存在函数作用域内，这种特征就叫 <strong>闭包</strong><br>最常见方式，就是 一个函数嵌套另一个函数，内部函数引用外部函数的局部变量<br>优点：<br>  延长外部函数局部变量的声明周期<br>缺点：<br>  容易造成 内存泄漏</p></blockquote><blockquote><p>javascript闭包简单实现</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        a =  a+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br><span class="line">res =func1()</span><br><span class="line"><span class="built_in">console</span>.log(res()) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(res()) <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>闭包的作用域链包含着它自己的作用域，以及包含它的函数的作用域和全局作用域。</p><blockquote><p>通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。</p></blockquote><blockquote><p>在javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收； <br>如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。<br>闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是某个特殊的变量。</p></blockquote><a id="more"></a><h2 id="闭包实现节流，和防抖"><a href="#闭包实现节流，和防抖" class="headerlink" title="闭包实现节流，和防抖"></a>闭包实现节流，和防抖</h2><blockquote><p>规定时间内 触发, 节流函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 记入上一次杉树触发时间</span></span><br><span class="line">    <span class="keyword">let</span> lastTime =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> nowTIME= <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span> (nowTIME-lastTime &gt;delay)&#123;</span><br><span class="line">            fn.call(<span class="built_in">this</span>); <span class="comment">// 修正this指向问题</span></span><br><span class="line">            <span class="comment">// fn()</span></span><br><span class="line">            lastTime=nowTIME</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>防抖函数, 一个需要频繁触发的函数,在规定时间内,只让最后一次生效,前面不生效</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,date</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 初始 记入上一次延时器</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 清楚上一次延时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="comment">// 重新设置新的延时器</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>)  <span class="comment">// 修正this指向</span></span><br><span class="line">        &#125;,date)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包中常见题型"><a href="#闭包中常见题型" class="headerlink" title="闭包中常见题型"></a>闭包中常见题型</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n,o</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(o)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        fun:<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fun(m,n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = fun(<span class="number">0</span>) <span class="comment">// undefinde,</span></span><br><span class="line"></span><br><span class="line">a.fun(<span class="number">1</span>) <span class="comment">// 0</span></span><br><span class="line">a.fun(<span class="number">2</span>) <span class="comment">//0</span></span><br><span class="line">a.fun(<span class="number">3</span>) <span class="comment">//0</span></span><br><span class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>).fun(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// undefinde,0,1,2,3</span></span><br><span class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>) <span class="comment">// undefinde,0</span></span><br><span class="line">c.fun(<span class="number">2</span>) <span class="comment">//1</span></span><br><span class="line">c.fun(<span class="number">3</span>) <span class="comment">//1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i++)    </span><br><span class="line">&#125;,<span class="number">4000</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">// 5,  5,6,7,8,9  i=10</span></span><br><span class="line"><span class="comment">// setTimeout是异步操作，会将任务管理起来，执行， 等待4秒后会直接执行所有</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">   (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x++)    </span><br><span class="line">        &#125;,<span class="number">4000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)<span class="comment">// 5, 0,1,2,3,4,5  i=5</span></span><br></pre></td></tr></table></figure><h2 id="Python，中闭包"><a href="#Python，中闭包" class="headerlink" title="Python，中闭包"></a>Python，中闭包</h2><blockquote><p>实现一个闭包</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">        <span class="comment"># nonloacal a</span></span><br><span class="line">        a = a+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">return</span> func2</span><br><span class="line">func1()()  <span class="comment"># 直接报错，local variable &#x27;a&#x27; referenced before assignment</span></span><br></pre></td></tr></table></figure><blockquote><p>这是应为python规定所有在赋值语句左面的变量都是局部变量，这个a在等号左边，所以成了一个局部的变量，导致我访问不到func1中的a<br>可使用 <code>nonloacal</code> 来指定变量a， 不为局部变量再在py3版本中， 即使这条它输入的结果跟js也是不一样的， 返回的结果始终是 2<br>这是应为python中 存在可变类型和不可变类型，<br><strong>不可变类型</strong> 在第一次声明赋值声明的时候, 会在内存中开辟一块空间, 用来存放这个变量被赋的值,  而这个变量实际上存储的, 并不是被赋予的这个值, 而是存放这个值所在空间的内存地址, 通过这个地址, 变量就可以在内存中取出数据了. 所谓不可变就是说, 我们不能改变这个数据在内存中的值, 所以当我们改变这个变量的赋值时, 只是在内存中重新开辟了一块空间, 将这一条新的数据存放在这一个新的内存地址里, 而原来的那个变量就不在引用原数据的内存地址而转为引用新数据的内存地址了.<br><strong>可变类型</strong> 结合不可变类类型，可变数据类型是指变量所指向的内存地址处的值是可以被改变的。</p></blockquote><h2 id="Python-装饰器"><a href="#Python-装饰器" class="headerlink" title="Python 装饰器"></a>Python 装饰器</h2><p>开发中经常会用到装饰器，减少重复写代码, 做验证判断机制，就时一个闭包，把一个函数当做参数然后返回一个替代版函数</p><blockquote><p>1.定义：函数装饰器用于标记函数，增强函数的行为。装饰器本身是可调用的对象，它的参数是另一个被装饰的函数。<br>2.装饰方法：可能会处理被装饰的函数，然后把他返回。或者将其替换成另一个函数或者可调用对象</p></blockquote><blockquote><p>函数装饰器 </p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logg</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment"># *args,**kwargs 是 func函数所携带参数， name...</span></span><br><span class="line">        print(func.__name__,*args,**kwargs) <span class="comment"># 传递进来的 函数</span></span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs)  <span class="comment">## 返回结果，</span></span><br><span class="line">    <span class="keyword">return</span> wrapper </span><br><span class="line"><span class="meta">@logg</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="meta">@logg</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">par</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&quot;par&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>带参数的装饰器, 再嵌套一个函数</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lg</span>(<span class="params">level</span>):</span></span><br><span class="line">    <span class="comment"># level 装饰器参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">&#x27;info&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"><span class="meta">@lg(&#x27;info&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;正常输入&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>装饰器常用来实现的小案例</p></blockquote><ol><li>时间计时器</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        t1=time.time()</span><br><span class="line">        <span class="comment"># 这是函数真正执行的地方</span></span><br><span class="line">        func(*args, **kw)</span><br><span class="line">        t2=time.time()</span><br><span class="line">        <span class="comment"># 计算下时长</span></span><br><span class="line">        cost_time = t2-t1 </span><br><span class="line">        print(<span class="string">&quot;花费时间：&#123;&#125;秒&quot;</span>.format(cost_time))</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>在开发很少会用到类装饰，但是再一些别的源码中会见到</p><blockquote><p>类装饰器， 使用 <code>__call__</code> <code>__init__</code> 内置函数来实现</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">loger</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,func</span>):</span></span><br><span class="line">        self.func = func</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;正在运行的函数是：&#x27;</span>,self.func.__name__)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"><span class="meta">@loger</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">hap</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;hi &#123;&#125;&#x27;</span>.format(hap))</span><br></pre></td></tr></table></figure><blockquote><p>带参数的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中Promise的用法</title>
      <link href="/archives/1e9fa2d1.html"/>
      <url>/archives/1e9fa2d1.html</url>
      
        <content type="html"><![CDATA[<h2 id="Promise-的定义"><a href="#Promise-的定义" class="headerlink" title="Promise 的定义"></a>Promise 的定义</h2><p><code>Promise</code> 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，<code>ES6</code> 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。<br>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。<code>Promise</code> 提供统一的 <code>API</code>，各种异步操作都可以用同样的方法进行处理。<br><code>Promise</code>对象有以下两个特点。<br>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。<br>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为 <code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 <code>resolved</code>（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（<code>Event</code>）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><blockquote><p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p></blockquote><h2 id="Promise缺点。"><a href="#Promise缺点。" class="headerlink" title="Promise缺点。"></a>Promise缺点。</h2><blockquote><ol><li>无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。</li><li>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ol></blockquote><a id="more"></a><h2 id="Promise-的用法"><a href="#Promise-的用法" class="headerlink" title="Promise 的用法"></a>Promise 的用法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> status = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (status) &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;操作成功!&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;操作失败!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;成功结果：&#x27;</span> + res);</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;失败结果：&#x27;</span> + error);</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 <code>JavaScript</code> 引擎提供，不用自己部署</p><blockquote><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”<br><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code> 变为 <code>rejected</code>）<br>在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p></blockquote><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。<br><code>then</code>方法可以接受两个回调函数作为参数。</p><blockquote><p>第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，<br>第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。(可选)</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;new Promise()&#x27;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve()&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;End&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">//new Promise()</span></span><br><span class="line"><span class="comment">// End</span></span><br><span class="line"><span class="comment">// resolve()</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise</code> 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p><code>Promise</code> 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise</code>.<code>prototype</code>上的。它的作用是为 <code>Promise</code> 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p><blockquote><p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;成功返回&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// 成功返回</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>then方法的基础调用写法，可以写一个回调方法，来执行成功后的回调。then方法返回一个的是一个新的Promise实例，因此我们可以采用链式写法，即then方法后面再调用一个then方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;成功返回&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> res <span class="comment">// 成功返回</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>res).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(res)&#125;)<span class="comment">// 成功返回</span></span><br></pre></td></tr></table></figure><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><blockquote><p>发生错误的回调函数,<br><code>Promise</code>实例当状态改变为<code>rejected</code>状态或者操作失败抛出异常错误，就会被<code>catch</code>方法捕获。所以在<code>Promise</code>实例中<code>reject</code>方法等同于抛出错误。如果<code>Promise</code>的状态已经变成了<code>resolved</code>，再抛出错误无效</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error); <span class="comment">// 失败</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>); <span class="comment">// 这行无效</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error); <span class="comment">// 失败</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise的finally方法"><a href="#Promise的finally方法" class="headerlink" title="Promise的finally方法"></a>Promise的finally方法</h3><blockquote><p>不管<code>Promise</code>最后状态如何，都会回调执行</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&#125;).finally(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;finally&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise的all方法"><a href="#Promise的all方法" class="headerlink" title="Promise的all方法"></a>Promise的all方法</h3><blockquote><p><code>Promise.all</code>方法用于将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例。在<code>all</code>方法中可以传递多个<code>Promise</code>对象，当所有的Promise对象状态都返回<code>fufilled</code>，才会返回<code>fulfilled</code>，否则返回<code>rejected</code>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promiseAll = <span class="built_in">Promise</span>.all([promise1, promise2, promise3]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;all&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Promise的race方法"><a href="#Promise的race方法" class="headerlink" title="Promise的race方法"></a>Promise的race方法</h3><blockquote><p>和<code>all</code> 差不多， 只是， <strong>只要有一个有一个实例率先改变状态，那么race的状态就会跟着改变</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseRace = <span class="built_in">Promise</span>.race([promise1, promise2, promise3]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;race then&#x27;</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;race catch&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://es6.ruanyifeng.com/#docs/promise#Promise-all">ECM6</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的网站工具收藏</title>
      <link href="/archives/ee063036.html"/>
      <url>/archives/ee063036.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/tool/yc.jpg" alt="帅气的亚索"></p><blockquote><p>整理一些自己经常用到的一些好的网站… 方便自己使用<br>有些插件工具用法会单独篇章在慢慢简介…<br><strong>持续增加…</strong></p></blockquote><blockquote><p><a href="https://tool.lu/">在线工具箱</a></p></blockquote><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><blockquote><p>css,html</p></blockquote><ol><li><a href="http://www.icosky.com/">图标之家</a></li><li><a href="https://www.iconfont.cn/">阿里字体图标库</a></li><li><a href="https://icomoon.io/">icomoon图库</a></li><li><a href="https://webgradients.com/">css渐变色</a></li><li><a href="http://www.animate.net.cn/">Animate.css 动画效果框架</a>, 在线CND<a href="https://unpkg.com/animate.css@3.5.2/animate.min.css">https://unpkg.com/animate.css@3.5.2/animate.min.css</a></li><li><a href="https://lbs.amap.com/api/amap-ui/demos/amap-ui-districtexplorer/index">高德地图api ui组件</a></li><li><a href="https://www.w3school.com.cn/tiy/t.asp?f=hdom_window_scrollby">W3school在线测试</a></li><li><a href="https://colorhunt.co/">colorhunt配色</a><a id="more"></a><blockquote><p>js,jQ</p></blockquote></li></ol><ul><li><a href="http://jquery.cuishifeng.cn/">JQuery文档</a></li><li><a href="http://www.jq22.com/">jQ插件</a></li></ul><blockquote><p>vue组件库</p></blockquote><ol><li><a href="https://element.eleme.cn/#/zh-CN">Element-UI</a></li></ol><blockquote><p>移动端组件库</p></blockquote><ol><li><a href="https://www.color-ui.com/">color-ui</a>, <a href="https://github.com/weilanwl/ColorUI/">Github</a></li></ol><blockquote><p>当你词穷,不知道怎么取变量名时</p></blockquote><ol><li><a href="https://unbug.github.io/">CODELF</a></li></ol><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li><a href="https://docs.python.org/">python文档</a></li><li><a href="https://studygolang.com/pkgdoc">Go文档</a></li><li><a href="https://es6.ruanyifeng.com/#README">ES6入门教程</a></li></ul><blockquote><p>刷题网</p></blockquote><p><a href="https://leetcode-cn.com/">力扣</a><br><a href="https://www.nowcoder.com/">牛客</a></p><blockquote><p>demo编程<br><a href="https://codehs.com/editor/sandbox/explore">Code HS</a></p></blockquote><h2 id="社区交流"><a href="#社区交流" class="headerlink" title="社区交流"></a>社区交流</h2><ol><li><a href="https://bbs.nightteam.cn/">夜幕爬虫论坛</a></li><li><a href="https://hacpai.com/">黑客派</a></li><li><a href="https://www.52pojie.cn/">吾爱破解</a></li><li><a href="https://juejin.im/welcome/frontend">掘金论坛</a></li><li><a href="https://stackoverflow.com/">stackoverflow</a></li></ol><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><h2 id="图库"><a href="#图库" class="headerlink" title="图库"></a>图库</h2><ol><li><a href="http://moe.005.tv/">萌娘动漫图库</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抓包工具的使用</title>
      <link href="/archives/4fbf257c.html"/>
      <url>/archives/4fbf257c.html</url>
      
        <content type="html"><![CDATA[<h2 id="Charles工具使用"><a href="#Charles工具使用" class="headerlink" title="Charles工具使用"></a>Charles工具使用</h2><ol><li><a href="https://www.charlesproxy.com/download/">Charles下载</a></li><li>配置抓https请求包<br><img src="/images/tool/crawler1.jpg"></li><li>点击安装证书，<code>本地计算机-将所有证书都到到-受信用的根证书烦发机构</code> 点击确定</li><li>设置 ssl 拦截配置 <code>Proxy-ssl Proxy Settings... </code> 点击，  勾选 <code>Enable SSL Proxying</code><br>再点击下面 Add 添加， 设置 *  即可， 全部拦截<br><img src="/images/tool/crawler2.png"></li></ol><h2 id="拦截抓包"><a href="#拦截抓包" class="headerlink" title="拦截抓包"></a>拦截抓包</h2><ol><li>通过使用测试请求的web工具 <a href="http://httpbin.org/">http://httpbin.org/</a> 发送请求</li></ol><h2 id="过滤请求"><a href="#过滤请求" class="headerlink" title="过滤请求"></a>过滤请求</h2><ol><li>通过设置 左下角的Filter: httpbin.org 来过滤请求</li><li>或者右键请求， 选择 Focus, </li></ol><h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><ol><li>通过 <code>Proxy- Breakpoint Sett...</code> 来设置请求的url断点<br><img src="/images/tool/cra3.png"></li></ol><a id="more"></a><p><strong>待续…</strong></p><h2 id="EditThisCookie-使用"><a href="#EditThisCookie-使用" class="headerlink" title="EditThisCookie 使用"></a>EditThisCookie 使用</h2><p>该插件就是方便 调试和管理 cookie，严重过期，参数， 导入导出，方便调试</p><ol><li>谷歌商店 搜索 <code>EditThisCookie</code> 小饼干图型的，安装即可</li></ol><h2 id="Toggle-JavaScript-插件"><a href="#Toggle-JavaScript-插件" class="headerlink" title="Toggle JavaScript 插件"></a>Toggle JavaScript 插件</h2><p>该插件主要是， 方便失败，有没有使用javaScript渲染，<br>渲染开关… 方便快速判断，</p><h2 id="Tampermonkey-插件"><a href="#Tampermonkey-插件" class="headerlink" title="Tampermonkey 插件"></a>Tampermonkey 插件</h2><video src="" width="100%"  controls="controls">Your browser does not support the video tag.</video>- 获取脚本- 管理面板<p><strong>待续…</strong></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中this的指向</title>
      <link href="/archives/c3ed0128.html"/>
      <url>/archives/c3ed0128.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在JavaScript 中，函数的 this 指向比较复杂多变。它和你调用的方式有关系，和 <strong>严格模式</strong> 或者 <strong>非严格模式</strong> 有关系，和你是否使用了箭头函数有关系，和你在使用函数时是否传入了 this 有关系，和你是否主动修改了调用对象有关系。</p></p></blockquote><ul><li>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值。<code>this</code> 不能再执行期间被赋值，并且在每次函数被调用时 <code>this</code> 的值也可能会不同。</li><li>与其他语言相比，<strong>函数的 <code>this</code> 关键字</strong>在 <code>JavaScript</code> 中的表现略有不同，此外，在 严格模式 和 非严格模式之间也会有一些差别。</li><li><code>this</code> 的值指向，取决于函数被调用的方式</li></ul><h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）<code>this</code> 都指代全局对象。【在全局执行上下文中 <code>this</code> 都是全局对象 <code>window</code>】（浏览器环境）</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);    <span class="comment">// window</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.a);  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);    <span class="comment">// window</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.b);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数内部，<code>this</code> 的值取决于函数被调用的方式。【取决于被调用的方式】</p><h3 id="简单调用"><a href="#简单调用" class="headerlink" title="简单调用"></a>简单调用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line">f1() === <span class="built_in">window</span>;  <span class="comment">// 在浏览器中，全局对象是widnow</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Node 中</span></span><br><span class="line">f1() === <span class="built_in">global</span>;</span><br></pre></td></tr></table></figure><p>【在严格模式下，<code>this</code> 将保持他进入执行上下文时的值】</p><p>在严格模式下，<code>this</code> 将保持他进入执行上下文时的值，所以下面的 <code>this</code> 将会默认为 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>; <span class="comment">// 这里是严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">f2() === <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以，在严格模式下，如果 <code>this</code> 没有被执行上下文（execution context）定义，那它将保持为 <code>undefined</code>。</p><p>因为 <code>f2()</code> 是被直接调用的，而不是作为对象的属性或方法调用的（如<code>window.f2()</code>）。有一些浏览器最初在支持严格模式时没有正确实现这个功能，于是它们错误的返回了 <code>window</code> 对象。</p><p>但是，如果用 <code>window</code> 来调用的话，<code>this</code> 就是 <code>window</code> 了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>; <span class="comment">// 这里是严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.f2())  <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>如果要想把 <code>this</code> 的值从一个上下文传到另一个，就要用 <code>call</code> 或者 <code>apply</code> 方法。</p><p>当一个函数在其主体中使用 <code>this</code> 关键字时，可以通过使用函数继承自 <code>Function.prototype</code> 的 <code>call</code> 或 <code>apply</code> 方法将 <code>this</code> 值绑定到调用中的特定对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是作为‘this’使用的对象</span></span><br><span class="line"><span class="comment">// 后续参数作为参数传递给函数调用</span></span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 1 + 3 + 5 + 7 = 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数也是作为‘this’使用的对象</span></span><br><span class="line"><span class="comment">// 第二个参数是一个数组，数组里的元素用作函数调用中的参数</span></span><br><span class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]); <span class="comment">// 1 + 3 + 10 + 20 = 34</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>call</code> 和 <code>apply</code> 函数的时候要注意，如果传递给 <code>this</code> 的值不是一个对象，<code>JavaScript</code> 会尝试使用内部 <code>ToObject</code> 操作将其转换为对象。</p></blockquote><blockquote><blockquote><p>因此，如果传递的值是一个原始值比如 <code>7</code> 或 <code>foo</code>，那么就会使用相关构造函数将它转换为对象，所以原始值 <code>7</code> 会被转为对象，像<br><code>new Number(7)</code> 这样，而字符串 <code>foo</code> 转化成 <code>new String(&#39;foo&#39;)</code> 这样。</p></blockquote></blockquote><h2 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h2><p><code>ECMAScript 5</code> 引入了 <code>Function.prototype.bind</code>。调用 <code>f.bind(someObject)</code> 会 <strong>创建</strong>一个与 <code>f</code> 具有相同函数体和作用域的函数，但是在这个新函数中，<code>this</code> 将永久地被绑定到了 <code>bind</code> 的第一个参数，无论这个函数是如何被调用的。</p><p>【<code>this</code> 将永久的被绑定到了 <code>bind</code> 的第一个参数，无论这个函数是如何被调用的】</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">a</span>:<span class="string">&quot;azerty&quot;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// azerty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h = g.bind(&#123;<span class="attr">a</span>:<span class="string">&#x27;yoo&#x27;</span>&#125;); <span class="comment">// bind只生效一次！</span></span><br><span class="line"><span class="built_in">console</span>.log(h()); <span class="comment">// azerty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">37</span>, <span class="attr">f</span>:f, <span class="attr">g</span>:g, <span class="attr">h</span>:h&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.f(), o.g(), o.h()); <span class="comment">// 37, azerty, azerty</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>在箭头函数中，<code>this</code> 与封闭词法上下文的 <code>this</code> 保持一致。在全局代码中，它将被设置为全局对象。【封闭词法上下文 是什么意思，你知道吗？】</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function">() =&gt;</span> <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着上面的代码</span></span><br><span class="line"><span class="comment">// 作为对象的一个方法调用</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>: foo&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.foo() === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试使用call来设定this</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.call(obj) === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试使用bind来设定this</span></span><br><span class="line">foo = foo.bind(obj);</span><br><span class="line"><span class="built_in">console</span>.log(foo() === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>【无论如何，<code>foo</code> 的 <code>this</code> 被设置为<strong>他被创建时的上下文</strong>（在上面的例子中，就是全局对象）】<br>这同样适用于在其他函数内创建的箭头函数：这些箭头函数的 <code>this</code> 被设置为封闭的词法上下文的。</p><h2 id="作为对象的方法"><a href="#作为对象的方法" class="headerlink" title="作为对象的方法"></a>作为对象的方法</h2><blockquote><p>当函数作为对象里的方法被调用时，它们的 <code>this</code> 是调用该函数的对象</p></blockquote><p><code>this</code> 的绑定只受最靠近的成员引用的影响。在下面的例子中，我们把一个方法 <code>g</code> 当做对象 <code>o.b</code> 的函数调用。在这次执行期间，函数中的 <code>this</code> 将指向 <code>o.b</code> 。事实证明，这与他是对象 <code>o</code> 的成员没有多大关系，最靠近的引用才是最重要的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">o.b = &#123; <span class="attr">g</span>: independent, <span class="attr">prop</span>: <span class="number">42</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(o.b.g())</span><br></pre></td></tr></table></figure><h2 id="原型链中的-this"><a href="#原型链中的-this" class="headerlink" title="原型链中的 this"></a>原型链中的 <code>this</code></h2><p>对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么 <code>this</code> 指向的是调用这个方法的对象，就像该方法在对象上一样。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.f()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>在这个例子中，对象 <code>p</code> 没有属于它自己的 <code>f</code> 属性，它的 <code>f</code> 属性继承自它的原型。虽然在对 <code>f</code> 的查找过程中，最终是在 <code>o</code> 中找到 <code>f</code> 属性的，这并没有关系；查找过程首先从 <code>p.f</code> 的引用开始，所以函数中的 <code>this</code> 指向 <code>p</code>。也就是说，因为 <code>f</code> 是作为 <code>p</code> 的方法调用的，所以它的 <code>this</code> 指向了 <code>p</code> 。这是 <code>JavaScript</code> 的原型继承中的一个有趣的特性。</p><h2 id="作为构造函数"><a href="#作为构造函数" class="headerlink" title="作为构造函数"></a>作为构造函数</h2><p>当一个函数用作构造函数时（适用 <code>new</code> 关键字），它的 <code>this</code> 被绑定到正在构造的新对象。</p><p>虽然构造器返回的默认值是 <code>this</code> 所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回 <code>this</code> 对象）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  构造函数这样工作:</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> function MyConstructor()&#123;</span></span><br><span class="line"><span class="comment">    函数实体写在这里</span></span><br><span class="line"><span class="comment">    根据需要在this上创建属性，然后赋值给它们，比如：</span></span><br><span class="line"><span class="comment">    this.fum = &quot;nom&quot;;</span></span><br><span class="line"><span class="comment">     等等...</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    如果函数具有返回对象的return语句，</span></span><br><span class="line"><span class="comment">    则该对象将是 new 表达式的结果。 </span></span><br><span class="line"><span class="comment">     否则，表达式的结果是当前绑定到 this 的对象。</span></span><br><span class="line"><span class="comment">    （即通常看到的常见情况）。</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">37</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> C();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 37</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">37</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">a</span>:<span class="number">38</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> C2();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 38</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在刚刚的例子中（C2），因为在调用构造函数的过程中，手动的设置了返回对象，与 <code>this</code> 绑定的默认对象被丢弃了。（这基本上使得语句 <code>this.a = 37;</code> 成了“僵尸”代码，实际上并不是真正的“僵尸”，这条语句执行了，但是对于外部没有任何影响，因此完全可以忽略它）。</p><h2 id="作为一个-DOM-事件处理函数"><a href="#作为一个-DOM-事件处理函数" class="headerlink" title="作为一个 DOM 事件处理函数"></a>作为一个 DOM 事件处理函数</h2><blockquote><p>当函数被用作事件处理函数时，它的 <code>this</code> 指向触发事件的元素（一些浏览器在使用非 <code>addEventListener</code> 的函数动态添加监听函数时不遵守这个约定）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被调用时，将关联的元素变成蓝色</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bluify</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === e.currentTarget); <span class="comment">// 总是 true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 currentTarget 和 target 是同一个对象时为 true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === e.target);        </span><br><span class="line">  <span class="built_in">this</span>.style.backgroundColor = <span class="string">&#x27;#A5D9F3&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文档中的所有元素的列表</span></span><br><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;elements.length ; i++)&#123;</span><br><span class="line">  elements[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, bluify, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="作为一个内联事件处理函数"><a href="#作为一个内联事件处理函数" class="headerlink" title="作为一个内联事件处理函数"></a>作为一个内联事件处理函数</h2><blockquote><p>当代码被内联 <code>on-event</code> 处理函数 调用时，它的 <code>this</code> 指向监听器所在的 <code>DOM</code> 元素</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(this.tagName.toLowerCase());&quot;</span>&gt;</span></span><br><span class="line">  Show this</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的 <code>alert</code> 会显示 <code>button</code> 。注意只有外层代码中的 <code>this</code> 是这样设置的：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert((function()&#123;return this&#125;)());&quot;</span>&gt;</span></span><br><span class="line">  Show inner this</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这种情况下，没有设置内部函数的 <code>this</code>，所以它指向 <code>global/window</code> 对象（即非严格模式下调用的函数未设置 <code>this</code> 时指向的默认对象）。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack常用配置</title>
      <link href="/archives/c36507d3.html"/>
      <url>/archives/c36507d3.html</url>
      
        <content type="html"><![CDATA[<h2 id="webpack创建项目"><a href="#webpack创建项目" class="headerlink" title="webpack创建项目"></a>webpack创建项目</h2><ol><li>项目初始化 npm init （再输入项目）  || npm init -y</li><li>下载包 <code>npm i webpack webpack-cli -D</code> 开发依赖</li></ol><blockquote><p>配置 webpack.config.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    entry: path.join(__dirname,<span class="string">&#x27;./src/main.js&#x27;</span>),  <span class="comment">// 入口文件，要使用webpack打包的文件</span></span><br><span class="line">    output:&#123; <span class="comment">// 输出文件相关的配置</span></span><br><span class="line">        path: path.join(__dirname,<span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">        filenname:<span class="string">&#x27;bundle.js&#x27;</span> <span class="comment">//指定， 输出的文件名称</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devServer:&#123; <span class="comment">// 配置 dev-server命令参数</span></span><br><span class="line">        open:<span class="literal">true</span> ,<span class="comment">// 自动打开浏览器</span></span><br><span class="line">        port: <span class="number">3000</span>,</span><br><span class="line">        contentBase:<span class="string">&#x27;src&#x27;</span>, <span class="comment">// 指定托管的 根目录</span></span><br><span class="line">        hot: <span class="literal">true</span> <span class="comment">// 启动热更新，再在 plugins中 new一下</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[ <span class="comment">// 配置插件的节点</span></span><br><span class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin() <span class="comment">// new 一个热更新的模块        </span></span><br><span class="line">    ],</span><br><span class="line">    <span class="built_in">module</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ol start="3"><li><code>npm i webpack-dev-server</code> 插件 自动打包编译工具（本地必须安装 <code>webpack webpack-cli</code>）,配置 <code>package.json</code> 启动命令</li><li><code>npm i html-webpack-plugin -D</code> 插件 内存中生产html<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --host 页面不刷新更新，--contentBace src 启动文件路径， --open 自动打开， </span></span><br><span class="line"><span class="comment">// webpack-dev-server --open --port 3000 --contentBace src --host</span></span><br><span class="line"><span class="comment">// 第二中，再配置文件中， webpack.config.js 修改</span></span><br><span class="line"><span class="comment">///=》 在  webpack.config.js 配置</span></span><br><span class="line"><span class="comment">// 导入在内存中生产HTML页面的插件</span></span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">// 热更新</span></span><br><span class="line">    <span class="comment">// 自动创建一一个，script引用正确路径</span></span><br><span class="line">    <span class="keyword">new</span> htmlWebpackPlugin(&#123; <span class="comment">// 创建一个 在内存中生成的 html</span></span><br><span class="line">        template:path.join(__dirname,<span class="string">&#x27;./src/index.html&#x27;</span>), <span class="comment">// 指定模板页面，根据指定页面生成内存中</span></span><br><span class="line">        filename:<span class="string">&#x27;index.html&#x27;</span> <span class="comment">// 指定生成页面的名称</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><code>webpack</code> 默认只能初始js文件， 处理不了css， css文件中的url地址，不管图片还是地址库，只要是url地址， 需要安装 <code>loader</code><br> 打包<code>css</code>文件安装 <code>less-loader</code> <code>css-loader</code> <code>style-loader</code><br> <code>cnpm -i node-sass sass-loader</code> 安装<br> <code>npm -i url-loader file-loader</code> css中 url路径的的处理<br><strong>在配置文件 webpack.config.js 中 <code>module</code>配置</strong><br>webpack处理第三方文件类型的过场：</p><ol><li>发现要处理的文件不是js文件，然后就去配置文件中， 查找有没有对应的第三方loader 规则</li><li>如果能倒找对应的规则， 就会调用对应的 loader 处理， 这样文件类型</li><li>在调用loader的时间，是从后往前调用</li><li>当最后一个 loader 调用完毕，会把处理的结果，直接交给webpack进行打包合并，最终输出到js文件</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;  <span class="comment">// 用于配置所有第三方模板，加速器</span></span><br><span class="line">    rules:[ <span class="comment">//所有第三方模板的比配规则， 参数格式和get请求一样</span></span><br><span class="line">    &#123;<span class="attr">test</span>:<span class="regexp">/\.css$/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>]&#125;,    </span><br><span class="line">    &#123;<span class="attr">test</span>:<span class="regexp">/\.less$/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>]&#125;, <span class="comment">// 配置.less文件处理   </span></span><br><span class="line">    &#123;<span class="attr">test</span>:<span class="regexp">/\.scss$/</span>,use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;sass-loader&#x27;</span>]&#125;, <span class="comment">// 配置.less文件处理   </span></span><br><span class="line">    <span class="comment">// limit=8000，参数，给定的值是图片的大小byte，如果图片大于或等于给定的limt值，则不会被转成base64格式字符串，如果小于给定的limit值，则会被转成baser64格式</span></span><br><span class="line">    <span class="comment">// name=[name].[ext], 修改文件名，[name].[ext] 原名和原后缀未修改,[hash:8]截取hash值前8位 </span></span><br><span class="line">    &#123;<span class="attr">test</span>:<span class="regexp">/\.(jpg|png|gif|bmp|jpeg)$/</span>,use:<span class="string">&#x27;url-loader?limit=8000&amp;name=[hash:8]-[name].[ext]&#x27;</span>&#125; <span class="comment">// 处理图片的 路径</span></span><br><span class="line">    &#123;<span class="attr">test</span>:<span class="regexp">/\.(ttf|eot|svg|woff|woff2)$/</span>,use:<span class="string">&#x27;url-loader&#x27;</span>&#125;, <span class="comment">// 处理字体文件</span></span><br><span class="line">    &#123;<span class="attr">test</span>:<span class="regexp">/\.js$/</span>,use:<span class="string">&#x27;babel-loader&#x27;</span>,<span class="attr">exclude</span>:<span class="regexp">/node_modules/</span>&#125; <span class="comment">// ES高级语法转换</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bable的配置"><a href="#bable的配置" class="headerlink" title="bable的配置"></a>bable的配置</h3><blockquote><p>webpack 中 默认只能处理一部分 ES6 的新语法， 一些更高级的ES6或者ES7语言，webpack是处理不了，这时候需要第三方loader，来处理<br>通过 Babel， 可以将高级的语法转成，低级语法<br><code>npm i babel-core babel-loader babel-plugin-transform-runtime -D</code><br><code>npm i babel-preset-env babel-preset-stage-0 -D</code><br> 在配置文件中 配置rules<br>/exclude （过滤掉） 不编译 node_modules 里第三方都是已经编译好了的，如在在编译，消费cpu过大<br><code>&#123;test:/\.js$/,use:&#39;babel-loader&#39;,exclude:/node_modules/&#125;</code><br><strong>在项目根目录，创建 <code>.babelrc</code>配置文件</strong> 这个配置文件属于JSON</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;env&quot;</span>,<span class="string">&quot;stage-0&quot;</span>], <span class="comment">// 语法</span></span><br><span class="line"><span class="string">&quot;plugins&quot;</span>:[<span class="string">&quot;transform-runtime&quot;</span>] <span class="comment">// 安装插件名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>工作中 webpack 的常用配置</p></blockquote><blockquote><p>配置一</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入每次删除文件夹的插件</span></span><br><span class="line"><span class="keyword">const</span> cleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入抽取CSS的插件</span></span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">&quot;extract-text-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="comment">// 导入压缩CSS的插件</span></span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123; <span class="comment">// 配置入口节点</span></span><br><span class="line">    app: path.join(__dirname, <span class="string">&#x27;./src/main.js&#x27;</span>),</span><br><span class="line">    vendors1: [<span class="string">&#x27;jquery&#x27;</span>] <span class="comment">// 把要抽离的第三方包的名称，放到这个数组中</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;js/bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [ <span class="comment">// 插件</span></span><br><span class="line">    <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.join(__dirname, <span class="string">&#x27;./src/index.html&#x27;</span>),</span><br><span class="line">      filename: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 合并多余的空格</span></span><br><span class="line">        removeComments: <span class="literal">true</span>, <span class="comment">// 移除注释</span></span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span> <span class="comment">// 移除 属性上的双引号</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> cleanWebpackPlugin([<span class="string">&#x27;dist&#x27;</span>]),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">&#x27;vendors1&#x27;</span>, <span class="comment">// 指定要抽离的入口名称</span></span><br><span class="line">      filename: <span class="string">&#x27;js/vendors.js&#x27;</span> <span class="comment">// 将来再发布的时候，除了会有一个 bundle.js ，还会多一个 vendors.js 的文件，里面存放了所有的第三方包</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">      compress: &#123; <span class="comment">// 配置压缩选项</span></span><br><span class="line">        warnings: <span class="literal">false</span> <span class="comment">// 移除警告</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.DedupePlugin(&#123; <span class="comment">// 设置为产品上线环境，进一步压缩JS代码</span></span><br><span class="line">      <span class="string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="string">&#x27;&quot;production&quot;&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">&quot;css/styles.css&quot;</span>), <span class="comment">// 抽取CSS文件</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin()<span class="comment">// 压缩CSS的插件</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          use: <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">          publicPath: <span class="string">&#x27;../&#x27;</span> <span class="comment">// 指定抽取的时候，自动为我们的路径加上 ../ 前缀</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>, use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          use: [<span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>],</span><br><span class="line">          publicPath: <span class="string">&#x27;../&#x27;</span> <span class="comment">// 指定抽取的时候，自动为我们的路径加上 ../ 前缀</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|gif|bmp|jpg)$/</span>, use: <span class="string">&#x27;url-loader?limit=5000&amp;name=images/[hash:8]-[name].[ext]&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, use: <span class="string">&#x27;babel-loader&#x27;</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 打包时不生成.map文件</span></span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: <span class="string">&#x27;http://localhost:3000&#x27;</span> <span class="comment">// 代理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置2"><a href="#配置2" class="headerlink" title="配置2"></a>配置2</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">&#x27;./utils&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../config&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> vueLoaderConfig = <span class="built_in">require</span>(<span class="string">&#x27;./vue-loader.conf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, <span class="string">&#x27;..&#x27;</span>, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createLintingRule = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  test: <span class="regexp">/\.(js|vue)$/</span>,</span><br><span class="line">  loader: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">  enforce: <span class="string">&#x27;pre&#x27;</span>,</span><br><span class="line">  include: [resolve(<span class="string">&#x27;src&#x27;</span>), resolve(<span class="string">&#x27;test&#x27;</span>)],</span><br><span class="line">  options: &#123;</span><br><span class="line">    formatter: <span class="built_in">require</span>(<span class="string">&#x27;eslint-friendly-formatter&#x27;</span>),</span><br><span class="line">    emitWarning: !config.dev.showEslintErrorsInOverlay</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  context: path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>),</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: [<span class="string">&quot;babel-polyfill&quot;</span>, <span class="string">&#x27;./src/main.js&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: &#123;</span><br><span class="line">    <span class="string">&#x27;BMap&#x27;</span>: <span class="string">&#x27;BMap&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;BMap_Symbol_SHAPE_POINT&#x27;</span>: <span class="string">&#x27;BMap_Symbol_SHAPE_POINT&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    publicPath: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span></span><br><span class="line">      ? config.build.assetsPublicPath</span><br><span class="line">      : config.dev.assetsPublicPath</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: resolve(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...(config.dev.useEslint ? [createLintingRule()] : []),</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">        options: vueLoaderConfig</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        include: [resolve(<span class="string">&#x27;src&#x27;</span>), resolve(<span class="string">&#x27;test&#x27;</span>), resolve(<span class="string">&#x27;node_modules/webpack-dev-server/client&#x27;</span>)]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">10000</span>,</span><br><span class="line">          name: utils.assetsPath(<span class="string">&#x27;img/[name].[hash:7].[ext]&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">10000</span>,</span><br><span class="line">          name: utils.assetsPath(<span class="string">&#x27;media/[name].[hash:7].[ext]&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">10000</span>,</span><br><span class="line">          name: utils.assetsPath(<span class="string">&#x27;fonts/[name].[hash:7].[ext]&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  node: &#123;</span><br><span class="line">    <span class="comment">// prevent webpack from injecting useless setImmediate polyfill because Vue</span></span><br><span class="line">    <span class="comment">// source contains it (although only uses it if it&#x27;s native).</span></span><br><span class="line">    setImmediate: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// prevent webpack from injecting mocks to Node native modules</span></span><br><span class="line">    <span class="comment">// that does not make sense for the client</span></span><br><span class="line">    dgram: <span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">    fs: <span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">    net: <span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">    tls: <span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">    child_process: <span class="string">&#x27;empty&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常考的问题</title>
      <link href="/archives/a5104644.html"/>
      <url>/archives/a5104644.html</url>
      
        <content type="html"><![CDATA[<h2 id="vue相关的问题汇总"><a href="#vue相关的问题汇总" class="headerlink" title="vue相关的问题汇总"></a>vue相关的问题汇总</h2><hr><h4 id="vue组件通信有哪些？"><a href="#vue组件通信有哪些？" class="headerlink" title="vue组件通信有哪些？"></a>vue组件通信有哪些？</h4><blockquote><p>vue组件通信有好几种方法，具体介绍工作中常用的方法<br>父子组件直接的通信，<code>props $emit/$on</code><br>父组件向子组件通信， 只需要 父组件中绑定响应方法， 子组件通过 <code>props</code> 直接接收使用即可，<br>子组件向父组件通信，<br>    - 子组件上面绑定一个事件方法， 方法中通过 <code>this.$emit(&#39;自定义事件名&#39;，&#39;传递的参数&#39;)</code><br>    - 父组件中需要接收 <code>v-on:自定义事件名=</code> 来获取数据<br>子组件向父组件通信，<code>$emit/$on</code> 订阅者发布则模式， 实现 兄弟之间通信</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Event=<span class="keyword">new</span> Vue(); <span class="comment">// 创建一个消息队列</span></span><br><span class="line">Event.$emit(事件名,数据); <span class="comment">// 子组件发送事件</span></span><br><span class="line">Event.$on(事件名,<span class="function"><span class="params">data</span> =&gt;</span> &#123;&#125;); <span class="comment">// 父组件接收</span></span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p><strong>Vuex</strong>实现各个组件之间的通信<br>简单点的理解就是 vuex类似第三方的数据管理，a,b,c..等待组件 只用调用vuex，就可以获取和修改上面的数据，这样就实现了通信</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模块化管理 Vuex</span></span><br><span class="line"><span class="comment">// 用户信息模块，user.js </span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        <span class="comment">// 存放状态，变量数据</span></span><br><span class="line">        loginStartus:<span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line">    <span class="comment">//  加工 state成员给外界，，自带2个参数， state，getters</span></span><br><span class="line">     <span class="comment">//  通过: 参数， state.获取state中的变量， 通过getters. 调用自己内部其它的方法</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">    <span class="comment">// 同步 操作 数据</span></span><br><span class="line">        login(state)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line">    <span class="comment">// 用来异步操作数据，套装了 mutations，</span></span><br><span class="line">     <span class="comment">/* 带2个参数， context：上下文</span></span><br><span class="line"><span class="comment">        payload 挂在参数</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules:&#123;</span><br><span class="line">        user</span><br><span class="line">        <span class="comment">// 模块化的方式很多， 具体可以看业务需求来弄 &#123;&#125;的形式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Vuex数据持久化"><a href="#Vuex数据持久化" class="headerlink" title="Vuex数据持久化"></a>Vuex数据持久化</h4><blockquote><p>解答： 通过vuex-persistedstate 这个插件来完成本地数据存储，从而实现刷新后 state仍然存在</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vuexPres = <span class="keyword">new</span> VuexPersistence(&#123; </span><br><span class="line">    storage: <span class="built_in">window</span>.localStorage,</span><br><span class="line">    reducer: <span class="function"><span class="params">state</span>=&gt;</span>(&#123;</span><br><span class="line">    user:state.user</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;  </span><br><span class="line">state,actions,</span><br><span class="line">mutations,</span><br><span class="line">plugins:[vuexPres.plugin]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Vue的声明周期，各个阶段都干啥的"><a href="#Vue的声明周期，各个阶段都干啥的" class="headerlink" title="Vue的声明周期，各个阶段都干啥的"></a>Vue的声明周期，各个阶段都干啥的</h4><blockquote><p>8个声明周期，如图<br><img src="/images/vue/vue%E5%88%9B%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Vue声明周期"></p></blockquote><h4 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h4><blockquote><p>浅谈一下： vue2.x响应式的底层使用的方法 <code>Object.defineProperty()</code> 消息劫持方式 该方法中存在一个getter和setter的可选项，可以对属性值的获取和设置造成影响<br>Vue中编写了一个 <code>wather</code> 来监听处理数据， 再使用 <code>getter</code>时，会通知water实力对view层渲染页面<br>在使用 setter方法时， 总会在变值的同时， 通知<code>wather</code>实例对view层更新<br>–  Object.defineProperty() 方法只部分支持IE9，所以Vue兼容IE版本最低为IE9</p></blockquote><h4 id="v-on可以绑定多个函数吗？"><a href="#v-on可以绑定多个函数吗？" class="headerlink" title="v-on可以绑定多个函数吗？"></a>v-on可以绑定多个函数吗？</h4><blockquote><p>可以</p></blockquote><h4 id="路由钩子函数"><a href="#路由钩子函数" class="headerlink" title="路由钩子函数"></a>路由钩子函数</h4><blockquote><p>全局的构造函数 <code>beforeEach(to,from,next)</code><br>针对单个路由钩子函数 <code>beforeEnter(to,from,next)</code><br>组件钩子函数 <code>beforRouteEnter(to,from,next)</code>   这个路由钩子函数比生命周期beforeCreate函数先执行，所以this实例还没有创建出来</p></blockquote><ul><li>next() 不写的话，不会跳转，</li></ul><h4 id="sessionStorage-localStorage-cookie-的区别"><a href="#sessionStorage-localStorage-cookie-的区别" class="headerlink" title="sessionStorage localStorage cookie 的区别"></a>sessionStorage localStorage cookie 的区别</h4><blockquote><p>他们的区别： 都是保存在浏览器端的，</p><ul><li>localStorage是永久缓存， 不主动删掉数据，数据不会消失，数据存储大小可以达到5m以上， 不同浏览器不同，在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li><li>sessionStorage 的生命周期是仅在当前会话下有效。sessionStorage 引入了一个“浏览器窗口”的概念，sessionStorage 是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是 sessionStorage 在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage 也是不一样的</li></ul></blockquote><ul><li>cookie生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右, 有个数限制（各浏览器不同），一般不能超过20个。缺点是不能储存大数据且不易读取</li></ul><h4 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h4><blockquote><p>computed: </p><ol><li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li><li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li><li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li><li>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。监听函数内部<br>watch</li></ol></blockquote><ol><li>不支持缓存，数据变，直接会触发相应的操作；</li><li>watch支持异步；</li><li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li><li>当一个属性发生变化时，需要执行对应的操作；一对多；</li><li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，<br>　　immediate：组件加载立即触发回调函数执行，<br>　　deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</li></ol><h4 id="单页面和多页面应用"><a href="#单页面和多页面应用" class="headerlink" title="单页面和多页面应用"></a>单页面和多页面应用</h4><h4 id="什么时虚拟DOM"><a href="#什么时虚拟DOM" class="headerlink" title="什么时虚拟DOM"></a>什么时虚拟DOM</h4><blockquote><p>通过js 创建 和原dom 以对象嵌套的方式来表示的<code>dom</code>树, 来替换掉直接对原生 dom的操作，<br>这样 dom 的更改就变成了 js 对象的属性的更改，这样一来就能查找 js 对象的属性变化要比查询 dom 树的性能开销小</p></blockquote><h4 id="v-for-中-key-的作用是什么"><a href="#v-for-中-key-的作用是什么" class="headerlink" title="v-for 中 key 的作用是什么"></a>v-for 中 key 的作用是什么</h4><h4 id="v-show-he-v-if的区别"><a href="#v-show-he-v-if的区别" class="headerlink" title="v-show he v-if的区别"></a>v-show he v-if的区别</h4><blockquote><p>v-show 不显示，但也渲染<br>v-if 显示就渲染，不显示就不渲染， </p></blockquote><h4 id="vue-loader？"><a href="#vue-loader？" class="headerlink" title="vue-loader？"></a>vue-loader？</h4><blockquote><p>作用： 解析和转换.vue文件。提取出其中的逻辑代码 script,样式代码style,以及HTML 模板template，再分别把他们交给对应的loader去处理<br>将es6转换成es5</p></blockquote><h4 id="什么是-mixin"><a href="#什么是-mixin" class="headerlink" title="什么是 mixin"></a>什么是 mixin</h4><h4 id="vue-cli如何配置方向代理"><a href="#vue-cli如何配置方向代理" class="headerlink" title="vue-cli如何配置方向代理"></a>vue-cli如何配置方向代理</h4><h4 id="props-如何指定类型"><a href="#props-如何指定类型" class="headerlink" title="props 如何指定类型"></a>props 如何指定类型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props:&#123;<span class="attr">id</span>:[<span class="built_in">Object</span>,<span class="built_in">Number</span>] &#125; </span><br></pre></td></tr></table></figure><h4 id="Vue-声明周期中，created-通常用于做什么"><a href="#Vue-声明周期中，created-通常用于做什么" class="headerlink" title="Vue 声明周期中，created 通常用于做什么"></a>Vue 声明周期中，created 通常用于做什么</h4><blockquote><p>获取数据</p></blockquote><h4 id="什么时候执行updated-周期"><a href="#什么时候执行updated-周期" class="headerlink" title="什么时候执行updated 周期"></a>什么时候执行updated 周期</h4><h4 id="Vue的钩子函数为何不能是用箭头函数"><a href="#Vue的钩子函数为何不能是用箭头函数" class="headerlink" title="Vue的钩子函数为何不能是用箭头函数"></a>Vue的钩子函数为何不能是用箭头函数</h4><blockquote><p>this指向未定义</p></blockquote><h4 id="keep-alive什么时候使用？"><a href="#keep-alive什么时候使用？" class="headerlink" title="keep-alive什么时候使用？"></a>keep-alive什么时候使用？</h4><h4 id="路由传值有哪些方式？"><a href="#路由传值有哪些方式？" class="headerlink" title="路由传值有哪些方式？"></a>路由传值有哪些方式？</h4><blockquote><p>工作中常用的的2种方式：</p><ol><li>{name：’’,params:{id;’’}} <code>params</code> 不显示  获取参数 <code>this.$route.params.id</code></li><li>{path:’/path’,query:{id:’’}} <code>query</code> 显示  <code>this.$route.query.id</code></li></ol></blockquote><h4 id="Vuex的使用过程？"><a href="#Vuex的使用过程？" class="headerlink" title="Vuex的使用过程？"></a>Vuex的使用过程？</h4><blockquote><p>state：vuex的基本数据，用来存储变量<br>geeter：从基本数据(state)派生的数据，相当于state的计算属性<br>mutation：提交更新数据的方法，必须是同步的(如果需要异步使用action)<br>action：和mutation的功能大致相同，不同之处在于 ==》1. Action 提交的是 mutation，而不是直接变更状态。 2. Action 可以包含任意异步操作。</p></blockquote><h4 id="什么是异步组件"><a href="#什么是异步组件" class="headerlink" title="什么是异步组件"></a>什么是异步组件</h4><blockquote><p>异步组件就是定义的时候什么都不做，只在组件需要渲染（组件第一次显示）的时候进行加载渲染并缓存，缓存是以备下次访问。</p></blockquote><ul><li>懒加载，按需加载</li></ul><h4 id="Vue-nextTick"><a href="#Vue-nextTick" class="headerlink" title="Vue.nextTick"></a>Vue.nextTick</h4><h2 id="js相关的问题汇总"><a href="#js相关的问题汇总" class="headerlink" title="js相关的问题汇总"></a>js相关的问题汇总</h2><hr><h3 id="new的作用"><a href="#new的作用" class="headerlink" title="new的作用"></a>new的作用</h3><blockquote><ol><li>在内存中创建一个新的空对象</li><li>让this指向这个新的对象</li><li>执行构造函数里面的代码： 目的就是给这个新对象添加属性和方法</li><li>返回这个新对象 (构造函数里面不需要放回)</li></ol></blockquote><h4 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一， 拆分，数组反转， 数组拼接字符串</span></span><br><span class="line"><span class="keyword">let</span> op =<span class="string">&#x27;abcdefg&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> newOp = op.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> newOp2 = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> f <span class="keyword">in</span> op)&#123;newOp2 = f +newOp2 &#125;</span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="proto-和-prototype"><a href="#proto-和-prototype" class="headerlink" title="proto 和 prototype"></a><strong>proto</strong> 和 prototype</h4><blockquote><p><code>__proto__</code> :私有属性，表示只能在内部使用<br> ==&gt; 该属性指向当前对象的构造函数的原型，它保证了对象实例能够访问在构造函数原型中定义的所有属性和方法。</p></blockquote><blockquote><p>prototype: 指向原型对象，这个对象包含所有实例共享的属性和方法<br> ==&gt;我们把prototype属性叫做原型属性。prototype指向的原型对象又有一个属性constructor，这个属性也是一个指针，指回原构造函数</p></blockquote><h4 id="js执行上下文"><a href="#js执行上下文" class="headerlink" title="js执行上下文"></a>js执行上下文</h4><blockquote><p>当函数执行时，会创建一个称为执行上下文的内部对象（可理解为作用域）。一个执行上下文定义了一个函数执行时的环境。</p></blockquote><ol><li>创建阶段 <ol><li>创建作用域链</li><li>创建变量对象</li><li>求 this 的值</li></ol></li><li>激活/代码执行阶段。</li></ol><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><blockquote><p>参考<br><a href="https://www.cnblogs.com/tylerdonet/p/9595436.html">JavaScript原型链和继承</a></p></blockquote><h4 id="call-bind-apply区别"><a href="#call-bind-apply区别" class="headerlink" title="call bind apply区别"></a>call bind apply区别</h4><blockquote><p>都是改变函数this指向<br>call和apply 参数传递不一样， <code>call</code>是以直接传入<code>(obj,arg1,arg2...)</code>，  <code>apply</code>是以数组的形式传入<code>(obj,[arg1,arg2...])</code><br>call,apply 方法是再调用之后立即执行函数， 而bind方法不立刻执行， 需要将函数再执行一遍</p></blockquote><h4 id="列表去重"><a href="#列表去重" class="headerlink" title="列表去重"></a>列表去重</h4><blockquote><p>es6去重：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">54</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newArr1 = arr.filter(<span class="function">(<span class="params">x, index,self</span>)=&gt;</span>self.indexOf(x)===index) </span><br><span class="line"><span class="keyword">let</span> newArr2 = <span class="built_in">Array</span>.from( <span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br></pre></td></tr></table></figure><blockquote><p>es5去重：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr =[]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (newArr.indexOf(arr[i]) !== <span class="number">-1</span>) &#123;newArr.shift(arr[i])&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="宏任务，微任务，事务循环"><a href="#宏任务，微任务，事务循环" class="headerlink" title="宏任务，微任务，事务循环"></a>宏任务，微任务，事务循环</h4><blockquote><p>微任务： promise 创建的任务，<br>宏观任务： 定时器异步的任务，</p></blockquote><h4 id="原生js-实现冒泡排序，-和深拷贝"><a href="#原生js-实现冒泡排序，-和深拷贝" class="headerlink" title="原生js 实现冒泡排序， 和深拷贝"></a>原生js 实现冒泡排序， 和深拷贝</h4><blockquote><p>冒泡算法</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">12</span>,<span class="number">7</span>,<span class="number">34</span>,<span class="number">65</span>,<span class="number">88</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">12</span>]        </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">art</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;art.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;art.length<span class="number">-1</span>-i;j++)</span><br><span class="line">        <span class="keyword">if</span>(art[j]&gt;art[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">// 当前项大于后一项</span></span><br><span class="line">                <span class="keyword">let</span> temp = [];</span><br><span class="line">                <span class="comment">// art[j],art[j+1] = art[j+1],art[j]</span></span><br><span class="line">                temp = art[j]</span><br><span class="line">                art[j]=art[j+<span class="number">1</span>]</span><br><span class="line">                art[j+<span class="number">1</span>] = temp     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> art</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="如何判断一个变量是数组还是对象？"><a href="#如何判断一个变量是数组还是对象？" class="headerlink" title="如何判断一个变量是数组还是对象？"></a>如何判断一个变量是数组还是对象？</h4><blockquote><p> 使用 toString()方法// 兼容性比较好</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> b = &#123; <span class="string">&#x27;c&#x27;</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(a); <span class="comment">//=&gt;&quot;[object Array]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(b) <span class="comment">//=&gt; &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 Array.isArray() 方法</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(a); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(b) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不存在Array.isArray() 创建</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ES6中forEach和map方法有何区别？"><a href="#ES6中forEach和map方法有何区别？" class="headerlink" title="ES6中forEach和map方法有何区别？"></a>ES6中forEach和map方法有何区别？</h4><blockquote><p>map()根据当前数组映射出一个新的数组，map和forEach等遍历方法不同，在forEach中return语句是没有任何效果的，而map则可以改变当前循环的值，返回一个新的被改变过值之后的数组（map需return），一般用来处理需要修改某一个数组的值<br>forEach遍历方式遍历数组全部元素，利用回调函数对数组进行操作，自动遍历数组.length次，且无法break中途跳出循环，不可控、不支持return操作输出，return只用于控制循环是否跳出当前循环</p></blockquote><h4 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包?"></a>什么是闭包?</h4><blockquote><p><a href="https://www.dongzhu.ink/2020/04/15/hou-duan/bi-bao-zhuang-shi-qi/">js中的闭包</a></p></blockquote><h4 id="节流和防抖有何区别-有什么作用"><a href="#节流和防抖有何区别-有什么作用" class="headerlink" title="节流和防抖有何区别? 有什么作用?"></a>节流和防抖有何区别? 有什么作用?</h4><blockquote><p>节流：规定时间内触发一次，==&gt; 稀释函数的执行频率<br>防抖：一个需要频繁触发的函数,在规定时间内,只让最后一次生效,前面不生效,再次触发，从新计算时间<br>作用： 都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象</p></blockquote><h4 id="this是什么，如何改变其指向？"><a href="#this是什么，如何改变其指向？" class="headerlink" title="this是什么，如何改变其指向？"></a>this是什么，如何改变其指向？</h4><blockquote><p>this:  包含他的函数，作为方法被调用时， 所属的对象<br>谁调用函数，执行，this就指向谁， </p></blockquote><h4 id="什么是事件冒泡-如何阻止默认事件"><a href="#什么是事件冒泡-如何阻止默认事件" class="headerlink" title="什么是事件冒泡, 如何阻止默认事件"></a>什么是事件冒泡, 如何阻止默认事件</h4><blockquote><p>事件冒泡: 一个事件的执行从调用它的对象向它的父级对象传播，直到全部执行<br>阻止冒泡： window.event? window.event.cancelBubble = true : e.stopPropagation(); //兼容性考虑<br>阻止默认事件: event.preventDefault()，  return false<br>考虑到兼容行， 再别的浏览器中：<br>IE： window.event.returnValue = false;//阻止事件的默认行为<br>FireFor： event.preventDefault();// 阻止事件的默认行为</p></blockquote><h4 id="mouseenter和mouseover的区别"><a href="#mouseenter和mouseover的区别" class="headerlink" title="mouseenter和mouseover的区别"></a>mouseenter和mouseover的区别</h4><blockquote><p>mouseover: 当鼠标指针位于元素上方时，会发生 mouseover 事件。mouseover最用于目标元素及其后代元素<br>mouseenter: 当鼠标指针穿过元素时，会发生 mouseenter 事件。mouseenter事件只作用于目标元素</p></blockquote><h4 id="什么是事件委托？-有什么作用？"><a href="#什么是事件委托？-有什么作用？" class="headerlink" title="什么是事件委托？ 有什么作用？"></a>什么是事件委托？ 有什么作用？</h4><blockquote><p>利用事件冒泡，只指定一个事件处理程序来管理某一类型的所有事件。<br>减少DOM操作，节省内存空间，提高性能。</p></blockquote><h4 id="Eventloop"><a href="#Eventloop" class="headerlink" title="Eventloop"></a>Eventloop</h4><blockquote><p>JavaScript的一种运行机制<br>Event Loop是一个程序结构，用于等待和发送消息和事件<br><code>简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为&quot;主线程&quot;； 另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为&quot;Event Loop线程&quot;（可以译为&quot;消息线程&quot;）</code></p></blockquote><h4 id="跨域有哪几种，如何解决"><a href="#跨域有哪几种，如何解决" class="headerlink" title="跨域有哪几种，如何解决"></a>跨域有哪几种，如何解决</h4><blockquote><p>当协议、子域名、主域名、端口号中任意一各不相同时，都算不同的“域”。 请求就出现了跨域， 工作中常遇到的的：</p></blockquote><ul><li>CORS跨域 ： 各种请求， 只需要后端配置</li><li>JSONP ： 只持此get请求</li></ul><h4 id="手写原生ajax"><a href="#手写原生ajax" class="headerlink" title="手写原生ajax"></a>手写原生ajax</h4><h4 id="window-onload-和-docunment-read-的区别"><a href="#window-onload-和-docunment-read-的区别" class="headerlink" title="window.onload 和 $(docunment.read)的区别"></a>window.onload 和 $(docunment.read)的区别</h4><blockquote><p>执行时机：</p></blockquote><ol><li>window.onload ：必须在页面所有元素（包括图片，引用文件）加载完后执行。。</li><li>$(document).ready() ：是页面中所有HTML DOM，CSS DOM结构加载完之后就会执行，其他图片可能没有加载完。<blockquote><p>编写个数不同</p></blockquote></li><li>window.onload ：不能同时写多个，后面的将会覆盖前面的</li><li>$(document).ready() ：可以同时编写多个，并且都可以得到执行。<blockquote><p>简写</p></blockquote></li><li>window.onload ：无。</li><li>$(document).ready() ：=》 <code>$().ready(function()&#123;&#125;)</code> =&gt; <code>$(function()&#123;&#125;)</code></li></ol><h4 id="原生js-获取和jQuery获取元素"><a href="#原生js-获取和jQuery获取元素" class="headerlink" title="原生js 获取和jQuery获取元素"></a>原生js 获取和jQuery获取元素</h4><blockquote><p>原生js</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;box&#x27;</span> <span class="attr">class</span>=<span class="string">&quot;cp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;cp&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="comment">// 选择器</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;#box&#x27;</span>)||<span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.cp&#x27;</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementsByName(<span class="string">&#x27;x&#x27;</span>); <span class="comment">// 返回name属性为x的伪数组</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>jQuery中获取元素</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础选择器</span></span><br><span class="line">$(<span class="string">&#x27;#id&#x27;</span>)</span><br><span class="line">$(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">$(<span class="string">&#x27;.class&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集，并列选择器</span></span><br><span class="line">$(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,)</span><br><span class="line">$(ul.li)</span><br><span class="line"><span class="comment">// 层次选择器</span></span><br><span class="line">$(<span class="string">&#x27;li span&#x27;</span>); <span class="comment">//后代选择器，li后代中所有的span</span></span><br><span class="line">$(<span class="string">&#x27;li&gt;span&#x27;</span>); <span class="comment">//子代选择器，li子代中所有的span</span></span><br><span class="line">$(<span class="string">&#x27;#dv~span&#x27;</span>);<span class="comment">//#dv后方兄弟span标签</span></span><br><span class="line">$(<span class="string">&#x27;#dv+span&#x27;</span>);<span class="comment">//#dv后方直接跟着的兄弟span标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引选</span></span><br><span class="line">$(对象:eq(索引值)); <span class="comment">//选中该索引值对应的对象</span></span><br><span class="line">$(对象:lt(索引值)) <span class="comment">//选中小于该索引值所有的对象</span></span><br><span class="line">$(对象:gt(索引值))<span class="comment">//选中大于该索引值所有的对象</span></span><br><span class="line">$(对象:odd/even) <span class="comment">//选中索引值为奇数/偶数的对象</span></span><br></pre></td></tr></table></figure><h4 id="DOM的增删改"><a href="#DOM的增删改" class="headerlink" title="DOM的增删改"></a>DOM的增删改</h4><blockquote><p><a href="/_posts/%E5%89%8D%E7%AB%AF/DOM%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5.md">Dom的操作</a></p></blockquote><ol><li><code>appendChild</code>(追加为子元素)</li><li><code>insertBefore</code>(插入前面)</li><li><code>removeChild</code>(删除子元素)</li><li><code>replaceChild</code>(替换子元素)</li><li>选择器, id,tag,</li></ol><h4 id="break-continue-和for-循环的区别"><a href="#break-continue-和for-循环的区别" class="headerlink" title="break continue 和for 循环的区别"></a>break continue 和for 循环的区别</h4><blockquote><p>break:终止循环<br>continue:跳过这条循环<br>for 循环</p></blockquote><h4 id="null-和-undefined的区别-typeof-null的值？"><a href="#null-和-undefined的区别-typeof-null的值？" class="headerlink" title="null 和 undefined的区别 , typeof null的值？"></a>null 和 undefined的区别 , typeof null的值？</h4><blockquote><p>null: object类型，代表“空值”，代表一个空对象指针，</p></blockquote><ul><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li></ul><blockquote><blockquote><p>undefined:  声明未给值，undefined类型</p></blockquote></blockquote><ol><li>变量被声明了，但没有赋值时，就等于undefined。 例如，</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时或者return后面什么也没有，返回undefined。</li></ol><blockquote><p>typeof null: “object”</p></blockquote><ul><li><code>console.log(null==undefined)//true</code></li><li><code>console.log(null===undefined)//false</code></li></ul><h4 id="GET和POST-的区别"><a href="#GET和POST-的区别" class="headerlink" title="GET和POST 的区别"></a>GET和POST 的区别</h4><blockquote></blockquote><ol><li>get参数通过url传递，post放在request body中</li><li>get请求在url中传递的参数是有长度限制的，而post没有。</li><li>get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。<ul><li>get请求只能进行url编码，而post支持多种编码方式</li><li>get请求会浏览器主动cache，而post支持多种编码方式。</li><li>get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</li></ul></li></ol><h4 id="手写实现原型链继承"><a href="#手写实现原型链继承" class="headerlink" title="手写实现原型链继承"></a>手写实现原型链继承</h4><h4 id="ES6-新特性（变量，数组方法，箭头函数）"><a href="#ES6-新特性（变量，数组方法，箭头函数）" class="headerlink" title="ES6 新特性（变量，数组方法，箭头函数）"></a>ES6 新特性（变量，数组方法，箭头函数）</h4><h2 id="css-项目的问题汇总"><a href="#css-项目的问题汇总" class="headerlink" title="css 项目的问题汇总"></a>css 项目的问题汇总</h2><hr><h4 id="标准盒子模型和怪异盒模型"><a href="#标准盒子模型和怪异盒模型" class="headerlink" title="标准盒子模型和怪异盒模型"></a>标准盒子模型和怪异盒模型</h4><blockquote><p>在标准模式下，一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)<br>一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值）</p></blockquote><h4 id="什么是盒子模型"><a href="#什么是盒子模型" class="headerlink" title="什么是盒子模型"></a>什么是盒子模型</h4><h4 id="水平垂直居中的方式"><a href="#水平垂直居中的方式" class="headerlink" title="水平垂直居中的方式"></a>水平垂直居中的方式</h4><h4 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h4><blockquote><p>伸缩盒布局 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮一峰-flex布局</a><br><strong>容器（父元素设置）上的属性</strong></p></blockquote><ul><li><code>flex-direction</code>  属性决定主轴的方向（即项目的排列方向）<ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul></li><li><code>flex-wrap</code>  ：默认情况下，项目都排在一条线（又称”轴线”）上<ul><li><code>nowrap</code>（默认）：不换行。</li><li><code>wrap</code>：换行，第一行在上方。</li><li><code>wrap-reverse</code>：换行，第一行在下方。</li></ul></li><li><code>flex-flow</code>  : 属性是flex-direction属性和flex-wrap属性的简写形式: 默认值为 <code>row</code> <code>nowrap</code><ul><li><code>flex-flow</code>: <flex-direction> || <flex-wrap></li></ul></li><li><code>justify-content</code> :  布局方式 属性定义了项目在主轴上的对齐方式<ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></li><li><code>align-items</code> 属性定义项目在交叉轴上如何对齐<ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul></li><li><code>align-content</code>  : 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul></li></ul><blockquote><p><strong>项目的（子元素）属性</strong></p></blockquote><ul><li><code>order</code> : <integer>;  属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li><li><code>flex-grow</code> : <number>; /* default 0 */  属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li><li><code>flex-shrink</code> : <number>  属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。=&gt;负值对该属性无效。</li><li><code>flex-basis</code> : <length> | auto; /* default auto */  属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小</li><li><code>flex</code> : none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]   属性是<code>flex-grow</code>, <code>flex-shrink </code>和 <code>flex-basis</code>的简写，默认值为0 1 auto。后两个属性可选。</li><li><code>align-self</code> : 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<ul><li><code>align-self</code>: <code>auto</code> | <code>flex-start</code> | <code>flex-end</code> | <code>center</code> | <code>baseline</code> | <code>stretch</code>;  该属性可能取6个值，除了<code>auto</code>，其他都与<code>align-items</code>属性完全一致。</li></ul></li></ul><h4 id="css五种定位"><a href="#css五种定位" class="headerlink" title="css五种定位"></a>css五种定位</h4><blockquote><ol><li><code>static</code> 定位(普通流定位) ————– 默认定位</li><li><code>relative</code> 定位(相对定位) <code>position:relative</code>; 该元素不脱离文档流，依然占浏览器位置。 常用来作为绝对定位元素的容器。可通过left、top、right、bottom值进行偏移，不设偏移量时位置不变。<br>可以通过z-index改变层叠顺序</li><li><code>absolute</code> 定位(绝对定位) <code>position:absolute</code>; 脱离文档流，不再占据空间，因此，下面的元素会顶上来。</li><li><code>fixed</code>；固定定位 <code>position:fixed</code> 脱离文档流，和绝对定位不同，固定定位会使该元素固定在某个位置不动。</li><li><code>sticky</code> (粘性定位) <code>position:sticky</code>; CSS3新增的定位属性，用于页面滚动时的定位，一般用于吸顶效果,  粘性定位的父元素不能设置overflow:hidden和overflow:auto;否则不能实现吸顶效果。</li></ol></blockquote><h4 id="css变量"><a href="#css变量" class="headerlink" title="css变量"></a>css变量</h4><blockquote><p>用 <code>--</code> 声明, <code>var()</code> 函数用于读取变量   <a href="http://www.ruanyifeng.com/blog/2017/05/css-variables.html">阮一峰-css变量</a></p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">--foo</span>: <span class="number">#7F583F</span>;</span><br><span class="line">  <span class="attribute">--bar</span>: <span class="number">#F7EFD2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*var() 函数用于读取变量。*/</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--foo);</span><br><span class="line">  <span class="attribute">text-decoration-color</span>: <span class="built_in">var</span>(--bar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数还可以使用第二个参数，表示变量的默认值。如果该变量不存在，就会使用这个默认值。*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">color</span>: <span class="selector-tag">var</span>(<span class="selector-tag">--foo</span>, <span class="selector-id">#7F583F</span>);</span><br></pre></td></tr></table></figure><h4 id="伪元素和伪类"><a href="#伪元素和伪类" class="headerlink" title="伪元素和伪类"></a>伪元素和伪类</h4><ol><li><code>before</code> 和 <code>after</code>是经常经常重用的伪元素</li><li>hover 和active 属于UI伪类<br>区别：<br>伪类和选择器之间用一个冒号隔开，伪元素则是两个冒号隔.</li></ol><h4 id="css如何实现左侧固定，右侧自动适应布局"><a href="#css如何实现左侧固定，右侧自动适应布局" class="headerlink" title="css如何实现左侧固定，右侧自动适应布局"></a>css如何实现左侧固定，右侧自动适应布局</h4><blockquote><p>定位， 左右2变固定定位， 中间 auto自动适应<br>flex布局， 左右给定固定的宽度， 中间 flex：1</p></blockquote><h4 id="gt-在css3-中表示什么"><a href="#gt-在css3-中表示什么" class="headerlink" title="~ + &gt; 在css3 中表示什么"></a>~ + &gt; 在css3 中表示什么</h4><h4 id="什么是浮动-如何清除浮动？"><a href="#什么是浮动-如何清除浮动？" class="headerlink" title="什么是浮动  如何清除浮动？"></a>什么是浮动  如何清除浮动？</h4><h4 id="import-和-link-的区别"><a href="#import-和-link-的区别" class="headerlink" title="@import 和 link 的区别"></a>@import 和 link 的区别</h4><blockquote><ol><li>加载顺序不通， link是异步， @import 是页面加载完成后被加载</li><li>DOM操作</li><li>link引入的权重， 大于@improt ==》 引入的在最上面</li><li>从属关系， link 是html 标签，  @import是css关键字</li></ol></blockquote><h4 id="BFC-FFC-IFC"><a href="#BFC-FFC-IFC" class="headerlink" title="BFC FFC IFC"></a>BFC FFC IFC</h4><ol><li>BFC 块级格式化上下文</li><li></li></ol><h4 id="vw-和-rem-怎么用"><a href="#vw-和-rem-怎么用" class="headerlink" title="vw 和 rem 怎么用"></a>vw 和 rem 怎么用</h4><blockquote><p> vw 是视口单位，相当于把视口等分成了100，1vw = 1<br> rem是相对单位，设置根元素 html 的 font-size，比如给 html 设置字体大小为100px，1rem = 100px;</p><blockquote><p>举例：<br>我们以 iPhone6为基准，屏幕宽度为375px，然后换算成 vw<br>    <code>　375 / 100 = 3.75;</code><br>一般使用 rem 会给 html 的 font-size 设置大小为 100px，因为方便计算，这里需要把100px 换算为 vw<br>    <code>　100 / 3.75 = 26.6666666vw</code></p><blockquote><p>注：上面结果能最大限度减少像素偏差，经测试，若值舍五入为27vw或26vw都会有1-2像素的偏差</p></blockquote></blockquote></blockquote><h2 id="前端性能，多端适配，-综合题型"><a href="#前端性能，多端适配，-综合题型" class="headerlink" title="前端性能，多端适配， 综合题型"></a>前端性能，多端适配， 综合题型</h2><hr><h4 id="性能优化，"><a href="#性能优化，" class="headerlink" title="性能优化，"></a>性能优化，</h4><h4 id="简单说一下从输入网站到页面显示发生了什么？"><a href="#简单说一下从输入网站到页面显示发生了什么？" class="headerlink" title="简单说一下从输入网站到页面显示发生了什么？"></a>简单说一下从输入网站到页面显示发生了什么？</h4><h4 id="你从哪些方便考虑，来做性能优化？"><a href="#你从哪些方便考虑，来做性能优化？" class="headerlink" title="你从哪些方便考虑，来做性能优化？"></a>你从哪些方便考虑，来做性能优化？</h4><h4 id="如何快速显示一个页面？"><a href="#如何快速显示一个页面？" class="headerlink" title="如何快速显示一个页面？"></a>如何快速显示一个页面？</h4><h4 id="网站打开速度优化的几种方式"><a href="#网站打开速度优化的几种方式" class="headerlink" title="网站打开速度优化的几种方式"></a>网站打开速度优化的几种方式</h4><ol><li>借助外部力量优化，CDN加速、云存储等。</li><li>网站图片压缩优化，</li><li>对于网站代码优化这方面，</li><li>服务器端，在服务器端要记得开启GZIP压缩功能,客户端浏览器快速解压的原理</li><li>使用浏览器缓存</li><li>减少重定向请求</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
            <tag> React </tag>
            
            <tag> css </tag>
            
            <tag> vue </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coding加域名部署</title>
      <link href="/archives/b96b1f.html"/>
      <url>/archives/b96b1f.html</url>
      
        <content type="html"><![CDATA[<h1 id="注册Coding账号密码"><a href="#注册Coding账号密码" class="headerlink" title="注册Coding账号密码"></a>注册Coding账号密码</h1><ul><li><p><a href="https://coding.net/">Coding注册</a></p></li><li><p>注册完成后，登入创建 <code>DevOpos</code> 类型项目，</p></li><li><p>项目名称,项目表示，自己随定义取名， 跟Github一样</p></li><li><p>创建项目后，点击项目，找到代码创库，点击克隆项目，复制链接，跟github一样的操作</p></li><li><p>添加密钥，加本地git生成的公钥添加到Coding中， <code>个人中心- ssh公钥</code> 中，<br>windows下面的git一般存放再C盘用户名下的.ssh文件<code>id_rsa.pub</code>文件中</p></li><li><p>再Hexo博客项目根目录下 _config.yml 中设置,</p></li></ul><a id="more"></a><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment"># repo: git@github.com:YouAge/youage.github.com.git</span></span><br><span class="line">  <span class="attr">repository:</span></span><br><span class="line">    <span class="comment"># 刚创建coding的项目的地址</span></span><br><span class="line">    <span class="attr">coding:</span> <span class="string">git@e.coding.net:facade/hexo-blog-matery.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><ul><li>使用命令</li></ul><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g </span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><ul><li>提交上去后， 点开项目，看到已更新了， 在点击构建与部署，点击静态网站<br>创建静态网站，<br><img src="/images/Coding1.jpg"><br>网站名字自定义， 项目和仓库选址刚创建的，点击保存，它会生产一个随机访问地址，这样就可以访问了</li></ul><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><h3 id="域名设置，绑定-DNS-设置中添加-CNAME-记录指向"><a href="#域名设置，绑定-DNS-设置中添加-CNAME-记录指向" class="headerlink" title="域名设置，绑定 DNS 设置中添加 CNAME 记录指向"></a>域名设置，绑定 DNS 设置中添加 CNAME 记录指向</h3><ul><li>打开你购买的域名网站，找到域名，点击解析，点击添加记录，设置添加即可，<br><img src="/images/Coding3.jpg"></li></ul><ul><li>点击静态网站，点击右边的设置， 拉到最下面，找到 自定义域名<br><img src="/images/Coding2.jpg"></li></ul><p>输入域名，点击绑定。 </p><ul><li>需要HTTPS, 开启即可，</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liunx常用命令</title>
      <link href="/archives/63f1ffdd.html"/>
      <url>/archives/63f1ffdd.html</url>
      
        <content type="html"><![CDATA[<h3 id="查看系统相关命令"><a href="#查看系统相关命令" class="headerlink" title="查看系统相关命令"></a>查看系统相关命令</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">查看系统版本</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line"></span><br><span class="line">查看时间  date </span><br><span class="line">查看磁盘信息 df  du</span><br><span class="line">df -h      显示磁盘剩余空间 disk free</span><br><span class="line">du -h [目录名]      显示目录下的文件大小 disk usage</span><br><span class="line"></span><br><span class="line">ps -ef |grep python  # 查看python运行程序</span><br><span class="line">ps -ef|grep python|grep -u dz| grep -v grep # 查看dz用户下的python进程 过滤掉grep进程</span><br><span class="line"># 提取pid(awk以空格分割，显示第二个变量即为pid)</span><br><span class="line">ps -ef|grep elasticsearch|grep -v grep|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">查看进程信息 ps</span><br><span class="line">ps aux    process status 查看进程的详细状况</span><br><span class="line">top    动态显示运行中的进程并且排序</span><br><span class="line"></span><br><span class="line">kill [-<span class="number">9</span>] 进程代号    终止指定代号的进程，-<span class="number">9</span> 表示强行终止 </span><br><span class="line"></span><br><span class="line">-----参数含义------&gt;&gt;&gt;</span><br><span class="line">a    显示终端上的所有进程，包括其他用户的进程</span><br><span class="line">u    显示进程的详细状态</span><br><span class="line">x    显示没有控制终端的进程</span><br><span class="line">--------注意点-----&gt;&gt;&gt;</span><br><span class="line">ps 默认只会显示当前用户通过终端启动的应用程序</span><br><span class="line">使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃</span><br><span class="line">要退出 top 可以直接输入 q</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="文件权限管理-chmod"><a href="#文件权限管理-chmod" class="headerlink" title="文件权限管理 chmod"></a>文件权限管理 chmod</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">chmod 可以修改 用户／组 对 文件／目录 的权限</span><br><span class="line">chmod +/-rwx 文件名|目录名    -R 递归修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改文件|目录的拥有者</span><br><span class="line">chown 用户名 文件名|目录名</span><br><span class="line"></span><br><span class="line"># 递归修改文件|目录的组</span><br><span class="line">chgrp -R 组名 文件名|目录名</span><br><span class="line"></span><br><span class="line"># 递归修改文件权限</span><br><span class="line">chmod -R <span class="number">755</span> 文件名|目录名</span><br><span class="line"></span><br><span class="line">权限数字对应</span><br><span class="line">r--&gt;<span class="number">4</span></span><br><span class="line">w--&gt;<span class="number">2</span></span><br><span class="line">x--&gt;<span class="number">1</span></span><br><span class="line">拥有者(rwx),组(rwx),其他(rwx)</span><br><span class="line">rwx--<span class="number">7</span></span><br><span class="line">rw- --&gt;<span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---查看log最后<span class="number">10</span>行</span><br><span class="line">tail  -n  <span class="number">10</span>  test.log</span><br><span class="line"></span><br><span class="line">tail -n +<span class="number">10</span> test.log    查询<span class="number">10</span>行之后的所有日志;</span><br><span class="line"></span><br><span class="line">head -n <span class="number">10</span>  test.log   查询日志文件中的头<span class="number">10</span>行日志;</span><br><span class="line"></span><br><span class="line">head -n -<span class="number">10</span>  test.log   查询日志文件除了最后<span class="number">10</span>行的其他所有日志;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grep “要查找的字符串” 文件名</span><br></pre></td></tr></table></figure><h3 id="yum安装软件卸载"><a href="#yum安装软件卸载" class="headerlink" title="yum安装软件卸载"></a>yum安装软件卸载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装：yum -y install ...</span><br><span class="line">卸载：yum -y remove  ...</span><br></pre></td></tr></table></figure><h3 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*    代表任意个数个字符</span><br><span class="line">?    代表任意一个字符，至少 1 个</span><br><span class="line">[]    表示可以匹配字符组中的任一一个</span><br><span class="line">[abc]    匹配 a、b、c 中的任意一个</span><br><span class="line">[a-f]    匹配从 a 到 f 范围内的的任意一个字符</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="liunx文件和目录常用命令"><a href="#liunx文件和目录常用命令" class="headerlink" title="liunx文件和目录常用命令"></a>liunx文件和目录常用命令</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">查看目录 ls </span><br><span class="line">ls -a  (ll)显示指定目录下所有子目录与文件，包括隐藏文件</span><br><span class="line">ls -l 以列表方式显示文件的详细信息</span><br><span class="line">ls -h 配合 -l 以人性化的方式显示文件大小</span><br><span class="line"></span><br><span class="line">创建文件 touch  ..</span><br><span class="line">创建文件夹 mkdir ..</span><br><span class="line">-p 可以递归创建目录</span><br><span class="line"></span><br><span class="line">删除 rm   </span><br><span class="line">-f:强制删除</span><br><span class="line">-i:交互模式，在删除前询问用户是否操作</span><br><span class="line">-r:递归删除，常用在目录的删除</span><br><span class="line"></span><br><span class="line">复制 cp</span><br><span class="line">-i    覆盖文件前提示</span><br><span class="line">-r    若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</span><br><span class="line"></span><br><span class="line">移动 mv</span><br><span class="line">-f:force，强制直接移动而不询问</span><br><span class="line">-i:若目标文件(destination)已经存在，就会询问是否覆盖</span><br><span class="line">-u:若目标文件已经存在，且源文件比较新，才会更新</span><br><span class="line"></span><br><span class="line">-------------------------------</span><br><span class="line">Linux 系统中 grep 命令是一种强大的文本搜索工具</span><br><span class="line">grep允许对文本文件进行 模式查找，所谓模式查找，又被称为正则表达式，在就业班会详细讲解</span><br><span class="line">-n    显示匹配行及行号</span><br><span class="line">-v    显示不包含匹配文本的所有行（相当于求反）</span><br><span class="line">-i    忽略大小写</span><br><span class="line">常用的两种模式查找</span><br><span class="line">^a    行首，搜寻以 a 开头的行</span><br><span class="line">ke$    行尾，搜寻以 ke 结束的行</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="远程管理常用命令"><a href="#远程管理常用命令" class="headerlink" title="远程管理常用命令"></a>远程管理常用命令</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">重启操作系统，now表现在</span><br><span class="line">$ shutdown -r now</span><br><span class="line">立刻关机</span><br><span class="line">$ shutdown mow</span><br><span class="line">系统在今天 <span class="number">20</span>:<span class="number">25</span>关机</span><br><span class="line">$ shutdown <span class="number">20</span>:<span class="number">25</span></span><br><span class="line">系统再过十分钟后关机</span><br><span class="line">$ shutdown +<span class="number">10</span></span><br><span class="line"></span><br><span class="line">取消之前制定的关机计划</span><br><span class="line">shutdown -c</span><br><span class="line"></span><br><span class="line">重启系统  reboot now</span><br><span class="line"></span><br><span class="line">查看网卡 Ip</span><br><span class="line">ifconfig</span><br><span class="line">ping Ip地址</span><br><span class="line"></span><br><span class="line">linux系统间文件传输：</span><br><span class="line"></span><br><span class="line"># 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py</span><br><span class="line"># 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径</span><br><span class="line">scp -P port <span class="number">01</span>.py user<span class="meta">@remote</span>:Desktop/<span class="number">01</span>.py</span><br><span class="line"></span><br><span class="line"># 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.py</span><br><span class="line">scp -P port user<span class="meta">@remote</span>:Desktop/<span class="number">01</span>.py <span class="number">01</span>.py</span><br><span class="line"></span><br><span class="line"># 加上 -r 选项可以传送文件夹</span><br><span class="line"># 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop</span><br><span class="line">scp -r demo user<span class="meta">@remote</span>:Desktop</span><br><span class="line"></span><br><span class="line"># 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹</span><br><span class="line">scp -r user<span class="meta">@remote</span>:Desktop demo</span><br><span class="line"></span><br><span class="line">--------参数含义</span><br><span class="line">-r    若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</span><br><span class="line">-P    若远程 SSH 服务器的端口不是 <span class="number">22</span>，需要使用大写字母 -P 选项指定端口</span><br><span class="line">--------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="tar解压打包命令"><a href="#tar解压打包命令" class="headerlink" title="tar解压打包命令"></a>tar解压打包命令</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 打包文件</span><br><span class="line">tar -cvf 打包文件.tar 被打包的文件／路径...</span><br><span class="line"></span><br><span class="line"># 解包文件</span><br><span class="line">tar -xvf 打包文件.tar</span><br><span class="line">------&gt;&gt;参数含义---------&gt;&gt;</span><br><span class="line">c    生成档案文件，创建打包文件</span><br><span class="line">x    解开档案文件</span><br><span class="line">v    列出归档解档的详细过程，显示进度</span><br><span class="line">f    指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后</span><br><span class="line">---------&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">gzip 压缩/解压</span><br><span class="line"># 压缩文件</span><br><span class="line">tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...</span><br><span class="line"></span><br><span class="line"># 解压缩文件</span><br><span class="line">tar -zxvf 打包文件.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压缩到指定路径</span><br><span class="line">tar -zxvf 打包文件.tar.gz -C 目标路径</span><br><span class="line"></span><br><span class="line">-C    解压缩到指定目录，注意：要解压缩的目录必须存在</span><br><span class="line">&lt;&lt;&lt;&lt;--------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>###　Supervisor　进程守护安装及其配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">【安装】 pip install supervisor</span><br><span class="line">【生成supervisor默认配置文件】</span><br><span class="line">echo_supervisord_conf &gt; /etc/supervisord.conf</span><br><span class="line">【启动 】</span><br><span class="line">supervisord -c /etc/supervisord.conf </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">【centos 配置开启自动启动】</span><br><span class="line"></span><br><span class="line">#supervisord.service</span><br><span class="line">-------------------------------------------------</span><br><span class="line">[Unit] </span><br><span class="line">Description=Supervisor daemon</span><br><span class="line"></span><br><span class="line">[Service] </span><br><span class="line">Type=forking </span><br><span class="line">ExecStart=/usr/bin/supervisord -c /etc/supervisord.conf </span><br><span class="line">ExecStop=/usr/bin/supervisorctl shutdown </span><br><span class="line">ExecReload=/usr/bin/supervisorctl reload </span><br><span class="line">KillMode=process </span><br><span class="line">Restart=on-failure </span><br><span class="line">RestartSec=<span class="number">42</span>s</span><br><span class="line"></span><br><span class="line">[Install] </span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">---------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把文件深拷贝到 /usr/lib/systemd/system/</span></span><br><span class="line">cp supervisord.service /usr/lib/systemd/system/</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line">systemctl enable supervisord</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reboot <span class="keyword">new</span>  重启电脑</span><br><span class="line"></span><br><span class="line">-------------------相关命令-----------</span><br><span class="line">supervisorctl status  --#查看所以进程</span><br><span class="line">supervisorctl stop all  --#关闭所有</span><br><span class="line">supervisorctl stop 加要关闭的程序名</span><br><span class="line"></span><br><span class="line">restart重启</span><br><span class="line">supervisorctl update #新增任务</span><br><span class="line">----系统</span><br><span class="line">systemctl stop firewalld.service  停止</span><br><span class="line">systemctl disable firewalld.service 关闭开启</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Liunx定时任务crontab"><a href="#Liunx定时任务crontab" class="headerlink" title="Liunx定时任务crontab"></a>Liunx定时任务crontab</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// TODO  查看是否安装：</span></span><br><span class="line">rpm -qa | grep crontab</span><br><span class="line"> </span><br><span class="line"><span class="comment">// TODO 任务存在路径， 对应用户名文件</span></span><br><span class="line"></span><br><span class="line">/<span class="keyword">var</span>/spool/cron</span><br><span class="line"></span><br><span class="line">新增调度任务可用两种方法：</span><br><span class="line">    <span class="number">1</span>)、在命令行输入: crontab -e 然后添加相应的任务，wq存盘退出。</span><br><span class="line">    <span class="number">2</span>)、直接编辑/etc/crontab 文件，即vi /etc/crontab，添加相应的任务。</span><br><span class="line"></span><br><span class="line">查看调度任务</span><br><span class="line">    crontab -l <span class="comment">//列出当前的所有调度任务</span></span><br><span class="line">    crontab -l -u jp   <span class="comment">//列出用户jp的所有调度任务</span></span><br><span class="line"></span><br><span class="line">删除任务调度工作</span><br><span class="line">    crontab -r   <span class="comment">//删除所有任务调度工作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">任务编写命令:</span><br><span class="line">     Minute Hour  Day Month Dayofweek  command</span><br><span class="line">     分钟    小时  天  月    天每星期     命令</span><br><span class="line"></span><br><span class="line">--在这些字段里，除了“Command”是每次都必须指定的字段以外，其它字段皆为可选字段，</span><br><span class="line">可视需要决定。对于不指定的字段，要用“*”来填补其位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>      *       *       *     *     ll  指定每小时的第<span class="number">5</span>分钟执行一次ll命令</span><br><span class="line"><span class="number">30</span>     <span class="number">5</span>       *       *     *     ll  指定每天的 <span class="number">5</span>:<span class="number">30</span> 执行ll命令</span><br><span class="line"><span class="number">30</span>     <span class="number">7</span>       <span class="number">8</span>       *     *     ll  指定每月<span class="number">8</span>号的<span class="number">7</span>：<span class="number">30</span>分执行ll命令</span><br><span class="line"><span class="number">30</span>     <span class="number">5</span>       <span class="number">8</span>       <span class="number">6</span>     *     ll  指定每年的<span class="number">6</span>月<span class="number">8</span>日<span class="number">5</span>：<span class="number">30</span>执行ll命令</span><br><span class="line"><span class="number">30</span>     <span class="number">6</span>       *       *     <span class="number">0</span>     ll  指定每星期日的<span class="number">6</span>:<span class="number">30</span>执行ll命令[注：<span class="number">0</span>表示星期天，<span class="number">1</span>表示星期<span class="number">1</span>，</span><br><span class="line">以此类推，也可以用英文来表示，sun表示星期天，mon表示星期一等。]</span><br><span class="line"><span class="number">30</span>     <span class="number">3</span>     <span class="number">10</span>,<span class="number">20</span>     *     *     ll  每月<span class="number">10</span>号及<span class="number">20</span>号的<span class="number">3</span>：<span class="number">30</span>执行ll命令[注：“，”用来连接多个不连续的时段]</span><br><span class="line"><span class="number">25</span>     <span class="number">8</span><span class="number">-11</span>    *       *     *     ll  每天<span class="number">8</span><span class="number">-11</span>点的第<span class="number">25</span>分钟执行ll命令[注：“-”用来连接连续的时段]</span><br><span class="line">*/<span class="number">15</span>   *       *       *     *     ll  每<span class="number">15</span>分钟执行一次ll命令 [即每个小时的第<span class="number">0</span> <span class="number">15</span> <span class="number">30</span> <span class="number">45</span> <span class="number">60</span>分钟执行ls命令 ]</span><br><span class="line">在shell脚本中</span><br><span class="line">&gt; ，这个表示向文件重新添加内容，该文件首先被清空</span><br><span class="line">而 &gt;&gt; ，这个表示想文件追加内容，原来的内容不会被清理掉。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装python</title>
      <link href="/archives/c7c488b9.html"/>
      <url>/archives/c7c488b9.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>编写 shell脚本自动安装python环境</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> -x  <span class="comment"># 脚本运行情况输出</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装EPEL和IUS软件源</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取用户名</span></span><br><span class="line">username=$(whoami)</span><br><span class="line"></span><br><span class="line">yum install epel-release -y</span><br><span class="line">yum install https://centos7.iuscommunity.org/ius-release.rpm -y</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#　安装python3.6版本</span></span></span><br><span class="line">yum install python36u -y</span><br><span class="line">yum install python36u-devel -y</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装python需要的系统环境</span></span></span><br><span class="line">yum install -y openssl-devel openssl-static zlib-devel lzma tk-devel xz-devel bzip2-devel ncurses-devel gdbm-devel readline-devel sqlite-devel gcc libffi-devel gcc-c++</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改pip下载源， 创建当前用户目录创建使用</span></span><br><span class="line">mkdir  /$username/.pip</span><br><span class="line"></span><br><span class="line">cat &gt; /$username/.pip/pip.conf &lt;&lt; eof</span><br><span class="line">[global]</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br><span class="line">eof</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  mv pip.conf /root/.pip/pip.conf</span></span><br><span class="line"></span><br><span class="line">if [ $username == &quot;root&quot; ]; then</span><br><span class="line"><span class="meta">  #</span><span class="bash">supervisor 安装需要 root 权限，</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 安装supervisor 进程守护</span></span><br><span class="line">  pip3 install supervisor</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 【生成supervisor默认配置文件】</span></span><br><span class="line">  echo_supervisord_conf &gt; /etc/supervisord.conf</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 启动 supervisord 启动项目</span></span><br><span class="line">  supervisord -c /etc/supervisord.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 配置开机自启， 检查一下 whereis supervisord 的路径，修改对应的 ExecStart=/usr/bin/supervisord</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> ExecStart=/usr/bin/supervisord</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">　生成开机自启的配置</span></span><br><span class="line">  cat &gt; /usr/lib/systemd/system/supervisord.service &lt;&lt; eof</span><br><span class="line">[Unit]</span><br><span class="line">Description=Supervisor daemon</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">ExecStart=/usr/local/bin/supervisord -c /etc/supervisord.conf</span><br><span class="line">ExecStop=/usr/local/bin/supervisorctl shutdown</span><br><span class="line">ExecReload=/usr/local/bin/supervisorctl reload</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=42s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">eof</span><br><span class="line"><span class="meta">#</span><span class="bash"> mv supervisord.service /usr/lib/systemd/system/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash">  启动服务</span></span><br><span class="line">  systemctl enable supervisord</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">  echo &quot;请在 root权限下安装，supervisor&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="pip源修改pip-conf"><a href="#pip源修改pip-conf" class="headerlink" title="pip源修改pip.conf"></a>pip源修改pip.conf</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[global] </span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple/ </span><br><span class="line">[install] </span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure><h2 id="supervisord-service-文件"><a href="#supervisord-service-文件" class="headerlink" title="supervisord.service 文件"></a>supervisord.service 文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit] </span><br><span class="line">Description=Supervisor daemon</span><br><span class="line"></span><br><span class="line">[Service] </span><br><span class="line">Type=forking </span><br><span class="line">ExecStart=/usr/local/bin/supervisord -c /etc/supervisord.conf</span><br><span class="line">ExecStop=/usr/local/bin/supervisorctl shutdown</span><br><span class="line">ExecReload=/usr/local/bin/supervisorctl reload</span><br><span class="line">KillMode=process </span><br><span class="line">Restart=on-failure </span><br><span class="line">RestartSec=42s</span><br><span class="line"></span><br><span class="line">[Install] </span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌开发工具的使用</title>
      <link href="/archives/63c75ff8.html"/>
      <url>/archives/63c75ff8.html</url>
      
        <content type="html"><![CDATA[<p>合理的运用好工具，再开发中的效率会有成倍的增长</p><h2 id="Elements-栏使用"><a href="#Elements-栏使用" class="headerlink" title="Elements 栏使用"></a>Elements 栏使用</h2><p>简介：渲染后的代码，搜索，定位元素，调试样式 </p><a id="more"></a><h2 id="Console-栏使用"><a href="#Console-栏使用" class="headerlink" title="Console 栏使用"></a>Console 栏使用</h2><p>简介： 命令行，js交互模式，</p><h2 id="Sources-栏使用"><a href="#Sources-栏使用" class="headerlink" title="Sources 栏使用"></a>Sources 栏使用</h2><p>简介： 用来调试和定位js代码，快速分析和逆向解析</p><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>简介： 主要用来抓包，分析url参数</p><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>简介： 查看cookie，数据缓存 参数</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 介绍 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM的增删改查</title>
      <link href="/archives/c229250e.html"/>
      <url>/archives/c229250e.html</url>
      
        <content type="html"><![CDATA[<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><h4 id="1-createElement"><a href="#1-createElement" class="headerlink" title="1. createElement"></a>1. createElement</h4><p>传件自定义标签，IE8以下浏览器不支持自定义标签</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="built_in">document</span>.createElement(<span class="string">&#x27;cat&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中;</p></blockquote><h4 id="2-createTexNode"><a href="#2-createTexNode" class="headerlink" title="2. createTexNode"></a>2. createTexNode</h4><p>创建一个文本节点</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> textCont = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;一个textCont&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>createTextNode</code>接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要append Child将其添加到HTML文档树中</p></blockquote><h4 id="3-cloneNode"><a href="#3-cloneNode" class="headerlink" title="3. cloneNode"></a>3. cloneNode</h4><p><code>cloneNode</code>是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">&quot;parentElement&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> parent2 = parent.cloneNode(<span class="literal">true</span>);<span class="comment">// 传入true</span></span><br><span class="line">parent2.id = <span class="string">&quot;parent2&quot;</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="4-createDocumentFragment"><a href="#4-createDocumentFragment" class="headerlink" title="4. createDocumentFragment"></a>4. createDocumentFragment</h4><p>createDocumentFragment方法用来创建一个DocumentFragment。在前面我们说到DocumentFragment表示一种轻量级的文档，它的作用主要是存储临时的节点用来准备添加到文档中<br>createDocumentFragment方法主要是用于添加大量节点到文档中时会使用到。假设要循环一组数据，然后创建多个节点添加到文档中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;ul id=<span class="string">&quot;list&quot;</span>&gt;&lt;/ul&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;添加多项&quot;</span> id=<span class="string">&quot;btnAdd&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;btnAdd&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        li.textContent = i;</span><br><span class="line">        list.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这段代码将按钮绑定了一个事件，这个事件创建了100个li节点，然后依次将其添加HTML文档中。</span></span><br><span class="line"><span class="comment">这样做有一个缺点：每次一创建一个新的元素，然后添加到文档树中，这个过程会造成浏览器的回流。</span></span><br><span class="line"><span class="comment">所谓回流简单说就是指元素大小和位置会被重新计算，如果添加的元素太多，会造成性能问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 修改，保存在内存中，  不会造成回流</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;btnAdd&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">&quot;list&quot;</span>);    </span><br><span class="line">    <span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        li.textContent = i;</span><br><span class="line">        fragment.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">    list.appendChild(fragment);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优化后的代码主要是创建了一个fragment，每次生成的li节点先添加到fragment，最后一次性添加到list</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><ul><li>它们创建的节点只是一个孤立的节点，</li><li>要通过appendChild添加到文档中</li><li>cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题</li><li>使用createDocumentFragment来解决添加大量节点时的性能问题</li></ul></blockquote></blockquote><h2 id="页面修改，删除"><a href="#页面修改，删除" class="headerlink" title="页面修改，删除"></a>页面修改，删除</h2><h4 id="1-appendChild-追加为子元素"><a href="#1-appendChild-追加为子元素" class="headerlink" title="1. appendChild(追加为子元素)"></a>1. appendChild(追加为子元素)</h4><h4 id="2-insertBefore-插入前面"><a href="#2-insertBefore-插入前面" class="headerlink" title="2. insertBefore(插入前面)"></a>2. insertBefore(插入前面)</h4><h4 id="3-removeChild-删除子元素"><a href="#3-removeChild-删除子元素" class="headerlink" title="3. removeChild(删除子元素)"></a>3. removeChild(删除子元素)</h4><h4 id="4-replaceChild-替换子元素"><a href="#4-replaceChild-替换子元素" class="headerlink" title="4. replaceChild(替换子元素)"></a>4. replaceChild(替换子元素)</h4><h2 id="查，-选择器"><a href="#查，-选择器" class="headerlink" title="查， 选择器"></a>查， 选择器</h2><ol><li><code>document.getElementById(&#39;box&#39;)</code>   </li><li><code>document.getElementsByTagName(&#39;div&#39;)</code></li><li><code>document.getElementsByClassName(&#39;cp&#39;)</code></li><li><code>document.querySelector(&#39;#box&#39;)</code>||<code>document.querySelectorAll(&#39;.cp&#39;)</code>;</li><li><code>document.getElementsByName(&#39;x&#39;)</code>; // 返回name属性为x的伪数组</li></ol><h2 id="元素属性型操作（属性节点的操作）"><a href="#元素属性型操作（属性节点的操作）" class="headerlink" title="元素属性型操作（属性节点的操作）"></a>元素属性型操作（属性节点的操作）</h2><ol><li><code>getAttribute(name)</code>用于获取元素的属性值</li><li><code>createAttribute(name)</code>方法生成一个新的属性对象节点，并返回它。</li><li><code>setAttribute(name, value)</code>方法用于设置元素属性</li><li><code>removeAttribute(name)</code>用于删除元素属性</li><li><code>element.attributes</code>（将属性生成数组对象）</li></ol><h2 id="innerText和innerHTML（outerHTML）区别？"><a href="#innerText和innerHTML（outerHTML）区别？" class="headerlink" title="innerText和innerHTML（outerHTML）区别？"></a>innerText和innerHTML（outerHTML）区别？</h2><ul><li>innerText返回的是元素内包含的文本内容（只返回文本节点类型）；</li><li>innerHTML返会元素内HTML结构，包括元素节点、注释节点、文本节点；</li><li>outerHTML返回包括元素节点自身和里面的所有元素节点、注释节点、文本节点；</li></ul><p><img src="/images/js/js-DOM.gif" alt="js-DOM"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-Python操作</title>
      <link href="/archives/f6341479.html"/>
      <url>/archives/f6341479.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>redis 的一些常用命令，与python的交互</p></blockquote><p><a href="https://rdbtools.com/docs/install/windows/">redis性能分析软件</a></p><h3 id="查看redis内存大小"><a href="#查看redis内存大小" class="headerlink" title="查看redis内存大小"></a>查看redis内存大小</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; select <span class="number">6</span> <span class="comment"># 指定db库</span></span><br><span class="line">&gt;&gt; INFO MEMORY  <span class="comment"># 查看</span></span><br></pre></td></tr></table></figure><h4 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis  </span><br><span class="line"><span class="comment"># 连接redis</span></span><br><span class="line">client =redis.StrictRedis(host=<span class="string">&#x27;&#x27;</span>,port=<span class="string">&#x27;&#x27;</span>,db=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----- (1)直接连接 --------</span></span><br><span class="line"> <span class="comment"># 导入redis模块，通过python操作redis 也可以直接在redis主机的服务端操作缓存数据库</span></span><br><span class="line"><span class="comment">#加上decode_responses=True，写入的键值对中的value为str类型，不加这个参数写入的则为字节类型。</span></span><br><span class="line">r = redis.Redis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, decode_responses=<span class="literal">True</span>)   <span class="comment"># host是redis主机，需要redis服务端和客户端都启动 redis默认端口是6379</span></span><br><span class="line">r.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;junxi&#x27;</span>)  <span class="comment"># key是&quot;foo&quot; value是&quot;bar&quot; 将键值对存入redis缓存</span></span><br><span class="line">print(r[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">print(r.get(<span class="string">&#x27;name&#x27;</span>))  <span class="comment"># 取出键name对应的值</span></span><br><span class="line">print(type(r.get(<span class="string">&#x27;name&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#-----（2）连接池 ---------</span></span><br><span class="line"></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, decode_responses=<span class="literal">True</span>)   <span class="comment"># host是redis主机，需要redis服务端和客户端都起着 redis默认端口是6379</span></span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line">r.set(<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;male&#x27;</span>)     <span class="comment"># key是&quot;gender&quot; value是&quot;male&quot; 将键值对存入redis缓存</span></span><br><span class="line">print(r.get(<span class="string">&#x27;gender&#x27;</span>))      <span class="comment"># gender 取出键male对应的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -----redis 基本命令 String -----------</span></span><br><span class="line"></span><br><span class="line">set(name, value, ex=<span class="literal">None</span>, px=<span class="literal">None</span>, nx=<span class="literal">False</span>, xx=<span class="literal">False</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ex，过期时间（秒）</span></span><br><span class="line"><span class="string">px，过期时间（毫秒）</span></span><br><span class="line"><span class="string">nx，如果设置为True，则只有name不存在时，当前set操作才执行</span></span><br><span class="line"><span class="string">xx，如果设置为True，则只有name存在时，当前set操作才执行</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># -----redis 集群连接------</span></span><br><span class="line"><span class="keyword">from</span> rediscluster <span class="keyword">import</span> StrictRedisCluster</span><br><span class="line"><span class="comment">### 存在 redis-py-cluster 和redis 版本要对应， 不然会导入不了StrictRedisCluster包</span></span><br><span class="line">client =  StrictRedisCluster(startup_nodes=REDIS_HOSTS, decode_responses=<span class="literal">True</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="comment">#  redis==2.10.6</span></span><br><span class="line"><span class="comment">#  redis-py-cluster==1.3.4   </span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="redis字符串Strings"><a href="#redis字符串Strings" class="headerlink" title="redis字符串Strings"></a>redis字符串Strings</h3><blockquote><p>Python操作Redis的redis模块对字符串（string）的主要操作函数包括：SET、GET、GETSET、SETEX、SETNX、MSET、MSETNX、INCR(INCRBY,DECR,DECRBY在python中庸同一个函数incr实现)、APPEND、SETRANGE、STRLEN。函数说明如下：</p></blockquote><ul><li>SET： 为指定的键（key）设置值（value）， set(self, name, value, **kwargs)。</li><li>GET：获取指定键（key）绑定的值（value），get(self, name)。</li><li>GETSET：为指定的键（key）设置新的值（value），并返回旧的值（old Value），getset(self, name, value)</li><li>SETEX：为指定的键（key）设置过期以秒（second）计的过期时间，setex(self, name, value, time)</li><li>SETNX：键（key）不存在时，为键（key）指定值（value），setnx(self, name, value)</li><li>MSET：一次性设置多个键-值(key-value)对,函数设置的键-值对（即mapping所指内容）数据要以Python字典数据类型传入，mset(self, mapping)</li><li>MSETNX：键-值(key-value)对不存在时，设置键-值（key-value）对,msetnx(self, mapping)，mapping值参考6</li><li>INCR：自增函数，默认步长为1，通过对步长（amount）大小以及字符的控制实现了INCRBY（amount&gt;=1）、DECR（amount=-1）、DECRBY（amount&lt;=-1）等函数功能，incr(self, name, amount=1)</li><li>APPEND：为指定的字符串追加值，若不存在则直接创建，append(self, key, value)</li><li>SETRANGE：用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始，setrange(self, name, offset, value)</li><li>STRLEN：返回字符串的长度，当name不存在时返回0，strlen(self, name)</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>,decode_responses=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">## pool = redis.StrictRedis(host=&#x27;127.0.0.1&#x27;, port=6379,decode_responses=True)</span></span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line">r.flushall()  <span class="comment"># 清空Redis</span></span><br><span class="line"></span><br><span class="line">r.setex(<span class="string">&#x27;name&#x27;</span>, value=<span class="string">&#x27;liaogx&#x27;</span>, time=<span class="number">2</span>)  <span class="comment"># 设置新值，过期时间为3s</span></span><br><span class="line">r.mset(k1 = <span class="string">&#x27;v1&#x27;</span>, k2 = <span class="string">&#x27;v2&#x27;</span>, k3 = <span class="string">&#x27;v3&#x27;</span>)  <span class="comment"># 批量设置新值</span></span><br><span class="line">print(r.mget(<span class="string">&#x27;k1&#x27;</span>, <span class="string">&#x27;k2&#x27;</span>, <span class="string">&#x27;k3&#x27;</span>, <span class="string">&#x27;k4&#x27;</span>))  <span class="comment"># 批量获取新值</span></span><br><span class="line">print(r.getset(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;liaogaoxiang&#x27;</span>))  <span class="comment"># 设置新值并获取原来的值</span></span><br><span class="line">print(r.getrange(<span class="string">&#x27;name&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>))  <span class="comment"># 获取子序列 0 &lt;= x &lt;= 1</span></span><br><span class="line">r.setrange(<span class="string">&#x27;name&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;LIAO&#x27;</span>)  <span class="comment"># 修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加），返回值的长度</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">4</span>:</span><br><span class="line">    print(r.get(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">source = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">r.set(<span class="string">&#x27;n1&#x27;</span>, source)</span><br><span class="line">r.setbit(<span class="string">&#x27;n1&#x27;</span>, <span class="number">7</span>, <span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">注：如果在Redis中有一个对应： n1 = &quot;foo&quot;，</span></span><br><span class="line"><span class="string">    那么字符串foo的二进制表示为：01100110 01101111 01101111</span></span><br><span class="line"><span class="string">    所以，如果执行 setbit(&#x27;n1&#x27;, 7, 1)，则就会将第7位设置为1，</span></span><br><span class="line"><span class="string">    那么最终二进制则变成 01100111 01101111 01101111，即：&quot;goo&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">print(r.get(<span class="string">&#x27;n1&#x27;</span>))</span><br><span class="line">print(r.getbit(<span class="string">&#x27;n1&#x27;</span>, <span class="number">7</span>))  <span class="comment"># 获取n1对应的值的二进制表示中的某位的值 （0或1）</span></span><br><span class="line">r.set(<span class="string">&#x27;n2&#x27;</span>, <span class="string">&#x27;廖高祥&#x27;</span>)</span><br><span class="line">print(r.strlen(<span class="string">&#x27;n2&#x27;</span>))  <span class="comment"># 返回对应的字节长度（一个汉字3个字节）</span></span><br><span class="line">r.set(<span class="string">&#x27;num&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">r.incr(<span class="string">&#x27;num&#x27;</span>, amount=<span class="number">10</span>)</span><br><span class="line">r.decr(<span class="string">&#x27;num&#x27;</span>, amount=<span class="number">1</span>)</span><br><span class="line">print(r.get(<span class="string">&#x27;num&#x27;</span>))  <span class="comment"># 自增num对应的值，当name不存在时，则创建name＝amount，否则，则自增。</span></span><br><span class="line">r.append(<span class="string">&#x27;num&#x27;</span>, <span class="number">111</span>)</span><br><span class="line">print(r.get(<span class="string">&#x27;num&#x27;</span>))  <span class="comment"># 在redis num对应的值后面追加内容</span></span><br></pre></td></tr></table></figure><h3 id="redis列表list"><a href="#redis列表list" class="headerlink" title="redis列表list"></a>redis列表list</h3><blockquote><p>Python操作Redis主要利用了redis模块来实现，list表操作函数主要模拟了Redis操作命令LPUSH，LRANGE，LINDEX，BLPOP，BRPOP。函数说明如下：</p></blockquote><ul><li>lpush函数实现了从向指定redis列表头部压入数据功能，lpush key value</li><li>lrange获取列表指定范围的函数，lrange key start end</li><li>lindex根据列表下标量获取列表元素值， lindex key index</li><li>blpop从列表头部取出第一个元素，返回该元素值并从列表删除（l代表left，左边）</li><li>brpop从列表尾部取出第一个元素，返回该元素值并从列表删除（l代表right，右边）</li><li>LPUSHX、RPUSHX以及其他一些Redis列表（List）函数目前版本无法实现，如有可实现方法博客代码事例将会得到更新。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>,decode_responses=<span class="literal">True</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line">r.flushall()  <span class="comment"># 清空Redis</span></span><br><span class="line"></span><br><span class="line">r.lpush(<span class="string">&#x27;oo&#x27;</span>, <span class="number">11</span>)  <span class="comment"># 保存顺序为: 33,22,11</span></span><br><span class="line">r.lpushx(<span class="string">&#x27;oo&#x27;</span>, <span class="number">00</span>)  <span class="comment"># 在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边</span></span><br><span class="line">print(r.llen(<span class="string">&#x27;oo&#x27;</span>))  <span class="comment"># name对应的list元素的个数</span></span><br><span class="line"></span><br><span class="line">r.linsert(<span class="string">&#x27;oo&#x27;</span>, <span class="string">&#x27;before&#x27;</span>, <span class="number">11</span>, <span class="number">99</span>)  <span class="comment"># 在11之前插入值99</span></span><br><span class="line">r.lset(<span class="string">&#x27;oo&#x27;</span>, <span class="number">1</span>, <span class="number">88</span>)  <span class="comment"># 对name对应的list中的某一个索引位置重新赋值</span></span><br><span class="line">print(r.lrange(<span class="string">&#x27;oo&#x27;</span>, <span class="number">0</span>, <span class="number">-1</span>))  <span class="comment"># 在name对应的列表分片获取数据</span></span><br><span class="line"></span><br><span class="line">r.lrem(<span class="string">&#x27;oo&#x27;</span>, <span class="number">88</span>, num=<span class="number">1</span>)  <span class="comment"># 在name对应的list中删除指定的值.num=0，删除列表中所有的指定值；num=2,从前到后，删除2个；num=-2,从后向前，删除2个</span></span><br><span class="line">print(r.lrange(<span class="string">&#x27;oo&#x27;</span>, <span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">print(r.lpop(<span class="string">&#x27;oo&#x27;</span>))  <span class="comment"># 在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素</span></span><br><span class="line">print(r.lindex(<span class="string">&#x27;oo&#x27;</span>, <span class="number">0</span>))  <span class="comment"># 在name对应的列表中根据索引获取列表元素</span></span><br><span class="line">r.lpush(<span class="string">&#x27;l1&#x27;</span>, <span class="number">11</span>)  <span class="comment"># index为0</span></span><br><span class="line">r.rpush(<span class="string">&#x27;l1&#x27;</span>, <span class="number">22</span>)</span><br><span class="line">r.rpush(<span class="string">&#x27;l1&#x27;</span>, <span class="number">33</span>)</span><br><span class="line">r.rpush(<span class="string">&#x27;l1&#x27;</span>, <span class="number">44</span>)</span><br><span class="line">r.rpush(<span class="string">&#x27;l1&#x27;</span>, <span class="number">55</span>)  <span class="comment"># index为4</span></span><br><span class="line">r.ltrim(<span class="string">&#x27;l1&#x27;</span>, <span class="number">1</span>, <span class="number">3</span>)  <span class="comment"># 在name对应的列表中移除没有在[start-end]索引之间的值</span></span><br><span class="line">print(r.lrange(<span class="string">&#x27;l1&#x27;</span>, <span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">r.rpoplpush(<span class="string">&#x27;l1&#x27;</span>, <span class="string">&#x27;l1&#x27;</span>)  <span class="comment"># 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边;src要取数据的列表的name, dst要添加数据的列表的name</span></span><br><span class="line">print(r.lrange(<span class="string">&#x27;l1&#x27;</span>, <span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">r.brpoplpush(<span class="string">&#x27;l1&#x27;</span>, <span class="string">&#x27;l1&#x27;</span>, timeout=<span class="number">3</span>)  <span class="comment"># # timeout，当src对应的列表中没有数据时，阻塞等待其有数据的超时时间（秒），0 表示永远阻塞</span></span><br><span class="line">print(r.lrange(<span class="string">&#x27;l1&#x27;</span>, <span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">print(r.blpop(<span class="string">&#x27;l1&#x27;</span>, <span class="number">3</span>))  <span class="comment"># 从列表头部取出第一个元素，返回该元素值并从列表删除（l代表left，左边）</span></span><br><span class="line">print(r.lrange(<span class="string">&#x27;l1&#x27;</span>, <span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    # 由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要：</span></span><br><span class="line"><span class="string">    # 1、获取name对应的所有列表</span></span><br><span class="line"><span class="string">    # 2、循环列表</span></span><br><span class="line"><span class="string">    # 但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">print(<span class="string">&#x27;自定义增量迭代：&#x27;</span>)</span><br><span class="line">r.flushall()</span><br><span class="line">r.lpush(<span class="string">&#x27;l1&#x27;</span>, <span class="number">11</span>)  <span class="comment"># index为0</span></span><br><span class="line">r.rpush(<span class="string">&#x27;l1&#x27;</span>, <span class="number">22</span>)</span><br><span class="line">r.rpush(<span class="string">&#x27;l1&#x27;</span>, <span class="number">33</span>)</span><br><span class="line">r.rpush(<span class="string">&#x27;l1&#x27;</span>, <span class="number">44</span>)</span><br><span class="line">r.rpush(<span class="string">&#x27;l1&#x27;</span>, <span class="number">55</span>)  <span class="comment"># index为4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_iter</span>(<span class="params">name</span>):</span></span><br><span class="line">    list_count = r.llen(name)</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(list_count):</span><br><span class="line">        <span class="keyword">yield</span> r.lindex(name, index)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> list_iter(<span class="string">&#x27;l1&#x27;</span>):</span><br><span class="line">    print(item)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="redis集合sets"><a href="#redis集合sets" class="headerlink" title="redis集合sets"></a>redis集合sets</h3><blockquote><p>Redis 数据库集合对象(set object)是由string类型的无重复元素的无需集合，底层编码可以是intset或者hashtable。intset编码的集合对象用整数集合最为底层实现，所有对象元素保存在整数集合中。Python的redis模块实现了 SADD、SCARD 、SDIFF 、SDIFFSTORE、SINTER 、SINTERSTORE、SISMEMBER 、SMEMBERS 、SMOVE、SPOP、SRANDMEMBER、SREM、SUNION、SUNIONSTORE操作命令的基本用法。函数说明如下：</p></blockquote><ul><li>SADD：向集合对象添加成员，sadd(self, name, value)</li><li>SCARD：获取集合元素个数，scard(self, name)</li><li>SDIFF：返回给定多个集合对象的差集(set key1-set key2..-set keyn)，从左到右计算集合差集，sdiff(self, keys, *args)</li><li>SDIFFSTORE：返回给定给定多个集合对象的差集并存储在目标（dest）集合中，sdiffstore(self, dest, keys, *args)</li><li>SINTER：返回给定所有集合（keys, args）的交集, sinter(self, keys, args)</li><li>SINTERSTORE：返回给定所有集合（keys, args）的交集并存储在 集合(dest) 中, sinterstore(self, dest, keys, args)</li><li>SISMEMBER：判断 value元素是否是集合 name 的成员,返回布尔逻辑值True或者False，sismember(self, name, value)</li><li>SMEMBERS：返回集合中所元素值的Python集合类型数据，smembers(self, name)</li><li>SMOVE：将元素value从集合src移动到 集合 dest。若元素value在集合src中不存在，则集合dest中不会添加元素value， smove(self, src, dest, value)</li><li>SPOP：移除并返回集合中的一个随机元素, spop(self, name)</li><li>SRANDMEMBER：返回集合中一个随机数，但是不做移除操作, srandmember(self, name)。从Redis 2.6 版本开始， 在命令行下Srandmember 命令接受可选返回元素数量的参数 redis&gt;SRANDMEMBER name count</li><li>SREM：移除集合中一个元素，srem(self, name, value)，redis模块任然沿用Redis 2.4 版本以前的只接受单个元素的用法。</li><li>SUNION：返回所有给定集合的并集中所有元素，sunion(self, keys, *args)</li><li>SUNIONSTORE：所有给定集合的并集存储在集合dest 中, sunionstore(self, dest, keys, *args)</li><li>SSCAN：迭代集合中的元素，sscan(self, name, cursor=0, match=None, count=None)</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line">r.flushall()  <span class="comment"># 清空Redis</span></span><br><span class="line"></span><br><span class="line">r.sadd(<span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;v1&#x27;</span>, <span class="string">&#x27;v1&#x27;</span>, <span class="string">&#x27;v2&#x27;</span>, <span class="string">&#x27;v3&#x27;</span>)  <span class="comment"># name对应的集合中添加元素</span></span><br><span class="line">r.sadd(<span class="string">&#x27;s2&#x27;</span>, <span class="string">&#x27;v2&#x27;</span>, <span class="string">&#x27;v4&#x27;</span>)  <span class="comment"># name对应的集合中添加元素</span></span><br><span class="line">print(r.scard(<span class="string">&#x27;s1&#x27;</span>))  <span class="comment"># 获取name对应的集合中元素个数</span></span><br><span class="line">print(r.sdiff(<span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>))  <span class="comment">#在第一个name对应的集合中且不在其他name对应的集合的元素集合</span></span><br><span class="line"></span><br><span class="line">r.sdiffstore(<span class="string">&#x27;s3&#x27;</span>, <span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>)  <span class="comment"># 获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中</span></span><br><span class="line">print(r.smembers(<span class="string">&#x27;s3&#x27;</span>))  <span class="comment"># 获取s3对应的集合的所有成员</span></span><br><span class="line"></span><br><span class="line">print(r.sinter(<span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>))  <span class="comment"># 获取s1, s2对应集合的交集</span></span><br><span class="line">r.sinterstore(<span class="string">&#x27;s4&#x27;</span>, <span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>)  <span class="comment"># 获取s1, s2对应集合的交集，并将其存放到集合是s4中</span></span><br><span class="line">print(r.smembers(<span class="string">&#x27;s4&#x27;</span>))</span><br><span class="line"></span><br><span class="line">print(r.sunion(<span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>))  <span class="comment"># 获取s1, s2对应集合的并集</span></span><br><span class="line"></span><br><span class="line">r.sunionstore(<span class="string">&#x27;s5&#x27;</span>, <span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;s2&#x27;</span>)  <span class="comment"># 获取s1, s2对应集合的交集，并将其存放到集合是s5中</span></span><br><span class="line">print(r.smembers(<span class="string">&#x27;s5&#x27;</span>))</span><br><span class="line"></span><br><span class="line">print(r.sismember(<span class="string">&#x27;s4&#x27;</span>, <span class="string">&#x27;v4&#x27;</span>))  <span class="comment"># 检查value是否是name对应的集合的成员</span></span><br><span class="line"></span><br><span class="line">r.smove(<span class="string">&#x27;s2&#x27;</span>, <span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;v4&#x27;</span>)  <span class="comment"># 将集合s2中成员v4移至集合s1中</span></span><br><span class="line">print(r.smembers(<span class="string">&#x27;s1&#x27;</span>))</span><br><span class="line">r.srem(<span class="string">&#x27;s1&#x27;</span>, <span class="string">&#x27;v1&#x27;</span>)  <span class="comment"># 在name对应的集合中删除某些值</span></span><br><span class="line"></span><br><span class="line">print(r.spop(<span class="string">&#x27;s1&#x27;</span>))  <span class="comment"># 从集合的右侧（尾部）移除一个成员，并将其返回 注意：集合是无序的，故结果随机！</span></span><br><span class="line"></span><br><span class="line">print(r.srandmember(<span class="string">&#x27;s1&#x27;</span>))  <span class="comment"># 从name对应的集合中随机获取 numbers 个元素(Redis 2.6+)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="有序集合-sortrd-sets"><a href="#有序集合-sortrd-sets" class="headerlink" title="有序集合 sortrd sets"></a>有序集合 sortrd sets</h3><ul><li>Redis Zadd 命令    向有序集合添加一个或多个成员，或者更新已存在成员的分数</li><li>Redis Zcard 命令    获取有序集合的成员数</li><li>Redis Zcount 命令    计算在有序集合中指定区间分数的成员数</li><li>Redis Zincrby 命令    有序集合中对指定成员的分数加上增量 increment</li><li>Redis Zinterstore 命令    计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</li><li>Redis Zlexcount 命令    在有序集合中计算指定字典区间内成员数量</li><li>Redis Zrange 命令    通过索引区间返回有序集合成指定区间内的成员</li><li>Redis Zrangebylex 命令    通过字典区间返回有序集合的成员</li><li>Redis Zrangebyscore 命令    通过分数返回有序集合指定区间内的成员</li><li>Redis Zrank 命令    返回有序集合中指定成员的索引</li><li>Redis Zrem 命令    移除有序集合中的一个或多个成员</li><li>Redis Zremrangebylex 命令    移除有序集合中给定的字典区间的所有成员</li><li>Redis Zremrangebyrank 命令    移除有序集合中给定的排名区间的所有成员</li><li>Redis Zremrangebyscore 命令    移除有序集合中给定的分数区间的所有成员</li><li>Redis Zrevrange 命令    返回有序集中指定区间内的成员，通过索引，分数从高到底</li><li>Redis Zrevrangebyscore 命令    返回有序集中指定分数区间内的成员，分数从高到低排序</li><li>Redis Zrevrank 命令    返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</li><li>Redis Zscore 命令    返回有序集中，成员的分数值</li><li>Redis Zunionstore 命令    计算给定的一个或多个有序集的并集，并存储在新的 key 中</li><li>Redis Zscan 命令    迭代有序集合中的元素（包括元素成员和元素分值）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line">r.flushall()  <span class="comment"># 清空Redis</span></span><br><span class="line"></span><br><span class="line">r.zadd(<span class="string">&#x27;z1&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;22&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;33&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;44&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;55&#x27;</span>, <span class="number">5</span>, <span class="string">&#x27;66&#x27;</span>, <span class="number">6</span>, <span class="string">&#x27;66&#x27;</span>, <span class="number">7</span>)  <span class="comment"># 在name对应的有序集合中添加元素</span></span><br><span class="line">print(r.zcard(<span class="string">&#x27;z1&#x27;</span>))  <span class="comment"># 获取name对应的有序集合元素的数量</span></span><br><span class="line">print(r.zcount(<span class="string">&#x27;z1&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 获取name对应的有序集合中分数 在 [min,max] 之间的个数</span></span><br><span class="line">r.zincrby(<span class="string">&#x27;z1&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, amount=<span class="number">5</span>)  <span class="comment"># 自增name对应的有序集合的 name 对应的分数</span></span><br><span class="line">print(r.zrange(<span class="string">&#x27;z1&#x27;</span>, <span class="number">0</span>, <span class="number">-1</span>, desc=<span class="literal">False</span>, withscores=<span class="literal">True</span>))  <span class="comment"># 值11被排序到最后;此处表示按元素的值升序排列</span></span><br><span class="line"></span><br><span class="line">print(r.zrank(<span class="string">&#x27;z1&#x27;</span>, <span class="number">33</span>))  <span class="comment"># 获取某个值在 name对应的有序集合中的排行（从 0 开始）</span></span><br><span class="line"></span><br><span class="line">r.zrem(<span class="string">&#x27;z1&#x27;</span>, <span class="string">&#x27;66&#x27;</span>)  <span class="comment"># 删除name对应的有序集合中值是values的成员</span></span><br><span class="line">print(r.zrange(<span class="string">&#x27;z1&#x27;</span>, <span class="number">0</span>, <span class="number">-1</span>, desc=<span class="literal">False</span>, withscores=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">r.zremrangebyrank(<span class="string">&#x27;z1&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>)  <span class="comment"># 根据排行范围删除</span></span><br><span class="line">print(r.zrange(<span class="string">&#x27;z1&#x27;</span>, <span class="number">0</span>, <span class="number">-1</span>, desc=<span class="literal">False</span>, withscores=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">r.zremrangebyscore(<span class="string">&#x27;z1&#x27;</span>, <span class="number">4.5</span>, <span class="number">5.5</span>)  <span class="comment"># 根据分数范围删除</span></span><br><span class="line">print(r.zrange(<span class="string">&#x27;z1&#x27;</span>, <span class="number">0</span>, <span class="number">-1</span>, desc=<span class="literal">False</span>, withscores=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">print(r.zscore(<span class="string">&#x27;z1&#x27;</span>, <span class="number">11</span>))  <span class="comment"># 获取name对应有序集合中 value 对应的分数</span></span><br><span class="line"></span><br><span class="line">r.zadd(<span class="string">&quot;zset_name&quot;</span>, <span class="string">&quot;a1&quot;</span>, <span class="number">6</span>, <span class="string">&quot;a2&quot;</span>, <span class="number">2</span>, <span class="string">&quot;a3&quot;</span>, <span class="number">5</span>)</span><br><span class="line">r.zadd(<span class="string">&#x27;zset_name1&#x27;</span>, a1=<span class="number">7</span>, b1=<span class="number">10</span>, b2=<span class="number">5</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作</span></span><br><span class="line"><span class="string">    aggregate的值为: SUM  MIN  MAX</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">r.zinterstore(<span class="string">&#x27;zset_name2&#x27;</span>, (<span class="string">&#x27;zset_name&#x27;</span>, <span class="string">&#x27;zset_name1&#x27;</span>), aggregate=<span class="string">&#x27;Sum&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(r.zrange(<span class="string">&#x27;zset_name2&#x27;</span>, <span class="number">0</span>, <span class="number">-1</span>, desc=<span class="literal">False</span>, withscores=<span class="literal">True</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="redis-哈希-hashes"><a href="#redis-哈希-hashes" class="headerlink" title="redis 哈希 hashes"></a>redis 哈希 hashes</h3><blockquote><p>Redis 数据库hash数据类型是一个string类型的key和value的映射表，适用于存储对象。redis 中每个hash可以存储键值对多达40亿。Python的redis模块实现了Redis哈希（Hash）命令行操作的几乎全部命令，包括HDEL、HEXISTS、HGET、HGETALL、HINCRBY、HKEYS、HLEN 、HMGET 、HMSET 、HSET 、HSETNX 、HVALS 、HINCRBYFLOAT等命令。函数说明如下：</p></blockquote><ul><li>HDEL：删除对应哈希（Hash）表的指定键（key）的字段，hdel(self, name, key)</li><li>HEXISTS：检测哈希（Hash）表对应键（key）字段是否存在，返回布尔逻辑，hexists(self, name, key)</li><li>HGET：获取哈希（Hash）指定键（key）对应的值，hget(self, name, key)</li><li>HGETALL：获取哈希(Hash)表的键-值对（key-value pairs）,返回python字典类型数据，hgetall(self, name)</li><li>HINCRBY：为哈希表（Hash）指定键（key）对应的值（key）加上指定的整数数值（int，可为负值）hincrby(self&gt;, name, key, amount=1)，Redis 中本操作的值被限制在 64 位(bit)有符号数字。</li><li>HKEYS：返回哈希表（Hash）对应键（key）的数组（Python称之为列表List），hkeys(self, name)</li><li>HLEN： 获取哈希表（Hash）中键-值对（key-value pairs）个数，hlen(self, name)</li><li>HMGET：获取哈希表（Hash）中一个或多个给点字段的值，不存在返回nil(Redis命令行)/None(Python)，hmget(self, name, keys)，其中keys可以为列表（list）</li><li>HMSET：设置对个键-值对（key-value pairs）到哈希表（Hash）中，python输入值（mapping）为字典（dictionary）类型，hmset(self, name, mapping)</li><li>HSET：为哈希表（Hash）赋值，若键（key）存在值（value）则覆盖，不存在则创建，hset(self, name, key, value)</li><li>HSETNX：为哈希表（Hash）不存值（value）的键（key）赋值，存在操作无效，对应值（value）无变化，hsetnx(self, name, key, value)</li><li>HVALS：返回哈希表（Hash）对应值（value）的列表，hvals(self, name)</li><li>HINCRBYFLOAT：为哈希表 key 中的指定字段的浮点数值加上增量 increment ，hincrbyfloat(self, name, key, amount=1.0)</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line">r.flushall()  <span class="comment"># 清空Redis</span></span><br><span class="line"></span><br><span class="line">r.hset(<span class="string">&#x27;n1&#x27;</span>, <span class="string">&#x27;k1&#x27;</span>, <span class="string">&#x27;v1&#x27;</span>)  <span class="comment"># hset(name, key, value),name对应的hash中设置一个键值对（不存在，则创建；否则，修改）</span></span><br><span class="line">print(r.hget(<span class="string">&#x27;n1&#x27;</span>, <span class="string">&#x27;k1&#x27;</span>))</span><br><span class="line">r.hmset(<span class="string">&#x27;n2&#x27;</span>, &#123;<span class="string">&#x27;k1&#x27;</span>: <span class="string">&#x27;v1&#x27;</span>, <span class="string">&#x27;k2&#x27;</span>: <span class="string">&#x27;v2&#x27;</span>, <span class="string">&#x27;k3&#x27;</span>: <span class="string">&#x27;v3&#x27;</span>&#125;)  <span class="comment"># hmset(name, mapping),在name对应的hash中批量设置键值对</span></span><br><span class="line">print(r.hmget(<span class="string">&#x27;n2&#x27;</span>, <span class="string">&#x27;k2&#x27;</span>))</span><br><span class="line">print(r.hgetall(<span class="string">&#x27;n2&#x27;</span>))  <span class="comment"># 获取name对应hash的所有键值</span></span><br><span class="line">print(r.hlen(<span class="string">&#x27;n2&#x27;</span>))  <span class="comment"># 获取name对应的hash中键值对的个数</span></span><br><span class="line">print(r.hkeys(<span class="string">&#x27;n2&#x27;</span>))  <span class="comment"># 获取name对应的hash中所有的key的值</span></span><br><span class="line">print(r.hvals(<span class="string">&#x27;n2&#x27;</span>))  <span class="comment"># 获取name对应的hash中所有的value的值</span></span><br><span class="line">print(r.hexists(<span class="string">&#x27;n2&#x27;</span>, <span class="string">&#x27;k4&#x27;</span>)) <span class="comment"># 检查name对应的hash是否存在当前传入的key</span></span><br><span class="line">r.hdel(<span class="string">&#x27;n2&#x27;</span>, <span class="string">&#x27;k3&#x27;</span>)  <span class="comment"># 将name对应的hash中指定key的键值对删除</span></span><br><span class="line">r.hset(<span class="string">&#x27;n3&#x27;</span>, <span class="string">&#x27;k1&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">r.hincrby(<span class="string">&#x27;n3&#x27;</span>, <span class="string">&#x27;k1&#x27;</span>, amount=<span class="number">1</span>)  <span class="comment"># hincrby(name, key, amount=1),自增name对应的hash中的指定key的value的值，不存在则创建key=amount</span></span><br><span class="line">print(r.hgetall(<span class="string">&#x27;n3&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql数据库的配置安装</title>
      <link href="/archives/27a7b644.html"/>
      <url>/archives/27a7b644.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在安装mysql和使用，中出现的一些的问题，<br>自己找到并实际解决的方法做一下记录</p></blockquote><h3 id="MySQL数据库安装"><a href="#MySQL数据库安装" class="headerlink" title="MySQL数据库安装"></a>MySQL数据库安装</h3><h2 id="–windows下安装，下一步"><a href="#–windows下安装，下一步" class="headerlink" title="–windows下安装，下一步"></a>–windows下安装，下一步</h2><blockquote><p>或者下载 直接下载  <a href="https://www.xp.cn/">phpstudy_pro</a> 管理工具，带<code>redis</code>库</p></blockquote><h2 id="–liunx下安装–"><a href="#–liunx下安装–" class="headerlink" title="–liunx下安装–"></a>–liunx下安装–</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 网上资料 </span></span><br><span class="line">yum install mysql</span><br><span class="line">yum install mysql-server</span><br><span class="line">yum install mysql-devel</span><br><span class="line"><span class="comment">### 在安装mysql-server是出现报错 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Loaded plugins: fastestmirror</span></span><br><span class="line"><span class="string">Loading mirror speeds from cached hostfile</span></span><br><span class="line"><span class="string"> * base: mirrors.sina.cn</span></span><br><span class="line"><span class="string"> * extras: mirrors.sina.cn</span></span><br><span class="line"><span class="string"> * updates: mirrors.sina.cn</span></span><br><span class="line"><span class="string">No package mysql-server available.</span></span><br><span class="line"><span class="string">Error: Nothing to do&quot;&quot;&quot;</span></span><br><span class="line">方法一 安装 yum install mariadb-server mariadb </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mariadb数据库的相关命令是：</span></span><br><span class="line"><span class="string">systemctl start mariadb  #启动MariaDB</span></span><br><span class="line"><span class="string">systemctl stop mariadb  #停止MariaDB</span></span><br><span class="line"><span class="string">systemctl restart mariadb  #重启MariaDB</span></span><br><span class="line"><span class="string">systemctl enable mariadb  #设置开机启动</span></span><br><span class="line"><span class="string">所以先启动数据库</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">## 启动数据库，进入后感觉怪怪 的 mysql -u root -p</span></span><br><span class="line"></span><br><span class="line">放法二 官网下载mysql-server </span><br><span class="line"><span class="comment">## 下载地址  https://dev.mysql.com/downloads/repo/yum/ 找到适合版本的liunx</span></span><br><span class="line">rpm -ivh（安装软件包并显示安装进度） 版本 .rpn</span><br><span class="line">yum -y install mysql-community-server</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">service mysqld start (5.0版本是mysqld) 启动</span></span><br><span class="line"><span class="string">service mysql start (5.5.7版本是mysql)</span></span><br><span class="line"><span class="string">----停止----</span></span><br><span class="line"><span class="string">service mysqld stop</span></span><br><span class="line"><span class="string">----重启----</span></span><br><span class="line"><span class="string">service mysqld restart </span></span><br><span class="line"><span class="string">service mysql restart (5.5.7版本命令)</span></span><br><span class="line"><span class="string">----查看MySQL运行状态--</span></span><br><span class="line"><span class="string">systemctl status mysqld.service</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2、使用 mysqld 脚本启动：</span></span><br><span class="line"><span class="string">/etc/inint.d/mysqld stop</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">------------------初始登入-------&gt;</span><br><span class="line"><span class="comment">## 如果首次登入不上，需要查看一下零时密码</span></span><br><span class="line"><span class="comment">## 查看临时密码 grep &quot;password&quot; /var/log/mysqld.log </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用临死密码登入， 成功后</span></span><br><span class="line"><span class="string">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Root_12root&#x27;;</span></span><br><span class="line"><span class="string">只能先修改密码 不能进行任何操作，设置密码也有规范不能太简单</span></span><br><span class="line"><span class="string">先修改一个符合条件的密码 Root_12root</span></span><br><span class="line"><span class="string">查看密码设置条件 SHOW VARIABLES LIKE &#x27;validate_password%&#x27;;</span></span><br><span class="line"><span class="string">通过设置 </span></span><br><span class="line"><span class="string">set global validate_password.policy=0;</span></span><br><span class="line"><span class="string">set global validate_password.length=1;</span></span><br><span class="line"><span class="string">这样就可以修改简单密码了，在重置一下密码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;mysql&#x27;;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">----------------注-----</span><br><span class="line">如果使用方法二去覆盖方法一的安装， 此时会出现MySQL 服务器开不起来的解决方法</span><br><span class="line">出现错误 Failed to start MySQL Server</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">查看 cat /etc/my.cnf</span></span><br><span class="line"><span class="string">datadir=/var/lib/mysql</span></span><br><span class="line"><span class="string">socket=/var/lib/mysql/mysql.sock</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">删除--   rm -rf /var/lib/mysql/*</span></span><br><span class="line"><span class="string">在启动mysql服务器， 安装方法二的操作</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解决Navicat-连接MySQL-8-0-11-出现2059错误"><a href="#解决Navicat-连接MySQL-8-0-11-出现2059错误" class="headerlink" title="解决Navicat 连接MySQL 8.0.11 出现2059错误"></a>解决Navicat 连接MySQL 8.0.11 出现2059错误</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql -uroot -ppassword <span class="comment">#登录</span></span><br><span class="line"></span><br><span class="line">use mysql; <span class="comment">#选择数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ---&gt;  select user,plugin from user where user=&#x27;root&#x27;;   查看加密方式</span></span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;password&#x27;</span> PASSWORD EXPIRE NEVER; <span class="comment">#更改加密方式</span></span><br><span class="line"></span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;password&#x27;</span>; <span class="comment">#更新用户密码</span></span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES; <span class="comment">#刷新权限</span></span><br><span class="line"></span><br><span class="line">-----------注-------------</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">修改时出现 ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 错误</span></span><br><span class="line"><span class="string">需要修改数据库的策略</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">查看mysql 初始的密码策略  SHOW VARIABLES LIKE &#x27;validate_password%&#x27;;</span></span><br><span class="line"><span class="string">需要设置密码的验证强度等级，设置 validate_password_policy 的全局参数为 LOW 即可</span></span><br><span class="line"><span class="string">set global validate_password.policy=LOW;</span></span><br><span class="line"><span class="string">当前密码长度为 8 ，如果不介意的话就不用修改了</span></span><br><span class="line"><span class="string"> set global validate_password.length=6; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">update user set password=(&#x27;123.com&#x27;) where user=&#x27;root&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">关于 mysql 密码策略相关参数；</span></span><br><span class="line"><span class="string">1）、validate_password_length  固定密码的总长度；</span></span><br><span class="line"><span class="string">2）、validate_password_dictionary_file 指定密码验证的文件路径；</span></span><br><span class="line"><span class="string">3）、validate_password_mixed_case_count  整个密码中至少要包含大/小写字母的总个数；</span></span><br><span class="line"><span class="string">4）、validate_password_number_count  整个密码中至少要包含阿拉伯数字的个数；</span></span><br><span class="line"><span class="string">5）、validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM；</span></span><br><span class="line"><span class="string">关于 validate_password_policy 的取值：</span></span><br><span class="line"><span class="string">0/LOW：只验证长度；</span></span><br><span class="line"><span class="string">1/MEDIUM：验证长度、数字、大小写、特殊字符；</span></span><br><span class="line"><span class="string">2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；</span></span><br><span class="line"><span class="string">6）、validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；</span></span><br><span class="line"><span class="string">--------------------- </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">-------------（liunx）如果mysql登入密码忘记，--------------------</span><br><span class="line">首先 vim /etc/my.cnf </span><br><span class="line">在[mysql] 下面增加一行  skip-grant-tables</span><br><span class="line">重启mysql重新登入不用输入密码</span><br><span class="line">更具网上的重置更新密码的语法 update user set authentication_string=password(<span class="string">&#x27;123.com&#x27;</span>) where user=<span class="string">&#x27;root&#x27;</span>; 如果报语法错误就使用下面一条，密码已经是加密过的 为mysql  （先查看一样，密码的加密方式是否是 mysql_native_password）是的就是可行的，</span><br><span class="line">update mysql.user set authentication_string=<span class="string">&#x27;*E74858DB86EBA20BC33D0AECAE8A8108C56B17FA where user&#x27;</span>=<span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----查看密码---</span><br><span class="line">select host,user,authentication_string <span class="keyword">from</span> user;</span><br><span class="line"></span><br><span class="line">------------更改mysql远程连接---------------</span><br><span class="line">方式一 直接修改修改  update user set host = <span class="string">&#x27;%&#x27;</span> where user = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">------查看修改后的状态---</span><br><span class="line">select host, user <span class="keyword">from</span> user;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟器安装</title>
      <link href="/archives/1b78260c.html"/>
      <url>/archives/1b78260c.html</url>
      
        <content type="html"><![CDATA[<h2 id="安卓模拟器环境搭建"><a href="#安卓模拟器环境搭建" class="headerlink" title="安卓模拟器环境搭建"></a>安卓模拟器环境搭建</h2><blockquote><p>开发者有时候会用到模拟器来完成一些工作…</p></blockquote><ol><li>安卓安卓模拟器需要安卓java的环境，直接下载<a href="https://www.androiddevtools.cn/">Android SDK</a> 安装时会给我们一个java的下载地址</li><li>然后下载java包，再安装java，安装后没有jre这个模块，</li><li>再安装的jdk目录下的输入 <code>bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</code> 后就会出现了</li><li>配置java, 直接点， 系统变量中， 创建 变量名： <code>JAVA_HOME</code> 变量值： <code>D:\Program Files\Java\jdk</code>, 再系统变量path中，添加，<code>/jdk/bin</code>，<code>jre/bin</code> 目录路径</li><li>配置好java环境后，再 从新点击刚刚下载的 <a href="https://www.androiddevtools.cn/">Android SDK</a> 进行安装，</li><li>安装完成后，再在系统变量中配置一下环境，<br><code>G:\Android\android-sdk\tools</code><br><code>G:\Android\android-sdk\platform-tools</code></li></ol><a id="more"></a><h2 id="Hbuilde使用夜神模拟器时"><a href="#Hbuilde使用夜神模拟器时" class="headerlink" title="Hbuilde使用夜神模拟器时"></a>Hbuilde使用夜神模拟器时</h2><blockquote><p>将 hBuilde的手机端口改成 62001<br>adb connect 127.0.0.1:62001<br>adb devices</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql常用命令</title>
      <link href="/archives/64129a24.html"/>
      <url>/archives/64129a24.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySql-常用命令的基本使用篇章"><a href="#MySql-常用命令的基本使用篇章" class="headerlink" title="MySql 常用命令的基本使用篇章"></a>MySql 常用命令的基本使用篇章</h1><h2 id="初始操作"><a href="#初始操作" class="headerlink" title="初始操作"></a>初始操作</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看所有数据库 </span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"><span class="comment">-- 选择数据库</span></span><br><span class="line"><span class="keyword">use</span> db;</span><br><span class="line"><span class="comment">-- 查看到但钱使用的数据库</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">database</span>();</span><br><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> dbname <span class="keyword">charset</span>=utf8;</span><br><span class="line"><span class="comment">-- 查看当前数据库中所有的表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line">desc 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- sql格式数据导入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span> (数据)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据表</span></span><br><span class="line"><span class="comment">-- 创建班级表 -----</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> classes (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> auto_increment primary <span class="keyword">key</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- students表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> students(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> primary <span class="keyword">key</span> auto_increment <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span> <span class="keyword">unsigned</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">    height <span class="built_in">decimal</span>(<span class="number">5</span>,<span class="number">2</span>),</span><br><span class="line">    gender enum(<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;中性&#x27;</span>,<span class="string">&#x27;保密&#x27;</span>) <span class="keyword">default</span> <span class="string">&#x27;保密&#x27;</span>,</span><br><span class="line">    cls_id <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">    is_delete <span class="built_in">bit</span> <span class="keyword">default</span> <span class="number">0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基础查询---</span></span><br><span class="line"><span class="comment">--查询表格所以字段</span></span><br><span class="line">&gt;&gt; select * from 表名;</span><br><span class="line"><span class="comment">-- 指定字段查询</span></span><br><span class="line">&gt;&gt; select 字1,字2,.. from 表名;</span><br><span class="line"><span class="comment">-- 对于表名 跟字段名长的可以通过 as 别名</span></span><br><span class="line">&gt;&gt; select id as 标号, name as 名字, gender as 性别 from students;</span><br><span class="line"><span class="comment">-- 跟表名起别名</span></span><br><span class="line">&gt;&gt; select s.id,s.name,s.gender from students as s;</span><br><span class="line"><span class="comment">-- 在select后面列前使用distinct可以消除重复的行</span></span><br><span class="line">&gt;&gt; select distinct 列1,... from 表名;</span><br><span class="line">    例：</span><br><span class="line">    &gt;&gt; select distinct gender from students;</span><br></pre></td></tr></table></figure><p><strong>条件查询</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用where子句对表中的数据筛选，结果为true的行会出现在结果集中</span></span><br><span class="line">&gt;&gt; select * from 表名 where 条件;</span><br><span class="line">    例：</span><br><span class="line">    &gt;&gt; select * from students where id=1;</span><br><span class="line"><span class="comment">----where后面支持多重运算符，进行比较</span></span><br><span class="line">    &gt;&gt; 比较运算符 | 逻辑运算符| 模糊查询| 范围查询 | 空判断</span><br><span class="line"><span class="comment">---比较运行符 </span></span><br><span class="line">    <span class="comment">-- 等于: = | 大于: &gt; |大于等于: &gt;= |小于: &lt; | 小于等于: &lt;= | 不等于: != 或 &lt;&gt;</span></span><br><span class="line">&gt;&gt; 例如：</span><br><span class="line">    <span class="comment">-- 例1：查询编号大于3的学生</span></span><br><span class="line">    &gt;&gt; select * from students where id &gt; 3;</span><br><span class="line">    <span class="comment">--例2：查询编号不大于4的学生</span></span><br><span class="line">    &gt;&gt; select * from students where id &lt;= 4;</span><br><span class="line">    <span class="comment">--例3：查询姓名不是“黄蓉”的学生</span></span><br><span class="line">    &gt;&gt; select * from students where name != &#x27;黄蓉&#x27;;</span><br><span class="line">    <span class="comment">--例4：查询没被删除的学生</span></span><br><span class="line">    &gt;&gt; select * from students where is_delete=0;</span><br><span class="line"></span><br><span class="line"><span class="comment">--- 逻辑运算符、</span></span><br><span class="line">    &gt;&gt; and | or | not</span><br><span class="line">&gt;&gt; 例如：</span><br><span class="line">    <span class="comment">--例5：查询编号大于3的女同学</span></span><br><span class="line">    &gt;&gt; select * from students where id &gt; 3 and gender=0;</span><br><span class="line">    <span class="comment">--例6：查询编号小于4或没被删除的学生</span></span><br><span class="line">    &gt;&gt; select * from students where id &lt; 4 or is_delete=0;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模糊查询</span></span><br><span class="line">    like | %表示任意多个任意字符 | _表示一个任意字符</span><br><span class="line">&gt;&gt; 例如：</span><br><span class="line">    <span class="comment">--例7：查询姓黄的学生</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">&#x27;黄%&#x27;</span>;</span><br><span class="line">    <span class="comment">--例8：查询姓黄并且名字是一个字的学生</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">&#x27;黄_&#x27;</span>;</span><br><span class="line">    <span class="comment">--例9：查询姓黄或叫靖的学生</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">&#x27;黄%&#x27;</span> <span class="keyword">or</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">&#x27;%靖&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 范围查询</span></span><br><span class="line">    in 表示在一个非连续的范围内 | between ... and ...表示在一个连续的范围内</span><br><span class="line">&gt;&gt; 例如：</span><br><span class="line">    <span class="comment">--例10：查询编号是1或3或8的学生</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line">    <span class="comment">--例11：查询编号为3至8的学生</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">between</span> <span class="number">3</span> <span class="keyword">and</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">--例12：查询学生是3至8的男生</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">between</span> <span class="number">3</span> <span class="keyword">and</span> <span class="number">8</span> <span class="keyword">and</span> gender=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 空判断</span></span><br><span class="line">    判空 is null  | 判非空is not null</span><br><span class="line">&gt;&gt; 例如：</span><br><span class="line">    <span class="comment">--例13：查询没有填写身高的学生</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> height <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">--例14：查询填写了身高的学生</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> height <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">--例15：查询填写了身高的男生</span></span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> height <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">and</span> gender=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优先级</span></span><br><span class="line">    <span class="comment">--优先级由高到低的顺序为：小括号，not，比较运算符，逻辑运算符</span></span><br><span class="line">    <span class="comment">--and比or先运算，如果同时出现并希望先算or，需要结合()使用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&gt;&gt; delete from 表名 where 条件</span><br><span class="line">如：</span><br><span class="line">&gt;&gt; delete from students where id=5;</span><br><span class="line"></span><br><span class="line"><span class="comment">--逻辑删除，本质就是修改操作,表中有逻辑删除的字段is_delete</span></span><br><span class="line">&gt;&gt; update students set is_delete=1 where id=1;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- 在未登入mysql下进行</span></span><br><span class="line">mysqldump -uroot -p 库名 &gt; python.sql; </span><br><span class="line"><span class="comment">-- 提示输入mysql密码， 在</span></span><br><span class="line"><span class="comment">-- 导入备份数据</span></span><br><span class="line"><span class="comment">-- 库名</span></span><br><span class="line">mysql -uroot -p 库名 &lt; python.sql</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客主题</title>
      <link href="/archives/21ba1a18.html"/>
      <url>/archives/21ba1a18.html</url>
      
        <content type="html"><![CDATA[<h1 id="快的构建博客"><a href="#快的构建博客" class="headerlink" title="快的构建博客"></a>快的构建博客</h1><p><strong>首先准备工作</strong>：  </p><ol><li><p>安装node.js, </p></li><li><p>安装git,  </p></li><li><p>配置好node.js 后安装hexo环境</p></li></ol><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">npm install hexo</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><strong>开始创建blog：</strong>  </p><ol><li>创建一个空的文件夹， 再使用命令，<br> wind使用管理权限打开cmd，或者使用git 使用</li></ol><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><ol start="2"><li>运行博客,再blog根目录下</li></ol><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><ol start="3"><li>运行成功后，初始的博客就搭建完成了，再部署github上面,先需要再GitHub上面创建一个仓库，</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  先再然后再blog根目录下配置</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:YouAge/youage.github.com.git</span>  <span class="comment"># git ssh地址</span></span><br><span class="line"><span class="comment"># 再执行下列命令，编译，提交</span></span><br><span class="line"></span><br><span class="line"><span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">d</span></span><br><span class="line"><span class="comment"># 或者 </span></span><br><span class="line"><span class="string">hexo</span> <span class="string">clean</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><a id="more"></a><ol start="3"><li><p>下列hexo主题参考使用</p><ul><li><p><a href="http://theme-next.iissnan.com/getting-started.html">next主题</a></p></li><li><p><a href="http://theme-next.iissnan.com/third-party-services.html">next第三方插件</a></p></li><li><p><a href="https://bestzuo.cn/posts/blog-establish.html">next深度优化定制</a></p></li><li><p><a href="https://github.com/blinkfox/hexo-theme-matery">本站主题-matery</a></p></li><li><p><a href="https://github.com/jerryc127/hexo-theme-butterfly.git">butterfly主题</a></p></li></ul></li></ol><h2 id="豆瓣插件的使用"><a href="#豆瓣插件的使用" class="headerlink" title="豆瓣插件的使用"></a>豆瓣插件的使用</h2><ul><li>根目录下安装 <code>npm install hexo-douban --save</code></li><li>再根目录下配置_config.xml 文件</li><li><a href="https://github.com/mythsman/hexo-douban">插件地址</a></li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">douban:</span> </span><br><span class="line">  <span class="attr">user:</span> <span class="comment"># 你的豆瓣ID，个人中心 url中的 people/xxxx</span></span><br><span class="line">  <span class="attr">builtin:</span> <span class="literal">false</span>  <span class="comment"># true </span></span><br><span class="line">  <span class="attr">book:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">&#x27;书香满园&#x27;</span>  <span class="comment"># 页面标题</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">&#x27;学如逆水行舟，不进则退&#x27;</span> <span class="comment"># 写在页面前面的化</span></span><br><span class="line">  <span class="attr">movie:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">&#x27;影视基地&#x27;</span> </span><br><span class="line">    <span class="attr">quote:</span> <span class="string">&#x27;一场电影，一部人生&#x27;</span> </span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">20000</span>  <span class="comment"># 请求超时</span></span><br></pre></td></tr></table></figure><ul><li>启动命令:<code>hexo clean &amp;&amp; hexo douban -bgm &amp;&amp; hexo g &amp;&amp; hexo s</code> 注意其中开启hexo-douban的命令中，-bgm代表的是book、game、movie三个参数，如果只需要其中的一部分就只带你想要的那些参数</li></ul><p><img src="/images/17.jpg" alt="插入图片"></p><p><img src="/images/matery.jpg" alt="matery文章设置"></p><h2 id="关于Markdown-的使用和好的编译器"><a href="#关于Markdown-的使用和好的编译器" class="headerlink" title="关于Markdown 的使用和好的编译器"></a>关于Markdown 的使用和好的编译器</h2><h3 id="前期可以使用-IDEA的工具来编写文章，相对很方便，"><a href="#前期可以使用-IDEA的工具来编写文章，相对很方便，" class="headerlink" title="前期可以使用 IDEA的工具来编写文章，相对很方便，"></a>前期可以使用 IDEA的工具来编写文章，相对很方便，</h3><ul><li><p><a href="https://www.jetbrains.com/pycharm/download/">PyCharm</a></p></li><li><p><a href="https://www.jetbrains.com/webstorm/">WebStorm</a></p></li><li><p>在设置中添加创建初始模板，</p></li></ul><p><img src="/images/hexo/pycharm1.jpg"></p><ul><li>相关语法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可用的预定义文件模板变量为：</span><br><span class="line">$ &#123;PROJECT_NAME&#125; - 当前项目的名称。</span><br><span class="line">$ &#123;NAME&#125; - 在文件创建过程中在“新建文件”对话框中指定的新文件的名称。</span><br><span class="line">$ &#123;USER&#125; - 当前用户的登录名。</span><br><span class="line">$ &#123;DATE&#125; - 当前的系统日期。</span><br><span class="line">$ &#123;TIME&#125; - 当前系统时间。</span><br><span class="line">$ &#123;YEAR&#125; - 今年。</span><br><span class="line">$ &#123;MONTH&#125; - 当月。</span><br><span class="line">$ &#123;DAY&#125; - 当月的当天。</span><br><span class="line">$ &#123;HOUR&#125; - 目前的小时。</span><br><span class="line">$ &#123;MINUTE&#125; - 当前分钟。</span><br><span class="line">$ &#123;PRODUCT_NAME&#125; - 将在其中创建文件的IDE的名称。</span><br><span class="line">$ &#123;MONTH_NAME_SHORT&#125; - 月份名称的前3个字母。 示例：1月，2月等</span><br><span class="line">$ &#123;MONTH_NAME_FULL&#125; - 一个月的全名。 示例：1月，2月等</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="Markdown语法记入点常用的"><a href="#Markdown语法记入点常用的" class="headerlink" title="Markdown语法记入点常用的"></a>Markdown语法记入点常用的</h3><hr><h4 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*加粗*</span></span><br><span class="line"><span class="emphasis">*这是倾斜的文字*</span>`</span><br><span class="line"><span class="strong">**<span class="emphasis">*这是斜体加粗<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">~~这是加删除线的文字~~</span></span></span></span></span><br></pre></td></tr></table></figure><ul><li>这是效果</li></ul><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>`<br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p><hr><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><hr><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">****</span>*</span></span></span><br></pre></td></tr></table></figure><hr><hr><hr><hr><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">插入图片</span>](<span class="link">/images/17.jpg &quot;图片title&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/17.jpg" alt="插入图片" title="图片title"></p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">超链接名</span>](<span class="link">超链接地址 &quot;超链接title&quot;</span>)</span><br><span class="line"><span class="bullet">-</span> 超链接title 可以不写</span><br><span class="line"><span class="bullet">-</span> 或者使用html <span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span></span>标签</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.dongzhu.ink/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;本站&quot;</span>&gt;</span></span>本站<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">http:</span>//<span class="attr">baidu.com</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><a href="https://www.dongzhu.ink/">小站</a><br><a href="http://baidu.com/">百度</a></p><p><a href="http://baidu.com/">http://baidu.com</a><br><a href="https://www.dongzhu.ink/" target="本站">本站</a></p><h4 id="视频添加"><a href="#视频添加" class="headerlink" title="视频添加"></a>视频添加</h4><ul><li>使用html的H5标签即可，<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;视频地址&quot;</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">无需列表</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 列表内容</span><br><span class="line"><span class="bullet">+</span> 列表内存</span><br><span class="line"><span class="bullet">*</span> 列表内存</span><br><span class="line"></span><br><span class="line">有序列表</span><br><span class="line"><span class="bullet">1.</span> 列表内容</span><br><span class="line"><span class="bullet">2.</span> 列表内容</span><br><span class="line"><span class="bullet">3.</span> 列表内容</span><br><span class="line">...</span><br><span class="line"><span class="bullet">-</span> + <span class="emphasis">* 1. 2. 3. 跟内容之间都要有一个空格</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">#### 列表嵌套</span></span><br><span class="line"><span class="emphasis">  在上一个和下一个敲一个 tab 键</span></span><br><span class="line"><span class="emphasis"></span></span><br></pre></td></tr></table></figure><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line"><span class="bullet">-</span> 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>栏目一</th><th align="center">栏目二</th><th align="right">栏目三</th></tr></thead><tbody><tr><td>1</td><td align="center">1</td><td align="right">1</td></tr><tr><td>2</td><td align="center">2</td><td align="right">2</td></tr><tr><td>3</td><td align="center">3</td><td align="right">3</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 网站建设 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
